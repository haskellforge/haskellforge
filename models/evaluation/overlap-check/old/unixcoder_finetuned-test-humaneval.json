{"input": "<s> -- From a given list of integers, generate a list of rolling maximum element found until given moment <EOL> -- in the sequence. <EOL> -- >>> rolling_max [1, 2, 3, 2, 3, 4, 2] <EOL> -- [1,2,3,3,3,4,4] <EOL> rolling_max :: [Int] -> [Int] <EOL> rolling_max numbers =", "gt": "scanl1 max numbers", "prediction": " take"}
{"input": "<s> -- From a given list of integers, generate a list of rolling maximum element found until given moment <EOL> -- in the sequence. <EOL> -- >>> rolling_max [1, 2, 3, 2, 3, 4, 2] <EOL> -- [1,2,3,3,3,4,4] <EOL> rolling_max :: [Int] -> [Int] <EOL> rolling_max numbers = scanl1", "gt": "max numbers", "prediction": " (+) numbers"}
{"input": "<s> -- Return true if a given number is prime, and false otherwise. <EOL> -- >>> is_prime 6 <EOL> -- False <EOL> -- >>> is_prime 101 <EOL> -- True <EOL> -- >>> is_prime 11 <EOL> -- True <EOL> -- >>> is_prime 13441 <EOL> -- True <EOL> -- >>> is_prime 61 <EOL> -- True <EOL> -- >>> is_prime 4 <EOL> -- False <EOL> -- >>> is_prime 1 <EOL> -- False <EOL> is_prime :: Int -> Bool <EOL> is_prime n = n > 1 && all (\\k ->", "gt": "n `mod` k /= 0) [2..n-1]", "prediction": " k `mod` k == 0) [1..]"}
{"input": "<s> -- Return true if a given number is prime, and false otherwise. <EOL> -- >>> is_prime 6 <EOL> -- False <EOL> -- >>> is_prime 101 <EOL> -- True <EOL> -- >>> is_prime 11 <EOL> -- True <EOL> -- >>> is_prime 13441 <EOL> -- True <EOL> -- >>> is_prime 61 <EOL> -- True <EOL> -- >>> is_prime 4 <EOL> -- False <EOL> -- >>> is_prime 1 <EOL> -- False <EOL> is_prime :: Int -> Bool <EOL> is_prime n =", "gt": "n > 1 && all (\\k -> n `mod` k /= 0) [2..n-1]", "prediction": " n"}
{"input": "<s> -- Return true if a given number is prime, and false otherwise. <EOL> -- >>> is_prime 6 <EOL> -- False <EOL> -- >>> is_prime 101 <EOL> -- True <EOL> -- >>> is_prime 11 <EOL> -- True <EOL> -- >>> is_prime 13441 <EOL> -- True <EOL> -- >>> is_prime 61 <EOL> -- True <EOL> -- >>> is_prime 4 <EOL> -- False <EOL> -- >>> is_prime 1 <EOL> -- False <EOL> is_prime :: Int -> Bool <EOL> is_prime n = n > 1 && all (\\k -> n `mod` k /= 0)", "gt": "[2..n-1]", "prediction": " [1..n]"}
{"input": "<s> -- Return true if a given number is prime, and false otherwise. <EOL> -- >>> is_prime 6 <EOL> -- False <EOL> -- >>> is_prime 101 <EOL> -- True <EOL> -- >>> is_prime 11 <EOL> -- True <EOL> -- >>> is_prime 13441 <EOL> -- True <EOL> -- >>> is_prime 61 <EOL> -- True <EOL> -- >>> is_prime 4 <EOL> -- False <EOL> -- >>> is_prime 1 <EOL> -- False <EOL> is_prime :: Int -> Bool <EOL> is_prime n = n > 1 &&", "gt": "all (\\k -> n `mod` k /= 0) [2..n-1]", "prediction": " n < 10"}
{"input": "<s> -- Given an integer. return a tuple that has the number of even and odd digits respectively. <EOL> -- <EOL> -- Example: <EOL> -- >>> even_odd_count (-12) <EOL> -- (1, 1) <EOL> -- >>> even_odd_count 123 <EOL> -- (1, 2) <EOL> even_odd_count :: Int -> (Int, Int) <EOL> even_odd_count num = (length [i | i <- show (abs num), even (read [i] :: Int)], length [i | i <-", "gt": "show (abs num), odd (read [i] :: Int)])", "prediction": " show (abs num] :: Int])"}
{"input": "<s> -- Given an integer. return a tuple that has the number of even and odd digits respectively. <EOL> -- <EOL> -- Example: <EOL> -- >>> even_odd_count (-12) <EOL> -- (1, 1) <EOL> -- >>> even_odd_count 123 <EOL> -- (1, 2) <EOL> even_odd_count :: Int -> (Int, Int) <EOL> even_odd_count num =", "gt": "(length [i | i <- show (abs num), even (read [i] :: Int)], length [i | i <- show (abs num), odd (read [i] :: Int)])", "prediction": " (num, num)"}
{"input": "<s> -- Given an integer. return a tuple that has the number of even and odd digits respectively. <EOL> -- <EOL> -- Example: <EOL> -- >>> even_odd_count (-12) <EOL> -- (1, 1) <EOL> -- >>> even_odd_count 123 <EOL> -- (1, 2) <EOL> even_odd_count :: Int -> (Int, Int) <EOL> even_odd_count num = (length [i | i <-", "gt": "show (abs num), even (read [i] :: Int)], length [i | i <- show (abs num), odd (read [i] :: Int)])", "prediction": " [1..num], even i])"}
{"input": "<s> -- Concatenate list of strings into a single string <EOL> concatenate :: [String] -> String <EOL> concatenate strings =", "gt": "concat strings", "prediction": " concat"}
{"input": "<s> -- Write a function count_nums which takes an array of integers and returns <EOL> -- the number of elements which has a sum of digits > 0. <EOL> -- If a number is negative, then its first signed digit will be negative: <EOL> -- e.g. -123 has signed digits -1, 2, and 3. <EOL> -- >>> count_nums [] == 0 <EOL> -- >>> count_nums [-1, 11, -11] == 1 <EOL> -- >>> count_nums [1, 1, 2] == 3 <EOL> import Data.Char (digitToInt) <EOL> count_nums :: [Int] -> Int <EOL> count_nums arr = length $ filter", "gt": "(> 0) $ map digitsSum arr", "prediction": " (\\Digit arr"}
{"input": "<s> -- Write a function count_nums which takes an array of integers and returns <EOL> -- the number of elements which has a sum of digits > 0. <EOL> -- If a number is negative, then its first signed digit will be negative: <EOL> -- e.g. -123 has signed digits -1, 2, and 3. <EOL> -- >>> count_nums [] == 0 <EOL> -- >>> count_nums [-1, 11, -11] == 1 <EOL> -- >>> count_nums [1, 1, 2] == 3 <EOL> import Data.Char (digitToInt) <EOL> count_nums :: [Int] -> Int <EOL> count_nums arr = length $ filter (> 0) $ map digitsSum arr <EOL>   where <EOL>     digitsSum n = <EOL>       if n < 0 <EOL>         then negate $ sum $ map digitToInt $ tail $ show n <EOL>         else sum $ map digitToInt", "gt": "$ show n", "prediction": " $ tail $ show n"}
{"input": "<s> -- Write a function count_nums which takes an array of integers and returns <EOL> -- the number of elements which has a sum of digits > 0. <EOL> -- If a number is negative, then its first signed digit will be negative: <EOL> -- e.g. -123 has signed digits -1, 2, and 3. <EOL> -- >>> count_nums [] == 0 <EOL> -- >>> count_nums [-1, 11, -11] == 1 <EOL> -- >>> count_nums [1, 1, 2] == 3 <EOL> import Data.Char (digitToInt) <EOL> count_nums :: [Int] -> Int <EOL> count_nums arr = length $ filter (> 0) $ map digitsSum arr <EOL>   where <EOL>     digitsSum n = <EOL>       if n < 0 <EOL>         then negate $ sum $ map digitToInt $ tail $ show n <EOL>         else", "gt": "sum $ map digitToInt $ show n", "prediction": " n"}
{"input": "<s> -- Write a function count_nums which takes an array of integers and returns <EOL> -- the number of elements which has a sum of digits > 0. <EOL> -- If a number is negative, then its first signed digit will be negative: <EOL> -- e.g. -123 has signed digits -1, 2, and 3. <EOL> -- >>> count_nums [] == 0 <EOL> -- >>> count_nums [-1, 11, -11] == 1 <EOL> -- >>> count_nums [1, 1, 2] == 3 <EOL> import Data.Char (digitToInt) <EOL> count_nums :: [Int] -> Int <EOL> count_nums arr = length $ filter (> 0) $ map digitsSum arr <EOL>   where <EOL>     digitsSum n = <EOL>       if n < 0 <EOL>         then negate $ sum $ map digitToInt", "gt": "$ tail $ show n", "prediction": " digitsSum"}
{"input": "<s> -- Write a function count_nums which takes an array of integers and returns <EOL> -- the number of elements which has a sum of digits > 0. <EOL> -- If a number is negative, then its first signed digit will be negative: <EOL> -- e.g. -123 has signed digits -1, 2, and 3. <EOL> -- >>> count_nums [] == 0 <EOL> -- >>> count_nums [-1, 11, -11] == 1 <EOL> -- >>> count_nums [1, 1, 2] == 3 <EOL> import Data.Char (digitToInt) <EOL> count_nums :: [Int] -> Int <EOL> count_nums arr = length $ filter (> 0) $ map digitsSum arr <EOL>   where <EOL>     digitsSum n = <EOL>       if n < 0 <EOL>         then", "gt": "negate $ sum $ map digitToInt $ tail $ show n", "prediction": " n"}
{"input": "<s> -- Create a function that takes integers, floats, or strings representing <EOL> -- real numbers, and returns the larger variable in its given variable type. <EOL> -- Return Nothing if the values are equal. <EOL> -- Note: If a real number is represented as a string, the floating point might be . or , <EOL> -- <EOL> -- >>> compare_one (IntNumber 1) (FloatNumber 2.5) <EOL> -- Just (FloatNumber 2.5) <EOL> -- >>> compare_one (IntNumber 1) (StringNumber \"2,3\") <EOL> -- Just (StringNumber \"2,3\") <EOL> -- >>> compare_one (StringNumber \"5,1\") (StringNumber \"6\") <EOL> -- Just (StringNumber \"6\") <EOL> -- >>> compare_one (StringNumber \"1\") (IntNumber 1) <EOL> -- Nothing <EOL> data Either3 a b c = IntNumber a | FloatNumber b | StringNumber c deriving (Show, Eq) <EOL> compare_one :: Either3 Int Float String -> Either3 Int Float String -> Maybe (Either3 Int Float String) <EOL> compare_one x y = if xf == yf then Nothing else Just (if xf > yf then x else y) <EOL>   where <EOL>     to_float :: Either3 Int Float String -> Float <EOL>     to_float (IntNumber x) = fromIntegral x <EOL>     to_float (FloatNumber x) = x <EOL>     to_float (StringNumber x) = read (map (\\c -> if c == ',' then '.' else c) x) :: Float <EOL>     xf :: Float <EOL>     xf = to_float x <EOL>     yf :: Float <EOL>     yf =", "gt": "to_float y", "prediction": " to_float yf"}
{"input": "<s> -- Create a function that takes integers, floats, or strings representing <EOL> -- real numbers, and returns the larger variable in its given variable type. <EOL> -- Return Nothing if the values are equal. <EOL> -- Note: If a real number is represented as a string, the floating point might be . or , <EOL> -- <EOL> -- >>> compare_one (IntNumber 1) (FloatNumber 2.5) <EOL> -- Just (FloatNumber 2.5) <EOL> -- >>> compare_one (IntNumber 1) (StringNumber \"2,3\") <EOL> -- Just (StringNumber \"2,3\") <EOL> -- >>> compare_one (StringNumber \"5,1\") (StringNumber \"6\") <EOL> -- Just (StringNumber \"6\") <EOL> -- >>> compare_one (StringNumber \"1\") (IntNumber 1) <EOL> -- Nothing <EOL> data Either3 a b c = IntNumber a | FloatNumber b | StringNumber c deriving (Show, Eq) <EOL> compare_one :: Either3 Int Float String -> Either3 Int Float String -> Maybe (Either3 Int Float String) <EOL> compare_one x y =", "gt": "if xf == yf then Nothing else Just (if xf > yf then x else y)", "prediction": " case"}
{"input": "<s> -- Create a function that takes integers, floats, or strings representing <EOL> -- real numbers, and returns the larger variable in its given variable type. <EOL> -- Return Nothing if the values are equal. <EOL> -- Note: If a real number is represented as a string, the floating point might be . or , <EOL> -- <EOL> -- >>> compare_one (IntNumber 1) (FloatNumber 2.5) <EOL> -- Just (FloatNumber 2.5) <EOL> -- >>> compare_one (IntNumber 1) (StringNumber \"2,3\") <EOL> -- Just (StringNumber \"2,3\") <EOL> -- >>> compare_one (StringNumber \"5,1\") (StringNumber \"6\") <EOL> -- Just (StringNumber \"6\") <EOL> -- >>> compare_one (StringNumber \"1\") (IntNumber 1) <EOL> -- Nothing <EOL> data Either3 a b c = IntNumber a | FloatNumber b | StringNumber c deriving (Show, Eq) <EOL> compare_one :: Either3 Int Float String -> Either3 Int Float String -> Maybe (Either3 Int Float String) <EOL> compare_one x y = if xf == yf then Nothing else Just (if xf > yf then x else y) <EOL>   where <EOL>     to_float :: Either3 Int Float String -> Float <EOL>     to_float (IntNumber x) = fromIntegral x <EOL>     to_float (FloatNumber x) =", "gt": "x", "prediction": " fromIntegral x"}
{"input": "<s> -- Create a function that takes integers, floats, or strings representing <EOL> -- real numbers, and returns the larger variable in its given variable type. <EOL> -- Return Nothing if the values are equal. <EOL> -- Note: If a real number is represented as a string, the floating point might be . or , <EOL> -- <EOL> -- >>> compare_one (IntNumber 1) (FloatNumber 2.5) <EOL> -- Just (FloatNumber 2.5) <EOL> -- >>> compare_one (IntNumber 1) (StringNumber \"2,3\") <EOL> -- Just (StringNumber \"2,3\") <EOL> -- >>> compare_one (StringNumber \"5,1\") (StringNumber \"6\") <EOL> -- Just (StringNumber \"6\") <EOL> -- >>> compare_one (StringNumber \"1\") (IntNumber 1) <EOL> -- Nothing <EOL> data Either3 a b c = IntNumber a | FloatNumber b | StringNumber c deriving (Show, Eq) <EOL> compare_one :: Either3 Int Float String -> Either3 Int Float String -> Maybe (Either3 Int Float String) <EOL> compare_one x y = if xf == yf then", "gt": "Nothing else Just (if xf > yf then x else y)", "prediction": " Just (Right x) else Nothing"}
{"input": "<s> -- Create a function that takes integers, floats, or strings representing <EOL> -- real numbers, and returns the larger variable in its given variable type. <EOL> -- Return Nothing if the values are equal. <EOL> -- Note: If a real number is represented as a string, the floating point might be . or , <EOL> -- <EOL> -- >>> compare_one (IntNumber 1) (FloatNumber 2.5) <EOL> -- Just (FloatNumber 2.5) <EOL> -- >>> compare_one (IntNumber 1) (StringNumber \"2,3\") <EOL> -- Just (StringNumber \"2,3\") <EOL> -- >>> compare_one (StringNumber \"5,1\") (StringNumber \"6\") <EOL> -- Just (StringNumber \"6\") <EOL> -- >>> compare_one (StringNumber \"1\") (IntNumber 1) <EOL> -- Nothing <EOL> data Either3 a b c = IntNumber a | FloatNumber b | StringNumber c deriving (Show, Eq) <EOL> compare_one :: Either3 Int Float String -> Either3 Int Float String -> Maybe (Either3 Int Float String) <EOL> compare_one x y = if xf == yf then Nothing else Just (if xf > yf then x else y) <EOL>   where <EOL>     to_float :: Either3 Int Float String -> Float <EOL>     to_float (IntNumber x) = fromIntegral x <EOL>     to_float (FloatNumber x) = x <EOL>     to_float (StringNumber x) = read (map (\\c -> if c == ',' then", "gt": "'.' else c) x) :: Float", "prediction": " ' ' else c) x)"}
{"input": "<s> import Data.List <EOL> -- Given list of integers, return list in strange order. <EOL> -- Strange sorting, is when you start with the minimum value, <EOL> -- then maximum of the remaining integers, then minimum and so on. <EOL> -- <EOL> -- Examples: <EOL> -- strange_sort_list [1, 2, 3, 4] == [1, 4, 2, 3] <EOL> -- strange_sort_list [5, 5, 5, 5] == [5, 5, 5, 5] <EOL> -- strange_sort_list [] == [] <EOL> strange_sort_list :: [Int] -> [Int] <EOL> strange_sort_list lst = let helper [] _ = [] <EOL>                             helper lst True = minimum lst : helper (delete (minimum lst) lst) False <EOL>                             helper lst False = maximum lst : helper (delete (maximum lst) lst) True <EOL>                         in", "gt": "helper lst True", "prediction": " map helper lst"}
{"input": "<s> import Data.List <EOL> -- Given list of integers, return list in strange order. <EOL> -- Strange sorting, is when you start with the minimum value, <EOL> -- then maximum of the remaining integers, then minimum and so on. <EOL> -- <EOL> -- Examples: <EOL> -- strange_sort_list [1, 2, 3, 4] == [1, 4, 2, 3] <EOL> -- strange_sort_list [5, 5, 5, 5] == [5, 5, 5, 5] <EOL> -- strange_sort_list [] == [] <EOL> strange_sort_list :: [Int] -> [Int] <EOL> strange_sort_list lst =", "gt": "let helper [] _ = []", "prediction": " undefined"}
{"input": "<s> import Data.List <EOL> -- Given list of integers, return list in strange order. <EOL> -- Strange sorting, is when you start with the minimum value, <EOL> -- then maximum of the remaining integers, then minimum and so on. <EOL> -- <EOL> -- Examples: <EOL> -- strange_sort_list [1, 2, 3, 4] == [1, 4, 2, 3] <EOL> -- strange_sort_list [5, 5, 5, 5] == [5, 5, 5, 5] <EOL> -- strange_sort_list [] == [] <EOL> strange_sort_list :: [Int] -> [Int] <EOL> strange_sort_list lst = let helper [] _ = [] <EOL>                             helper lst True =", "gt": "minimum lst : helper (delete (minimum lst) lst) False", "prediction": " lst"}
{"input": "<s> import Data.List <EOL> -- Given list of integers, return list in strange order. <EOL> -- Strange sorting, is when you start with the minimum value, <EOL> -- then maximum of the remaining integers, then minimum and so on. <EOL> -- <EOL> -- Examples: <EOL> -- strange_sort_list [1, 2, 3, 4] == [1, 4, 2, 3] <EOL> -- strange_sort_list [5, 5, 5, 5] == [5, 5, 5, 5] <EOL> -- strange_sort_list [] == [] <EOL> strange_sort_list :: [Int] -> [Int] <EOL> strange_sort_list lst = let helper [] _ = [] <EOL>                             helper lst True = minimum lst : helper (delete (minimum lst) lst) False <EOL>                             helper lst False =", "gt": "maximum lst : helper (delete (maximum lst) lst) True", "prediction": " maximum lst lst"}
{"input": "<s> -- xs represent coefficients of a polynomial. <EOL> -- xs[0] + xs[1] * x + xs[2] * x^2 + .... <EOL> -- Return derivative of this polynomial in the same form. <EOL> -- >>> derivative [3,1,2,4,5] <EOL> -- [1,4,12,20] <EOL> -- >>> derivative [1,2,3] <EOL> -- [2,6] <EOL> derivative :: [Int] -> [Int] <EOL> derivative xs =", "gt": "[i * x | (i, x) <- zip [1..] (tail xs)]", "prediction": " map"}
{"input": "<s> -- xs represent coefficients of a polynomial. <EOL> -- xs[0] + xs[1] * x + xs[2] * x^2 + .... <EOL> -- Return derivative of this polynomial in the same form. <EOL> -- >>> derivative [3,1,2,4,5] <EOL> -- [1,4,12,20] <EOL> -- >>> derivative [1,2,3] <EOL> -- [2,6] <EOL> derivative :: [Int] -> [Int] <EOL> derivative xs = [i * x | (i, x) <-", "gt": "zip [1..] (tail xs)]", "prediction": " zip [0..] xs]"}
{"input": "<s> -- triples_sum_to_zero takes a list of integers as an input. <EOL> -- it returns True if there are three distinct elements in the list that <EOL> -- sum to zero, and False otherwise. <EOL> --  <EOL> -- >>> triples_sum_to_zero [1,3,5,0] <EOL> -- False <EOL> -- >>> triples_sum_to_zero [1,3,-2,1] <EOL> -- True <EOL> -- >>> triples_sum_to_zero [1,2,3,7] <EOL> -- False <EOL> -- >>> triples_sum_to_zero [2,4,-5,3,9,7] <EOL> -- True <EOL> -- >>> triples_sum_to_zero [1] <EOL> -- False <EOL> triples_sum_to_zero :: [Int] -> Bool <EOL> triples_sum_to_zero xs = any (\\(a, b, c) -> a + b + c == 0) $ triples xs <EOL>   where <EOL>     triples :: [Int] -> [(Int, Int, Int)] <EOL>     triples [] = [] <EOL>     triples (x:xs) = [(x, y, z) | y <- xs, z <- tail xs,", "gt": "y /= z] ++ triples xs", "prediction": " x <- xs]"}
{"input": "<s> -- triples_sum_to_zero takes a list of integers as an input. <EOL> -- it returns True if there are three distinct elements in the list that <EOL> -- sum to zero, and False otherwise. <EOL> --  <EOL> -- >>> triples_sum_to_zero [1,3,5,0] <EOL> -- False <EOL> -- >>> triples_sum_to_zero [1,3,-2,1] <EOL> -- True <EOL> -- >>> triples_sum_to_zero [1,2,3,7] <EOL> -- False <EOL> -- >>> triples_sum_to_zero [2,4,-5,3,9,7] <EOL> -- True <EOL> -- >>> triples_sum_to_zero [1] <EOL> -- False <EOL> triples_sum_to_zero :: [Int] -> Bool <EOL> triples_sum_to_zero xs = any (\\(a, b, c) -> a + b + c == 0) $ triples xs <EOL>   where <EOL>     triples :: [Int] -> [(Int, Int, Int)] <EOL>     triples [] = [] <EOL>     triples (x:xs) =", "gt": "[(x, y, z) | y <- xs, z <- tail xs, y /= z] ++ triples xs", "prediction": " ("}
{"input": "<s> -- triples_sum_to_zero takes a list of integers as an input. <EOL> -- it returns True if there are three distinct elements in the list that <EOL> -- sum to zero, and False otherwise. <EOL> --  <EOL> -- >>> triples_sum_to_zero [1,3,5,0] <EOL> -- False <EOL> -- >>> triples_sum_to_zero [1,3,-2,1] <EOL> -- True <EOL> -- >>> triples_sum_to_zero [1,2,3,7] <EOL> -- False <EOL> -- >>> triples_sum_to_zero [2,4,-5,3,9,7] <EOL> -- True <EOL> -- >>> triples_sum_to_zero [1] <EOL> -- False <EOL> triples_sum_to_zero :: [Int] -> Bool <EOL> triples_sum_to_zero xs = any (\\(a, b, c) -> a + b + c == 0) $ triples xs <EOL>   where <EOL>     triples :: [Int] -> [(Int, Int, Int)] <EOL>     triples [] =", "gt": "[]", "prediction": " []"}
{"input": "<s> -- triples_sum_to_zero takes a list of integers as an input. <EOL> -- it returns True if there are three distinct elements in the list that <EOL> -- sum to zero, and False otherwise. <EOL> --  <EOL> -- >>> triples_sum_to_zero [1,3,5,0] <EOL> -- False <EOL> -- >>> triples_sum_to_zero [1,3,-2,1] <EOL> -- True <EOL> -- >>> triples_sum_to_zero [1,2,3,7] <EOL> -- False <EOL> -- >>> triples_sum_to_zero [2,4,-5,3,9,7] <EOL> -- True <EOL> -- >>> triples_sum_to_zero [1] <EOL> -- False <EOL> triples_sum_to_zero :: [Int] -> Bool <EOL> triples_sum_to_zero xs = any (\\(a, b, c) -> a + b + c == 0) $ triples xs <EOL>   where <EOL>     triples :: [Int] -> [(Int, Int, Int)] <EOL>     triples [] = [] <EOL>     triples (x:xs) = [(x, y, z) | y <- xs, z <-", "gt": "tail xs, y /= z] ++ triples xs", "prediction": " xs]"}
{"input": "<s> -- triples_sum_to_zero takes a list of integers as an input. <EOL> -- it returns True if there are three distinct elements in the list that <EOL> -- sum to zero, and False otherwise. <EOL> --  <EOL> -- >>> triples_sum_to_zero [1,3,5,0] <EOL> -- False <EOL> -- >>> triples_sum_to_zero [1,3,-2,1] <EOL> -- True <EOL> -- >>> triples_sum_to_zero [1,2,3,7] <EOL> -- False <EOL> -- >>> triples_sum_to_zero [2,4,-5,3,9,7] <EOL> -- True <EOL> -- >>> triples_sum_to_zero [1] <EOL> -- False <EOL> triples_sum_to_zero :: [Int] -> Bool <EOL> triples_sum_to_zero xs =", "gt": "any (\\(a, b, c) -> a + b + c == 0) $ triples xs", "prediction": " all"}
{"input": "<s> -- Given two lists operator, and operand. The first list has basic algebra operations, and <EOL> -- the second list is a list of integers. Use the two given lists to build the algebric <EOL> -- expression and return the evaluation of this expression. <EOL> -- <EOL> -- The basic algebra operations: <EOL> -- Addition ( + ) <EOL> -- Subtraction ( - ) <EOL> -- Multiplication ( * ) <EOL> -- Floor division ( // ) <EOL> -- Exponentiation ( ** ) <EOL> -- <EOL> -- Example: <EOL> -- >>> do_algebra [\"+\", \"*\", \"-\"] [2, 3, 4, 5] <EOL> -- 9 <EOL> -- <EOL> -- Note: <EOL> --     The length of operator list is equal to the length of operand list minus one. <EOL> --     Operand is a list of of non-negative integers. <EOL> --     Operator list has at least one operator, and operand list has at least two operands. <EOL> do_algebra :: [String] -> [Int] -> Int <EOL> do_algebra operators operands = head (snd (foldl (\\(operators, operands) operator -> applyOperator operator operators operands 0 (length operators)) (operators, operands) operator_order)) <EOL>   where <EOL>     operator_order :: [String] <EOL>     operator_order = [\"**\", \"//\", \"*\", \"+\", \"-\"] <EOL>     applyOperator operator operators operands index length <EOL>       | index >= length = (operators, operands) <EOL>       | operator /= operators !! index = applyOperator operator operators operands (index + 1) length <EOL>       | otherwise =", "gt": "applyOperator operator (newOperators) (newOperands) (index + 1) (length - 1)", "prediction": " (_order"}
{"input": "<s> -- Given two lists operator, and operand. The first list has basic algebra operations, and <EOL> -- the second list is a list of integers. Use the two given lists to build the algebric <EOL> -- expression and return the evaluation of this expression. <EOL> -- <EOL> -- The basic algebra operations: <EOL> -- Addition ( + ) <EOL> -- Subtraction ( - ) <EOL> -- Multiplication ( * ) <EOL> -- Floor division ( // ) <EOL> -- Exponentiation ( ** ) <EOL> -- <EOL> -- Example: <EOL> -- >>> do_algebra [\"+\", \"*\", \"-\"] [2, 3, 4, 5] <EOL> -- 9 <EOL> -- <EOL> -- Note: <EOL> --     The length of operator list is equal to the length of operand list minus one. <EOL> --     Operand is a list of of non-negative integers. <EOL> --     Operator list has at least one operator, and operand list has at least two operands. <EOL> do_algebra :: [String] -> [Int] -> Int <EOL> do_algebra operators operands = head (snd (foldl (\\(operators, operands) operator -> applyOperator operator operators operands 0 (length operators)) (operators, operands) operator_order)) <EOL>   where <EOL>     operator_order :: [String] <EOL>     operator_order = [\"**\", \"//\", \"*\", \"+\", \"-\"] <EOL>     applyOperator operator operators operands index length <EOL>       | index >= length = (operators, operands) <EOL>       | operator /= operators !! index = applyOperator operator operators operands (index + 1) length <EOL>       | otherwise = applyOperator operator (newOperators) (newOperands) (index + 1) (length - 1) <EOL>       where <EOL>         newOperands :: [Int] <EOL>         newOperands = take index operands ++ [newOperand] ++ (drop (index + 2) operands) <EOL>         newOperand =", "gt": "case operator of", "prediction": " applyOperator operator (take index operand) (drop index operand)"}
{"input": "<s> -- Given two lists operator, and operand. The first list has basic algebra operations, and <EOL> -- the second list is a list of integers. Use the two given lists to build the algebric <EOL> -- expression and return the evaluation of this expression. <EOL> -- <EOL> -- The basic algebra operations: <EOL> -- Addition ( + ) <EOL> -- Subtraction ( - ) <EOL> -- Multiplication ( * ) <EOL> -- Floor division ( // ) <EOL> -- Exponentiation ( ** ) <EOL> -- <EOL> -- Example: <EOL> -- >>> do_algebra [\"+\", \"*\", \"-\"] [2, 3, 4, 5] <EOL> -- 9 <EOL> -- <EOL> -- Note: <EOL> --     The length of operator list is equal to the length of operand list minus one. <EOL> --     Operand is a list of of non-negative integers. <EOL> --     Operator list has at least one operator, and operand list has at least two operands. <EOL> do_algebra :: [String] -> [Int] -> Int <EOL> do_algebra operators operands = head (snd (foldl (\\(operators, operands) operator -> applyOperator operator operators operands 0 (length operators)) (operators, operands) operator_order)) <EOL>   where <EOL>     operator_order :: [String] <EOL>     operator_order = [\"**\", \"//\", \"*\", \"+\", \"-\"] <EOL>     applyOperator operator operators operands index length <EOL>       | index >= length =", "gt": "(operators, operands)", "prediction": " return operator"}
{"input": "<s> -- Given two lists operator, and operand. The first list has basic algebra operations, and <EOL> -- the second list is a list of integers. Use the two given lists to build the algebric <EOL> -- expression and return the evaluation of this expression. <EOL> -- <EOL> -- The basic algebra operations: <EOL> -- Addition ( + ) <EOL> -- Subtraction ( - ) <EOL> -- Multiplication ( * ) <EOL> -- Floor division ( // ) <EOL> -- Exponentiation ( ** ) <EOL> -- <EOL> -- Example: <EOL> -- >>> do_algebra [\"+\", \"*\", \"-\"] [2, 3, 4, 5] <EOL> -- 9 <EOL> -- <EOL> -- Note: <EOL> --     The length of operator list is equal to the length of operand list minus one. <EOL> --     Operand is a list of of non-negative integers. <EOL> --     Operator list has at least one operator, and operand list has at least two operands. <EOL> do_algebra :: [String] -> [Int] -> Int <EOL> do_algebra operators operands = head (snd (foldl (\\(operators, operands) operator -> applyOperator operator operators operands 0 (length operators)) (operators, operands) operator_order)) <EOL>   where <EOL>     operator_order :: [String] <EOL>     operator_order = [\"**\", \"//\", \"*\", \"+\", \"-\"] <EOL>     applyOperator operator operators operands index length <EOL>       | index >= length = (operators, operands) <EOL>       | operator /= operators !! index = applyOperator operator operators operands (index + 1) length <EOL>       | otherwise = applyOperator operator (newOperators) (newOperands) (index + 1) (length - 1) <EOL>       where <EOL>         newOperands :: [Int] <EOL>         newOperands = take index operands ++ [newOperand] ++ (drop (index + 2) operands) <EOL>         newOperand = case operator of <EOL>           \"*\" -> operands !! index * operands !! (index + 1) <EOL>           \"//\" -> operands !! index `div` operands !! (index + 1) <EOL>           \"+\" -> operands !! index + operands !! (index + 1) <EOL>           \"-\" ->", "gt": "operands !! index - operands !! (index + 1)", "prediction": " operand !! index - 1"}
{"input": "<s> -- Given two lists operator, and operand. The first list has basic algebra operations, and <EOL> -- the second list is a list of integers. Use the two given lists to build the algebric <EOL> -- expression and return the evaluation of this expression. <EOL> -- <EOL> -- The basic algebra operations: <EOL> -- Addition ( + ) <EOL> -- Subtraction ( - ) <EOL> -- Multiplication ( * ) <EOL> -- Floor division ( // ) <EOL> -- Exponentiation ( ** ) <EOL> -- <EOL> -- Example: <EOL> -- >>> do_algebra [\"+\", \"*\", \"-\"] [2, 3, 4, 5] <EOL> -- 9 <EOL> -- <EOL> -- Note: <EOL> --     The length of operator list is equal to the length of operand list minus one. <EOL> --     Operand is a list of of non-negative integers. <EOL> --     Operator list has at least one operator, and operand list has at least two operands. <EOL> do_algebra :: [String] -> [Int] -> Int <EOL> do_algebra operators operands = head (snd (foldl (\\(operators, operands) operator -> applyOperator operator operators operands 0 (length operators)) (operators, operands) operator_order)) <EOL>   where <EOL>     operator_order :: [String] <EOL>     operator_order = [\"**\", \"//\", \"*\", \"+\", \"-\"] <EOL>     applyOperator operator operators operands index length <EOL>       | index >= length = (operators, operands) <EOL>       | operator /= operators !! index = applyOperator operator operators operands (index + 1) length <EOL>       | otherwise = applyOperator operator (newOperators) (newOperands) (index + 1) (length - 1) <EOL>       where <EOL>         newOperands :: [Int] <EOL>         newOperands = take index operands ++ [newOperand] ++ (drop (index + 2) operands) <EOL>         newOperand = case operator of <EOL>           \"*\" ->", "gt": "operands !! index * operands !! (index + 1)", "prediction": " \"*\""}
{"input": "<s> -- This function takes two positive numbers x and y and returns the <EOL> -- biggest even integer number that is in the range [x, y] inclusive. If <EOL> -- there's no such number, then the function should return -1. <EOL> -- <EOL> -- For example: <EOL> -- choose_num 12 15 = 14 <EOL> -- choose_num 13 12 = -1 <EOL> choose_num :: Int -> Int -> Int <EOL> choose_num x y <EOL>   | x >", "gt": "y = -1", "prediction": " y = -1"}
{"input": "<s> -- This function takes two positive numbers x and y and returns the <EOL> -- biggest even integer number that is in the range [x, y] inclusive. If <EOL> -- there's no such number, then the function should return -1. <EOL> -- <EOL> -- For example: <EOL> -- choose_num 12 15 = 14 <EOL> -- choose_num 13 12 = -1 <EOL> choose_num :: Int -> Int -> Int <EOL> choose_num x y <EOL>   | x > y = -1 <EOL>   | y `mod`", "gt": "2 == 0 = y", "prediction": " x == 0 = -1"}
{"input": "<s> -- This function takes two positive numbers x and y and returns the <EOL> -- biggest even integer number that is in the range [x, y] inclusive. If <EOL> -- there's no such number, then the function should return -1. <EOL> -- <EOL> -- For example: <EOL> -- choose_num 12 15 = 14 <EOL> -- choose_num 13 12 = -1 <EOL> choose_num :: Int -> Int -> Int <EOL> choose_num x y <EOL>   | x > y = -1 <EOL>   | y `mod` 2 == 0 = y <EOL>   | x == y =", "gt": "-1", "prediction": " x"}
{"input": "<s> -- This function takes two positive numbers x and y and returns the <EOL> -- biggest even integer number that is in the range [x, y] inclusive. If <EOL> -- there's no such number, then the function should return -1. <EOL> -- <EOL> -- For example: <EOL> -- choose_num 12 15 = 14 <EOL> -- choose_num 13 12 = -1 <EOL> choose_num :: Int -> Int -> Int <EOL> choose_num x y <EOL>   | x > y = -1 <EOL>   | y `mod` 2 == 0 = y <EOL>   | x ==", "gt": "y = -1", "prediction": " y = x"}
{"input": "<s> -- This function takes two positive numbers x and y and returns the <EOL> -- biggest even integer number that is in the range [x, y] inclusive. If <EOL> -- there's no such number, then the function should return -1. <EOL> -- <EOL> -- For example: <EOL> -- choose_num 12 15 = 14 <EOL> -- choose_num 13 12 = -1 <EOL> choose_num :: Int -> Int -> Int <EOL> choose_num x y <EOL>   | x > y = -1 <EOL>   | y `mod` 2 == 0 = y <EOL>   | x == y = -1 <EOL>   | otherwise =", "gt": "y - 1", "prediction": " x"}
{"input": "<s> -- Given a list of numbers, return whether or not they are sorted <EOL> -- in ascending order. If list has more than 1 duplicate of the same <EOL> -- number, return False. Assume no negative numbers and only integers. <EOL> --  <EOL> -- Examples <EOL> -- is_sorted [5] \u279e True <EOL> -- is_sorted [1, 2, 3, 4, 5] \u279e True <EOL> -- is_sorted [1, 3, 2, 4, 5] \u279e False <EOL> -- is_sorted [1, 2, 3, 4, 5, 6] \u279e True <EOL> -- is_sorted [1, 2, 3, 4, 5, 6, 7] \u279e True <EOL> -- is_sorted [1, 3, 2, 4, 5, 6, 7] \u279e False <EOL> -- is_sorted [1, 2, 2, 3, 3, 4] \u279e True <EOL> -- is_sorted [1, 2, 2, 2, 3, 4] \u279e False <EOL> import Data.List (nub) <EOL> is_sorted :: [Int] -> Bool <EOL> is_sorted lst = length (nub lst) == length lst &&", "gt": "all (uncurry (<=)) (zip lst (tail lst))", "prediction": " all"}
{"input": "<s> -- Given a list of numbers, return whether or not they are sorted <EOL> -- in ascending order. If list has more than 1 duplicate of the same <EOL> -- number, return False. Assume no negative numbers and only integers. <EOL> --  <EOL> -- Examples <EOL> -- is_sorted [5] \u279e True <EOL> -- is_sorted [1, 2, 3, 4, 5] \u279e True <EOL> -- is_sorted [1, 3, 2, 4, 5] \u279e False <EOL> -- is_sorted [1, 2, 3, 4, 5, 6] \u279e True <EOL> -- is_sorted [1, 2, 3, 4, 5, 6, 7] \u279e True <EOL> -- is_sorted [1, 3, 2, 4, 5, 6, 7] \u279e False <EOL> -- is_sorted [1, 2, 2, 3, 3, 4] \u279e True <EOL> -- is_sorted [1, 2, 2, 2, 3, 4] \u279e False <EOL> import Data.List (nub) <EOL> is_sorted :: [Int] -> Bool <EOL> is_sorted lst =", "gt": "length (nub lst) == length lst && all (uncurry (<=)) (zip lst (tail lst))", "prediction": " all"}
{"input": "<s> -- For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list. <EOL> -- Empty sum should be equal to 0 and empty product should be equal to 1. <EOL> -- >>> sum_product [] <EOL> -- (0,1) <EOL> -- >>> sum_product [1, 2, 3, 4] <EOL> -- (10,24) <EOL> sum_product :: [Int] -> (Int, Int) <EOL> sum_product numbers =", "gt": "(sum numbers, product numbers)", "prediction": " fold"}
{"input": "<s> -- Return only positive numbers in the list. <EOL> get_positive :: [Int] -> [Int] <EOL> get_positive l =", "gt": "[x | x <- l, x > 0]", "prediction": " filter"}
{"input": "<s> -- Return only positive numbers in the list. <EOL> get_positive :: [Int] -> [Int] <EOL> get_positive l = [x | x <- l,", "gt": "x > 0]", "prediction": " x > 0]"}
{"input": "<s> -- Given a positive integer, obtain its roman numeral equivalent as a string, <EOL> -- and return it in lowercase. <EOL> -- Restrictions: 1 <= num <= 1000 <EOL> -- <EOL> -- Examples: <EOL> -- >>> int_to_mini_roman 19 <EOL> -- \"xix\" <EOL> -- >>> int_to_mini_roman 152 <EOL> -- \"clii\" <EOL> -- >>> int_to_mini_roman 426 <EOL> -- \"cdxxvi\" <EOL> import Data.Char (toLower) <EOL> int_to_mini_roman :: Int -> String <EOL> int_to_mini_roman number = map toLower $ int_to_mini_roman' number num sym (length num - 1) \"\" <EOL>   where <EOL>     num :: [Int] <EOL>     sym :: [String] <EOL>     num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000] <EOL>     sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] <EOL>     int_to_mini_roman' :: Int -> [Int] -> [String] -> Int -> String -> String <EOL>     int_to_mini_roman' number num sym index res <EOL>       | index < 0 = res <EOL>       | number == 0 = res <EOL>       | num !! index <= number = int_to_mini_roman' (number - num !! index) num sym index (res ++ sym !! index) <EOL>       | otherwise =", "gt": "int_to_mini_roman' number num sym (index - 1) res", "prediction": " res"}
{"input": "<s> -- Given a positive integer, obtain its roman numeral equivalent as a string, <EOL> -- and return it in lowercase. <EOL> -- Restrictions: 1 <= num <= 1000 <EOL> -- <EOL> -- Examples: <EOL> -- >>> int_to_mini_roman 19 <EOL> -- \"xix\" <EOL> -- >>> int_to_mini_roman 152 <EOL> -- \"clii\" <EOL> -- >>> int_to_mini_roman 426 <EOL> -- \"cdxxvi\" <EOL> import Data.Char (toLower) <EOL> int_to_mini_roman :: Int -> String <EOL> int_to_mini_roman number = map toLower $ int_to_mini_roman' number num sym (length num - 1) \"\" <EOL>   where <EOL>     num :: [Int] <EOL>     sym :: [String] <EOL>     num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000] <EOL>     sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] <EOL>     int_to_mini_roman' :: Int -> [Int] -> [String] -> Int -> String -> String <EOL>     int_to_mini_roman' number num sym index res <EOL>       | index < 0 = res <EOL>       | number == 0 = res <EOL>       | num !! index <= number =", "gt": "int_to_mini_roman' (number - num !! index) num sym index (res ++ sym !! index)", "prediction": " ["}
{"input": "<s> -- Given a positive integer, obtain its roman numeral equivalent as a string, <EOL> -- and return it in lowercase. <EOL> -- Restrictions: 1 <= num <= 1000 <EOL> -- <EOL> -- Examples: <EOL> -- >>> int_to_mini_roman 19 <EOL> -- \"xix\" <EOL> -- >>> int_to_mini_roman 152 <EOL> -- \"clii\" <EOL> -- >>> int_to_mini_roman 426 <EOL> -- \"cdxxvi\" <EOL> import Data.Char (toLower) <EOL> int_to_mini_roman :: Int -> String <EOL> int_to_mini_roman number = map toLower $ int_to_mini_roman' number num sym (length num - 1) \"\" <EOL>   where <EOL>     num :: [Int] <EOL>     sym :: [String] <EOL>     num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000] <EOL>     sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] <EOL>     int_to_mini_roman' :: Int -> [Int] -> [String] -> Int -> String -> String <EOL>     int_to_mini_roman' number num sym index res <EOL>       | index < 0 = res <EOL>       | number == 0 =", "gt": "res", "prediction": " []"}
{"input": "<s> -- Given a positive integer, obtain its roman numeral equivalent as a string, <EOL> -- and return it in lowercase. <EOL> -- Restrictions: 1 <= num <= 1000 <EOL> -- <EOL> -- Examples: <EOL> -- >>> int_to_mini_roman 19 <EOL> -- \"xix\" <EOL> -- >>> int_to_mini_roman 152 <EOL> -- \"clii\" <EOL> -- >>> int_to_mini_roman 426 <EOL> -- \"cdxxvi\" <EOL> import Data.Char (toLower) <EOL> int_to_mini_roman :: Int -> String <EOL> int_to_mini_roman number = map toLower $ int_to_mini_roman' number num sym (length num - 1) \"\" <EOL>   where <EOL>     num :: [Int] <EOL>     sym :: [String] <EOL>     num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000] <EOL>     sym =", "gt": "[\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"]", "prediction": " [ toLower sym"}
{"input": "<s> -- Given a positive integer, obtain its roman numeral equivalent as a string, <EOL> -- and return it in lowercase. <EOL> -- Restrictions: 1 <= num <= 1000 <EOL> -- <EOL> -- Examples: <EOL> -- >>> int_to_mini_roman 19 <EOL> -- \"xix\" <EOL> -- >>> int_to_mini_roman 152 <EOL> -- \"clii\" <EOL> -- >>> int_to_mini_roman 426 <EOL> -- \"cdxxvi\" <EOL> import Data.Char (toLower) <EOL> int_to_mini_roman :: Int -> String <EOL> int_to_mini_roman number = map toLower $ int_to_mini_roman' number num sym (length num - 1) \"\" <EOL>   where <EOL>     num :: [Int] <EOL>     sym :: [String] <EOL>     num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000] <EOL>     sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] <EOL>     int_to_mini_roman' :: Int -> [Int] -> [String] -> Int -> String -> String <EOL>     int_to_mini_roman' number num sym index res <EOL>       | index < 0 =", "gt": "res", "prediction": " []"}
{"input": "<s> -- This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a <EOL> -- multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not <EOL> -- change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. <EOL> -- <EOL> -- Examples: <EOL> -- >>> sum_squares [1,2,3] <EOL> -- 6 <EOL> -- >>> sum_squares [] <EOL> -- 0 <EOL> -- >>> sum_squares [-1,-5,2,-1,-5] <EOL> -- -126 <EOL> sum_squares :: [Int] -> Int <EOL> sum_squares lst = sum_squares' lst 0 0 <EOL>   where <EOL>     sum_squares' :: [Int] -> Int -> Int -> Int <EOL>     sum_squares' [] sum _ =", "gt": "sum", "prediction": " sum"}
{"input": "<s> -- This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a <EOL> -- multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not <EOL> -- change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. <EOL> -- <EOL> -- Examples: <EOL> -- >>> sum_squares [1,2,3] <EOL> -- 6 <EOL> -- >>> sum_squares [] <EOL> -- 0 <EOL> -- >>> sum_squares [-1,-5,2,-1,-5] <EOL> -- -126 <EOL> sum_squares :: [Int] -> Int <EOL> sum_squares lst =", "gt": "sum_squares' lst 0 0", "prediction": " sum (map square lst)"}
{"input": "<s> -- This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a <EOL> -- multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not <EOL> -- change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. <EOL> -- <EOL> -- Examples: <EOL> -- >>> sum_squares [1,2,3] <EOL> -- 6 <EOL> -- >>> sum_squares [] <EOL> -- 0 <EOL> -- >>> sum_squares [-1,-5,2,-1,-5] <EOL> -- -126 <EOL> sum_squares :: [Int] -> Int <EOL> sum_squares lst = sum_squares' lst 0 0 <EOL>   where <EOL>     sum_squares' :: [Int] -> Int -> Int -> Int <EOL>     sum_squares' [] sum _ = sum <EOL>     sum_squares' (x : xs) sum index <EOL>       | index `mod` 3 == 0 = sum_squares' xs (sum + x ^ 2) (index + 1) <EOL>       | index `mod` 4 == 0 =", "gt": "sum_squares' xs (sum + x ^ 3) (index + 1)", "prediction": " sums"}
{"input": "<s> -- This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a <EOL> -- multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not <EOL> -- change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. <EOL> -- <EOL> -- Examples: <EOL> -- >>> sum_squares [1,2,3] <EOL> -- 6 <EOL> -- >>> sum_squares [] <EOL> -- 0 <EOL> -- >>> sum_squares [-1,-5,2,-1,-5] <EOL> -- -126 <EOL> sum_squares :: [Int] -> Int <EOL> sum_squares lst = sum_squares' lst 0 0 <EOL>   where <EOL>     sum_squares' :: [Int] -> Int -> Int -> Int <EOL>     sum_squares' [] sum _ = sum <EOL>     sum_squares' (x : xs) sum index <EOL>       | index `mod` 3 == 0 =", "gt": "sum_squares' xs (sum + x ^ 2) (index + 1)", "prediction": " if"}
{"input": "<s> -- This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a <EOL> -- multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not <EOL> -- change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. <EOL> -- <EOL> -- Examples: <EOL> -- >>> sum_squares [1,2,3] <EOL> -- 6 <EOL> -- >>> sum_squares [] <EOL> -- 0 <EOL> -- >>> sum_squares [-1,-5,2,-1,-5] <EOL> -- -126 <EOL> sum_squares :: [Int] -> Int <EOL> sum_squares lst = sum_squares' lst 0 0 <EOL>   where <EOL>     sum_squares' :: [Int] -> Int -> Int -> Int <EOL>     sum_squares' [] sum _ = sum <EOL>     sum_squares' (x : xs) sum index <EOL>       | index `mod` 3 == 0 = sum_squares' xs (sum + x ^ 2) (index + 1) <EOL>       | index `mod` 4 == 0 = sum_squares' xs (sum + x ^ 3) (index + 1) <EOL>       | otherwise =", "gt": "sum_squares' xs (sum + x) (index + 1)", "prediction": " 0"}
{"input": "<s> -- You will be given the name of a class (a string) and a list of extensions. <EOL> -- The extensions are to be used to load additional classes to the class. The <EOL> -- strength of the extension is as follows: Let CAP be the number of the uppercase <EOL> -- letters in the extension's name, and let SM be the number of lowercase letters <EOL> -- in the extension's name, the strength is given by the fraction CAP - SM. <EOL> -- You should find the strongest extension and return a string in this <EOL> -- format: ClassName.StrongestExtensionName. <EOL> -- If there are two or more extensions with the same strength, you should <EOL> -- choose the one that comes first in the list. <EOL> -- For example, if you are given \"Slices\" as the class and a list of the <EOL> -- extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should <EOL> -- return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension <EOL> -- (its strength is -1). <EOL> -- Example: <EOL> -- >>> strongest_extension \"my_class\" [\"AA\", \"Be\", \"CC\"] <EOL> -- \"my_class.AA\" <EOL> import Data.Char (isAlpha, isLower, isUpper) <EOL> strongest_extension :: String -> [String] -> String <EOL> strongest_extension class_name extensions =", "gt": "class_name ++ \".\" ++ strongest", "prediction": " undefined"}
{"input": "<s> -- You will be given the name of a class (a string) and a list of extensions. <EOL> -- The extensions are to be used to load additional classes to the class. The <EOL> -- strength of the extension is as follows: Let CAP be the number of the uppercase <EOL> -- letters in the extension's name, and let SM be the number of lowercase letters <EOL> -- in the extension's name, the strength is given by the fraction CAP - SM. <EOL> -- You should find the strongest extension and return a string in this <EOL> -- format: ClassName.StrongestExtensionName. <EOL> -- If there are two or more extensions with the same strength, you should <EOL> -- choose the one that comes first in the list. <EOL> -- For example, if you are given \"Slices\" as the class and a list of the <EOL> -- extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should <EOL> -- return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension <EOL> -- (its strength is -1). <EOL> -- Example: <EOL> -- >>> strongest_extension \"my_class\" [\"AA\", \"Be\", \"CC\"] <EOL> -- \"my_class.AA\" <EOL> import Data.Char (isAlpha, isLower, isUpper) <EOL> strongest_extension :: String -> [String] -> String <EOL> strongest_extension class_name extensions = class_name ++ \".\" ++ strongest <EOL>   where <EOL>     strongest :: String <EOL>     strongest =", "gt": "head $ filter (\\x -> strength x == maximum (map strength extensions)) extensions", "prediction": " if"}
{"input": "<s> -- You will be given the name of a class (a string) and a list of extensions. <EOL> -- The extensions are to be used to load additional classes to the class. The <EOL> -- strength of the extension is as follows: Let CAP be the number of the uppercase <EOL> -- letters in the extension's name, and let SM be the number of lowercase letters <EOL> -- in the extension's name, the strength is given by the fraction CAP - SM. <EOL> -- You should find the strongest extension and return a string in this <EOL> -- format: ClassName.StrongestExtensionName. <EOL> -- If there are two or more extensions with the same strength, you should <EOL> -- choose the one that comes first in the list. <EOL> -- For example, if you are given \"Slices\" as the class and a list of the <EOL> -- extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should <EOL> -- return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension <EOL> -- (its strength is -1). <EOL> -- Example: <EOL> -- >>> strongest_extension \"my_class\" [\"AA\", \"Be\", \"CC\"] <EOL> -- \"my_class.AA\" <EOL> import Data.Char (isAlpha, isLower, isUpper) <EOL> strongest_extension :: String -> [String] -> String <EOL> strongest_extension class_name extensions = class_name ++ \".\" ++ strongest <EOL>   where <EOL>     strongest :: String <EOL>     strongest = head $ filter (\\x -> strength x == maximum (map strength extensions)) extensions <EOL>     strength x = length [x | x <- x, isAlpha x, isUpper x] -", "gt": "length [x | x <- x, isAlpha x, isLower x]", "prediction": " 1"}
{"input": "<s> -- You will be given the name of a class (a string) and a list of extensions. <EOL> -- The extensions are to be used to load additional classes to the class. The <EOL> -- strength of the extension is as follows: Let CAP be the number of the uppercase <EOL> -- letters in the extension's name, and let SM be the number of lowercase letters <EOL> -- in the extension's name, the strength is given by the fraction CAP - SM. <EOL> -- You should find the strongest extension and return a string in this <EOL> -- format: ClassName.StrongestExtensionName. <EOL> -- If there are two or more extensions with the same strength, you should <EOL> -- choose the one that comes first in the list. <EOL> -- For example, if you are given \"Slices\" as the class and a list of the <EOL> -- extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should <EOL> -- return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension <EOL> -- (its strength is -1). <EOL> -- Example: <EOL> -- >>> strongest_extension \"my_class\" [\"AA\", \"Be\", \"CC\"] <EOL> -- \"my_class.AA\" <EOL> import Data.Char (isAlpha, isLower, isUpper) <EOL> strongest_extension :: String -> [String] -> String <EOL> strongest_extension class_name extensions = class_name ++ \".\" ++ strongest <EOL>   where <EOL>     strongest :: String <EOL>     strongest = head $ filter (\\x -> strength x == maximum (map strength extensions)) extensions <EOL>     strength x =", "gt": "length [x | x <- x, isAlpha x, isUpper x] - length [x | x <- x, isAlpha x, isLower x]", "prediction": " x"}
{"input": "<s> -- You will be given the name of a class (a string) and a list of extensions. <EOL> -- The extensions are to be used to load additional classes to the class. The <EOL> -- strength of the extension is as follows: Let CAP be the number of the uppercase <EOL> -- letters in the extension's name, and let SM be the number of lowercase letters <EOL> -- in the extension's name, the strength is given by the fraction CAP - SM. <EOL> -- You should find the strongest extension and return a string in this <EOL> -- format: ClassName.StrongestExtensionName. <EOL> -- If there are two or more extensions with the same strength, you should <EOL> -- choose the one that comes first in the list. <EOL> -- For example, if you are given \"Slices\" as the class and a list of the <EOL> -- extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should <EOL> -- return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension <EOL> -- (its strength is -1). <EOL> -- Example: <EOL> -- >>> strongest_extension \"my_class\" [\"AA\", \"Be\", \"CC\"] <EOL> -- \"my_class.AA\" <EOL> import Data.Char (isAlpha, isLower, isUpper) <EOL> strongest_extension :: String -> [String] -> String <EOL> strongest_extension class_name extensions = class_name ++ \".\" ++ strongest <EOL>   where <EOL>     strongest :: String <EOL>     strongest = head $ filter (\\x ->", "gt": "strength x == maximum (map strength extensions)) extensions", "prediction": " isAlpha x || isLower x) extensions"}
{"input": "<s> -- You are given a string representing a sentence, <EOL> -- the sentence contains some words separated by a space, <EOL> -- and you have to return a string that contains the words from the original sentence, <EOL> -- whose lengths are prime numbers, <EOL> -- the order of the words in the new string should be the same as the original one. <EOL> -- <EOL> -- Example 1: <EOL> -- >>> words_in_sentence \"This is a test\" <EOL> -- \"is\" <EOL> -- <EOL> -- Example 2: <EOL> -- >>> words_in_sentence \"lets go for swimming\" <EOL> -- \"go for\" <EOL> -- <EOL> -- Constraints: <EOL> -- * 1 <= len(sentence) <= 100 <EOL> -- * sentence contains only letters <EOL> words_in_sentence :: String -> String <EOL> words_in_sentence sentence = unwords $ filter (\\x -> isPrime (length x)) (words sentence) <EOL>   where <EOL>     isPrime :: Int -> Bool <EOL>     isPrime n =", "gt": "n > 1 && all (\\x -> n `mod` x /= 0) [2 .. n - 1]", "prediction": " n"}
{"input": "<s> -- You are given a string representing a sentence, <EOL> -- the sentence contains some words separated by a space, <EOL> -- and you have to return a string that contains the words from the original sentence, <EOL> -- whose lengths are prime numbers, <EOL> -- the order of the words in the new string should be the same as the original one. <EOL> -- <EOL> -- Example 1: <EOL> -- >>> words_in_sentence \"This is a test\" <EOL> -- \"is\" <EOL> -- <EOL> -- Example 2: <EOL> -- >>> words_in_sentence \"lets go for swimming\" <EOL> -- \"go for\" <EOL> -- <EOL> -- Constraints: <EOL> -- * 1 <= len(sentence) <= 100 <EOL> -- * sentence contains only letters <EOL> words_in_sentence :: String -> String <EOL> words_in_sentence sentence = unwords $ filter (\\x ->", "gt": "isPrime (length x)) (words sentence)", "prediction": " length x <= 100) $ words sentence"}
{"input": "<s> -- You are given a string representing a sentence, <EOL> -- the sentence contains some words separated by a space, <EOL> -- and you have to return a string that contains the words from the original sentence, <EOL> -- whose lengths are prime numbers, <EOL> -- the order of the words in the new string should be the same as the original one. <EOL> -- <EOL> -- Example 1: <EOL> -- >>> words_in_sentence \"This is a test\" <EOL> -- \"is\" <EOL> -- <EOL> -- Example 2: <EOL> -- >>> words_in_sentence \"lets go for swimming\" <EOL> -- \"go for\" <EOL> -- <EOL> -- Constraints: <EOL> -- * 1 <= len(sentence) <= 100 <EOL> -- * sentence contains only letters <EOL> words_in_sentence :: String -> String <EOL> words_in_sentence sentence =", "gt": "unwords $ filter (\\x -> isPrime (length x)) (words sentence)", "prediction": " undefined"}
{"input": "<s> -- You are given a string representing a sentence, <EOL> -- the sentence contains some words separated by a space, <EOL> -- and you have to return a string that contains the words from the original sentence, <EOL> -- whose lengths are prime numbers, <EOL> -- the order of the words in the new string should be the same as the original one. <EOL> -- <EOL> -- Example 1: <EOL> -- >>> words_in_sentence \"This is a test\" <EOL> -- \"is\" <EOL> -- <EOL> -- Example 2: <EOL> -- >>> words_in_sentence \"lets go for swimming\" <EOL> -- \"go for\" <EOL> -- <EOL> -- Constraints: <EOL> -- * 1 <= len(sentence) <= 100 <EOL> -- * sentence contains only letters <EOL> words_in_sentence :: String -> String <EOL> words_in_sentence sentence = unwords $", "gt": "filter (\\x -> isPrime (length x)) (words sentence)", "prediction": " words_in_ sentence'"}
{"input": "<s> -- You are given a string representing a sentence, <EOL> -- the sentence contains some words separated by a space, <EOL> -- and you have to return a string that contains the words from the original sentence, <EOL> -- whose lengths are prime numbers, <EOL> -- the order of the words in the new string should be the same as the original one. <EOL> -- <EOL> -- Example 1: <EOL> -- >>> words_in_sentence \"This is a test\" <EOL> -- \"is\" <EOL> -- <EOL> -- Example 2: <EOL> -- >>> words_in_sentence \"lets go for swimming\" <EOL> -- \"go for\" <EOL> -- <EOL> -- Constraints: <EOL> -- * 1 <= len(sentence) <= 100 <EOL> -- * sentence contains only letters <EOL> words_in_sentence :: String -> String <EOL> words_in_sentence sentence = unwords $ filter (\\x -> isPrime (length x)) (words sentence) <EOL>   where <EOL>     isPrime :: Int -> Bool <EOL>     isPrime n = n > 1 &&", "gt": "all (\\x -> n `mod` x /= 0) [2 .. n - 1]", "prediction": " n < 100"}
{"input": "<s> import Data.Char <EOL> import Numeric (showIntAtBase) <EOL> -- Given a positive integer N, return the total sum of its digits in binary. <EOL> -- <EOL> -- Example <EOL> --     For N = 1000, the sum of digits will be 1 the output should be \"1\". <EOL> --     For N = 150, the sum of digits will be 6 the output should be \"110\". <EOL> --     For N = 147, the sum of digits will be 12 the output should be \"1100\". <EOL> -- <EOL> -- Variables: <EOL> --     @N integer <EOL> --          Constraints: 0 \u2264 N \u2264 10000. <EOL> -- Output: <EOL> --      a string of binary number <EOL> solve :: Int -> String <EOL> solve n =", "gt": "showIntAtBase 2 intToDigit (sum (map digitToInt (show n))) \"\"", "prediction": " undefined"}
{"input": "<s> import Data.Char <EOL> import Numeric (showIntAtBase) <EOL> -- Given a positive integer N, return the total sum of its digits in binary. <EOL> -- <EOL> -- Example <EOL> --     For N = 1000, the sum of digits will be 1 the output should be \"1\". <EOL> --     For N = 150, the sum of digits will be 6 the output should be \"110\". <EOL> --     For N = 147, the sum of digits will be 12 the output should be \"1100\". <EOL> -- <EOL> -- Variables: <EOL> --     @N integer <EOL> --          Constraints: 0 \u2264 N \u2264 10000. <EOL> -- Output: <EOL> --      a string of binary number <EOL> solve :: Int -> String <EOL> solve n = showIntAtBase 2 intToDigit", "gt": "(sum (map digitToInt (show n))) \"\"", "prediction": " ( \"\""}
{"input": "<s> import Data.Char <EOL> import Numeric (showIntAtBase) <EOL> -- Given a positive integer N, return the total sum of its digits in binary. <EOL> -- <EOL> -- Example <EOL> --     For N = 1000, the sum of digits will be 1 the output should be \"1\". <EOL> --     For N = 150, the sum of digits will be 6 the output should be \"110\". <EOL> --     For N = 147, the sum of digits will be 12 the output should be \"1100\". <EOL> -- <EOL> -- Variables: <EOL> --     @N integer <EOL> --          Constraints: 0 \u2264 N \u2264 10000. <EOL> -- Output: <EOL> --      a string of binary number <EOL> solve :: Int -> String <EOL> solve n = showIntAtBase 2 intToDigit (sum (map digitToInt", "gt": "(show n))) \"\"", "prediction": " ())"}
{"input": "<s> import Data.Char <EOL> -- For a given string, flip lowercase characters to uppercase and uppercase to lowercase. <EOL> -- >>> flip_case \"Hello\" <EOL> -- \"hELLO\" <EOL> flip_case :: String -> String <EOL> flip_case string = map swap_case string <EOL>     where swap_case c =", "gt": "if isUpper c then toLower c else toUpper c", "prediction": " toUpper c : map toLower c"}
{"input": "<s> import Data.Char <EOL> -- For a given string, flip lowercase characters to uppercase and uppercase to lowercase. <EOL> -- >>> flip_case \"Hello\" <EOL> -- \"hELLO\" <EOL> flip_case :: String -> String <EOL> flip_case string = map swap_case string <EOL>     where swap_case c = if isUpper c then", "gt": "toLower c else toUpper c", "prediction": " toUpper c else c"}
{"input": "<s> import Data.Char <EOL> -- For a given string, flip lowercase characters to uppercase and uppercase to lowercase. <EOL> -- >>> flip_case \"Hello\" <EOL> -- \"hELLO\" <EOL> flip_case :: String -> String <EOL> flip_case string =", "gt": "map swap_case string", "prediction": " map toLower string"}
{"input": "<s> import Data.Char <EOL> -- For a given string, flip lowercase characters to uppercase and uppercase to lowercase. <EOL> -- >>> flip_case \"Hello\" <EOL> -- \"hELLO\" <EOL> flip_case :: String -> String <EOL> flip_case string = map swap_case string <EOL>     where swap_case c = if isUpper c then toLower c else", "gt": "toUpper c", "prediction": " c"}
{"input": "<s> -- You have to write a function which validates a given date string and <EOL> -- returns True if the date is valid otherwise False. <EOL> -- The date is valid if all of the following rules are satisfied: <EOL> -- 1. The date string is not empty. <EOL> -- 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2. <EOL> -- 3. The months should not be less than 1 or higher than 12. <EOL> -- 4. The date should be in the format: mm-dd-yyyy <EOL> -- <EOL> -- for example: <EOL> -- >>> valid_date \"03-11-2000\" <EOL> -- True <EOL> -- >>> valid_date \"15-01-2012\" <EOL> -- False <EOL> -- >>> valid_date \"04-0-2040\" <EOL> -- False <EOL> -- >>> valid_date \"06-04-2020\" <EOL> -- True <EOL> -- >>> valid_date \"06/04/2020\" <EOL> -- False <EOL> import Data.Char (digitToInt) <EOL> valid_date :: String -> Bool <EOL> valid_date date = case splitDate date of <EOL>   Just (m, d, y) -> isValidDate m d y <EOL>   _ -> False <EOL>   where <EOL>     splitDate :: String -> Maybe (Int, Int, Int) <EOL>     splitDate (m1 : m2 : '-' : d1 : d2 : '-' : y1 : y2 : y3 : y4 : []) = <EOL>       Just <EOL>         ( digitToInt m1 * 10 + digitToInt m2, <EOL>           digitToInt d1 * 10 + digitToInt d2, <EOL>           digitToInt y1 * 1000 + digitToInt y2 * 100 + digitToInt y3 * 10 + digitToInt y4 <EOL>         ) <EOL>     splitDate _ = Nothing <EOL>     isValidDate m d y = <EOL>       m >= 1 <EOL>         && m <= 12 <EOL>         && ( m `elem` [1, 3, 5, 7, 8, 10, 12] && d >= 1 && d <= 31 <EOL>                || m `elem` [4, 6, 9, 11] && d >= 1 && d <= 30 <EOL>                || m == 2 && d >= 1 && d <= 29 && (y `mod` 4 /=", "gt": "0 || y `mod` 100 == 0 && y `mod` 400 /= 0)", "prediction": " 0)"}
{"input": "<s> -- You have to write a function which validates a given date string and <EOL> -- returns True if the date is valid otherwise False. <EOL> -- The date is valid if all of the following rules are satisfied: <EOL> -- 1. The date string is not empty. <EOL> -- 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2. <EOL> -- 3. The months should not be less than 1 or higher than 12. <EOL> -- 4. The date should be in the format: mm-dd-yyyy <EOL> -- <EOL> -- for example: <EOL> -- >>> valid_date \"03-11-2000\" <EOL> -- True <EOL> -- >>> valid_date \"15-01-2012\" <EOL> -- False <EOL> -- >>> valid_date \"04-0-2040\" <EOL> -- False <EOL> -- >>> valid_date \"06-04-2020\" <EOL> -- True <EOL> -- >>> valid_date \"06/04/2020\" <EOL> -- False <EOL> import Data.Char (digitToInt) <EOL> valid_date :: String -> Bool <EOL> valid_date date = case splitDate date of <EOL>   Just (m, d, y) -> isValidDate m d y <EOL>   _ -> False <EOL>   where <EOL>     splitDate :: String -> Maybe (Int, Int, Int) <EOL>     splitDate (m1 : m2 : '-' : d1 : d2 : '-' : y1 : y2 : y3 : y4 : []) = <EOL>       Just <EOL>         ( digitToInt m1 * 10 + digitToInt m2, <EOL>           digitToInt d1 * 10 + digitToInt d2, <EOL>           digitToInt y1 * 1000 + digitToInt y2 * 100 + digitToInt y3 * 10 + digitToInt y4 <EOL>         ) <EOL>     splitDate _ = Nothing <EOL>     isValidDate m d y = <EOL>       m >= 1 <EOL>         && m <= 12 <EOL>         && ( m `elem` [1, 3, 5, 7, 8, 10, 12] && d >= 1 && d <= 31 <EOL>                || m `elem` [4, 6, 9, 11] && d", "gt": ">= 1 && d <= 30", "prediction": " <= 1 && d <= 30"}
{"input": "<s> -- You have to write a function which validates a given date string and <EOL> -- returns True if the date is valid otherwise False. <EOL> -- The date is valid if all of the following rules are satisfied: <EOL> -- 1. The date string is not empty. <EOL> -- 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2. <EOL> -- 3. The months should not be less than 1 or higher than 12. <EOL> -- 4. The date should be in the format: mm-dd-yyyy <EOL> -- <EOL> -- for example: <EOL> -- >>> valid_date \"03-11-2000\" <EOL> -- True <EOL> -- >>> valid_date \"15-01-2012\" <EOL> -- False <EOL> -- >>> valid_date \"04-0-2040\" <EOL> -- False <EOL> -- >>> valid_date \"06-04-2020\" <EOL> -- True <EOL> -- >>> valid_date \"06/04/2020\" <EOL> -- False <EOL> import Data.Char (digitToInt) <EOL> valid_date :: String -> Bool <EOL> valid_date date = case splitDate date of <EOL>   Just (m, d, y) -> isValidDate m d y <EOL>   _ -> False <EOL>   where <EOL>     splitDate :: String -> Maybe (Int, Int, Int) <EOL>     splitDate (m1 : m2 : '-' : d1 : d2 : '-' : y1 : y2 : y3 : y4 : []) = <EOL>       Just <EOL>         ( digitToInt m1 * 10 + digitToInt m2, <EOL>           digitToInt d1 * 10 +", "gt": "digitToInt d2,", "prediction": " digitToInt d2 * 10 + digitToInt d3 * 10 + digitToInt d4 * 10) ="}
{"input": "<s> -- You have to write a function which validates a given date string and <EOL> -- returns True if the date is valid otherwise False. <EOL> -- The date is valid if all of the following rules are satisfied: <EOL> -- 1. The date string is not empty. <EOL> -- 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2. <EOL> -- 3. The months should not be less than 1 or higher than 12. <EOL> -- 4. The date should be in the format: mm-dd-yyyy <EOL> -- <EOL> -- for example: <EOL> -- >>> valid_date \"03-11-2000\" <EOL> -- True <EOL> -- >>> valid_date \"15-01-2012\" <EOL> -- False <EOL> -- >>> valid_date \"04-0-2040\" <EOL> -- False <EOL> -- >>> valid_date \"06-04-2020\" <EOL> -- True <EOL> -- >>> valid_date \"06/04/2020\" <EOL> -- False <EOL> import Data.Char (digitToInt) <EOL> valid_date :: String -> Bool <EOL> valid_date date = case splitDate date of <EOL>   Just (m, d, y) -> isValidDate m d y <EOL>   _ -> False <EOL>   where <EOL>     splitDate :: String -> Maybe (Int, Int, Int) <EOL>     splitDate (m1 : m2 : '-' : d1 : d2 : '-' : y1 : y2 : y3 : y4 : []) = <EOL>       Just <EOL>         ( digitToInt m1 * 10 + digitToInt m2, <EOL>           digitToInt d1 * 10 + digitToInt d2, <EOL>           digitToInt y1 * 1000 + digitToInt y2 * 100 + digitToInt y3 * 10 + digitToInt y4 <EOL>         ) <EOL>     splitDate _ = Nothing <EOL>     isValidDate m d y = <EOL>       m >= 1 <EOL>         && m <= 12 <EOL>         && ( m `elem` [1, 3, 5, 7, 8, 10, 12] && d", "gt": ">= 1 && d <= 31", "prediction": " `elem` [1, 3, 5, 7, 8, 10, 12])"}
{"input": "<s> -- You have to write a function which validates a given date string and <EOL> -- returns True if the date is valid otherwise False. <EOL> -- The date is valid if all of the following rules are satisfied: <EOL> -- 1. The date string is not empty. <EOL> -- 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2. <EOL> -- 3. The months should not be less than 1 or higher than 12. <EOL> -- 4. The date should be in the format: mm-dd-yyyy <EOL> -- <EOL> -- for example: <EOL> -- >>> valid_date \"03-11-2000\" <EOL> -- True <EOL> -- >>> valid_date \"15-01-2012\" <EOL> -- False <EOL> -- >>> valid_date \"04-0-2040\" <EOL> -- False <EOL> -- >>> valid_date \"06-04-2020\" <EOL> -- True <EOL> -- >>> valid_date \"06/04/2020\" <EOL> -- False <EOL> import Data.Char (digitToInt) <EOL> valid_date :: String -> Bool <EOL> valid_date date = case splitDate date of <EOL>   Just (m, d, y) -> isValidDate m d y <EOL>   _ -> False <EOL>   where <EOL>     splitDate :: String -> Maybe (Int, Int, Int) <EOL>     splitDate (m1 : m2 : '-' : d1 : d2 : '-' : y1 : y2 : y3 : y4 : []) = <EOL>       Just <EOL>         ( digitToInt m1 * 10 + digitToInt m2, <EOL>           digitToInt d1 * 10 + digitToInt d2, <EOL>           digitToInt y1 * 1000 + digitToInt y2 * 100 + digitToInt y3 * 10 + digitToInt y4 <EOL>         ) <EOL>     splitDate _ = Nothing <EOL>     isValidDate m d y = <EOL>       m >= 1 <EOL>         && m <= 12 <EOL>         && ( m `elem` [1, 3, 5, 7, 8, 10, 12] && d >= 1 && d <= 31 <EOL>                || m `elem`", "gt": "[4, 6, 9, 11] && d >= 1 && d <= 30", "prediction": " [1, 3, 5, 7, 8, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 28, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30,"}
{"input": "<s> import Data.List (sort) <EOL> -- Return True is list elements are monotonically increasing or decreasing. <EOL> -- >>> monotonic [1,2,4,20] <EOL> -- True <EOL> -- >>> monotonic [1,20,4,10] <EOL> -- False <EOL> -- >>> monotonic [4,1,0,-10] <EOL> -- True <EOL> monotonic :: [Int] -> Bool <EOL> monotonic l =", "gt": "l == sort l || l == reverse (sort l)", "prediction": " and"}
{"input": "<s> import Data.List (sort) <EOL> -- Return True is list elements are monotonically increasing or decreasing. <EOL> -- >>> monotonic [1,2,4,20] <EOL> -- True <EOL> -- >>> monotonic [1,20,4,10] <EOL> -- False <EOL> -- >>> monotonic [4,1,0,-10] <EOL> -- True <EOL> monotonic :: [Int] -> Bool <EOL> monotonic l = l == sort l || l ==", "gt": "reverse (sort l)", "prediction": " n l"}
{"input": "<s> -- You will be given a string of words separated by commas or spaces. Your task is <EOL> -- to split the string into words and return an array of the words. <EOL> -- <EOL> -- For example: <EOL> -- >>> words_string \"Hi, my name is John\" <EOL> -- [\"Hi\",\"my\",\"name\",\"is\",\"John\"] <EOL> -- >>> words_string \"One, two, three, four, five, six\" <EOL> -- [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"] <EOL> words_string :: String -> [String] <EOL> words_string s =", "gt": "words $", "prediction": " words s"}
{"input": "<s> -- You will be given a string of words separated by commas or spaces. Your task is <EOL> -- to split the string into words and return an array of the words. <EOL> -- <EOL> -- For example: <EOL> -- >>> words_string \"Hi, my name is John\" <EOL> -- [\"Hi\",\"my\",\"name\",\"is\",\"John\"] <EOL> -- >>> words_string \"One, two, three, four, five, six\" <EOL> -- [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"] <EOL> words_string :: String -> [String] <EOL> words_string s = words $ <EOL>         map <EOL>         ( \\c -> <EOL>             if c == ',' <EOL>                 then ' ' <EOL>                 else", "gt": "c", "prediction": " c"}
{"input": "<s> -- You will be given a string of words separated by commas or spaces. Your task is <EOL> -- to split the string into words and return an array of the words. <EOL> -- <EOL> -- For example: <EOL> -- >>> words_string \"Hi, my name is John\" <EOL> -- [\"Hi\",\"my\",\"name\",\"is\",\"John\"] <EOL> -- >>> words_string \"One, two, three, four, five, six\" <EOL> -- [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"] <EOL> words_string :: String -> [String] <EOL> words_string s = words $ <EOL>         map <EOL>         ( \\c -> <EOL>             if c == ',' <EOL>                 then", "gt": "' '", "prediction": " concat"}
{"input": "<s> -- You will be given a string of words separated by commas or spaces. Your task is <EOL> -- to split the string into words and return an array of the words. <EOL> -- <EOL> -- For example: <EOL> -- >>> words_string \"Hi, my name is John\" <EOL> -- [\"Hi\",\"my\",\"name\",\"is\",\"John\"] <EOL> -- >>> words_string \"One, two, three, four, five, six\" <EOL> -- [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"] <EOL> words_string :: String -> [String] <EOL> words_string s = words $ <EOL>         map <EOL>         ( \\c -> <EOL>             if c ==", "gt": "','", "prediction": " '.'"}
{"input": "<s> import Data.List <EOL> -- Filter an input list of strings only for ones that contain given substring <EOL> -- >>> filter_by_substring [] \"a\" <EOL> -- [] <EOL> -- >>> filter_by_substring [\"abc\", \"bacd\", \"cde\", \"array\"] \"a\" <EOL> -- [\"abc\",\"bacd\",\"array\"] <EOL> filter_by_substring :: [String] -> String -> [String] <EOL> filter_by_substring strings substring = [x | x <- strings,", "gt": "substring `isInfixOf` x]", "prediction": " is `isInfixOf` x]"}
{"input": "<s> import Data.List <EOL> -- Filter an input list of strings only for ones that contain given substring <EOL> -- >>> filter_by_substring [] \"a\" <EOL> -- [] <EOL> -- >>> filter_by_substring [\"abc\", \"bacd\", \"cde\", \"array\"] \"a\" <EOL> -- [\"abc\",\"bacd\",\"array\"] <EOL> filter_by_substring :: [String] -> String -> [String] <EOL> filter_by_substring strings substring =", "gt": "[x | x <- strings, substring `isInfixOf` x]", "prediction": " filter"}
{"input": "<s> -- Given a string representing a space separated lowercase letters, return a dictionary <EOL> -- of the letter with the most repetition and containing the corresponding count. <EOL> -- If several letters have the same occurrence, return all of them. <EOL> -- <EOL> -- Example: <EOL> -- histogram \"a b c\" == [('a',1),('b',1),('c',1)] <EOL> -- histogram \"a b b a\" == [('a',2),('b',2)] <EOL> -- histogram \"a b c a b\" == [('a',2),('b',2)] <EOL> -- histogram \"b b b b a\" == [('b',4)] <EOL> -- histogram(\"\") == [] <EOL> import Data.List (group, sort) <EOL> histogram :: String -> [(Char, Int)] <EOL> histogram str = <EOL>   [ (c, n) <EOL>     | (n, c) <-", "gt": "freqs,", "prediction": " zip [1..] str"}
{"input": "<s> -- Given a string representing a space separated lowercase letters, return a dictionary <EOL> -- of the letter with the most repetition and containing the corresponding count. <EOL> -- If several letters have the same occurrence, return all of them. <EOL> -- <EOL> -- Example: <EOL> -- histogram \"a b c\" == [('a',1),('b',1),('c',1)] <EOL> -- histogram \"a b b a\" == [('a',2),('b',2)] <EOL> -- histogram \"a b c a b\" == [('a',2),('b',2)] <EOL> -- histogram \"b b b b a\" == [('b',4)] <EOL> -- histogram(\"\") == [] <EOL> import Data.List (group, sort) <EOL> histogram :: String -> [(Char, Int)] <EOL> histogram str = <EOL>   [ (c, n) <EOL>     | (n, c) <- freqs, <EOL>       n ==", "gt": "maxFreq", "prediction": " [] ]"}
{"input": "<s> -- Given a string representing a space separated lowercase letters, return a dictionary <EOL> -- of the letter with the most repetition and containing the corresponding count. <EOL> -- If several letters have the same occurrence, return all of them. <EOL> -- <EOL> -- Example: <EOL> -- histogram \"a b c\" == [('a',1),('b',1),('c',1)] <EOL> -- histogram \"a b b a\" == [('a',2),('b',2)] <EOL> -- histogram \"a b c a b\" == [('a',2),('b',2)] <EOL> -- histogram \"b b b b a\" == [('b',4)] <EOL> -- histogram(\"\") == [] <EOL> import Data.List (group, sort) <EOL> histogram :: String -> [(Char, Int)] <EOL> histogram str = <EOL>   [ (c, n) <EOL>     | (n, c) <- freqs, <EOL>       n == maxFreq <EOL>   ] <EOL>   where <EOL>     freqs = <EOL>       [ (length g, head g) <EOL>         | g <-", "gt": "group $ sort str,", "prediction": " freqs"}
{"input": "<s> -- Given a string representing a space separated lowercase letters, return a dictionary <EOL> -- of the letter with the most repetition and containing the corresponding count. <EOL> -- If several letters have the same occurrence, return all of them. <EOL> -- <EOL> -- Example: <EOL> -- histogram \"a b c\" == [('a',1),('b',1),('c',1)] <EOL> -- histogram \"a b b a\" == [('a',2),('b',2)] <EOL> -- histogram \"a b c a b\" == [('a',2),('b',2)] <EOL> -- histogram \"b b b b a\" == [('b',4)] <EOL> -- histogram(\"\") == [] <EOL> import Data.List (group, sort) <EOL> histogram :: String -> [(Char, Int)] <EOL> histogram str = <EOL>   [ (c, n) <EOL>     | (n, c) <- freqs, <EOL>       n == maxFreq <EOL>   ] <EOL>   where <EOL>     freqs = <EOL>       [ (length g, head g) <EOL>         | g <- group $ sort str, <EOL>           head g /= ' ' <EOL>       ] <EOL>     maxFreq = maximum $", "gt": "map fst freqs", "prediction": " map length freqs"}
{"input": "<s> -- Given a string representing a space separated lowercase letters, return a dictionary <EOL> -- of the letter with the most repetition and containing the corresponding count. <EOL> -- If several letters have the same occurrence, return all of them. <EOL> -- <EOL> -- Example: <EOL> -- histogram \"a b c\" == [('a',1),('b',1),('c',1)] <EOL> -- histogram \"a b b a\" == [('a',2),('b',2)] <EOL> -- histogram \"a b c a b\" == [('a',2),('b',2)] <EOL> -- histogram \"b b b b a\" == [('b',4)] <EOL> -- histogram(\"\") == [] <EOL> import Data.List (group, sort) <EOL> histogram :: String -> [(Char, Int)] <EOL> histogram str = <EOL>   [ (c, n) <EOL>     | (n, c) <- freqs, <EOL>       n == maxFreq <EOL>   ] <EOL>   where <EOL>     freqs = <EOL>       [ (length g, head g) <EOL>         | g <- group $ sort str, <EOL>           head g /= ' ' <EOL>       ] <EOL>     maxFreq =", "gt": "maximum $ map fst freqs", "prediction": " maximum"}
{"input": "<s> import Data.Char <EOL> import Data.List <EOL> -- Given a string, find out how many distinct characters (regardless of case) does it consist of <EOL> -- >>> count_distinct_characters \"xyzXYZ\" <EOL> -- 3 <EOL> -- >>> count_distinct_characters \"Jerry\" <EOL> -- 4 <EOL> count_distinct_characters :: String -> Int <EOL> count_distinct_characters string = length $", "gt": "nub $ map toLower string", "prediction": " filter (== ' ') string"}
{"input": "<s> import Data.Char <EOL> import Data.List <EOL> -- Given a string, find out how many distinct characters (regardless of case) does it consist of <EOL> -- >>> count_distinct_characters \"xyzXYZ\" <EOL> -- 3 <EOL> -- >>> count_distinct_characters \"Jerry\" <EOL> -- 4 <EOL> count_distinct_characters :: String -> Int <EOL> count_distinct_characters string = length $ nub $", "gt": "map toLower string", "prediction": " filter (== ' ') string"}
{"input": "<s> import Data.Char <EOL> import Data.List <EOL> -- Given a string, find out how many distinct characters (regardless of case) does it consist of <EOL> -- >>> count_distinct_characters \"xyzXYZ\" <EOL> -- 3 <EOL> -- >>> count_distinct_characters \"Jerry\" <EOL> -- 4 <EOL> count_distinct_characters :: String -> Int <EOL> count_distinct_characters string =", "gt": "length $ nub $ map toLower string", "prediction": " undefined"}
{"input": "<s> -- Given a string s, count the number of uppercase vowels in even indices. <EOL> -- <EOL> -- For example: <EOL> -- count_upper \"aBCdEf\" returns 1 <EOL> -- count_upper \"abcdefg\" returns 0 <EOL> -- count_upper \"dBBE\" returns 0 <EOL> count_upper :: String -> Int <EOL> count_upper s = <EOL>   length <EOL>     [ i <EOL>       | i <- [0, 2 ..", "gt": "(length s - 1)],", "prediction": " ]length s - 1)]"}
{"input": "<s> -- Given a string s, count the number of uppercase vowels in even indices. <EOL> -- <EOL> -- For example: <EOL> -- count_upper \"aBCdEf\" returns 1 <EOL> -- count_upper \"abcdefg\" returns 0 <EOL> -- count_upper \"dBBE\" returns 0 <EOL> count_upper :: String -> Int <EOL> count_upper s = <EOL>   length <EOL>     [ i <EOL>       | i <-", "gt": "[0, 2 .. (length s - 1)],", "prediction": " [0..(length s - 1)]"}
{"input": "<s> -- Given a string s, count the number of uppercase vowels in even indices. <EOL> -- <EOL> -- For example: <EOL> -- count_upper \"aBCdEf\" returns 1 <EOL> -- count_upper \"abcdefg\" returns 0 <EOL> -- count_upper \"dBBE\" returns 0 <EOL> count_upper :: String -> Int <EOL> count_upper s = <EOL>   length <EOL>     [ i <EOL>       | i <- [0, 2 .. (length s - 1)], <EOL>         s !! i `elem`", "gt": "\"AEIOU\"", "prediction": " [ 'a' .. 'z']"}
{"input": "<s> -- Given an array arr of integers and a positive integer k, return a sorted list  <EOL> -- of length k with the maximum k numbers in arr. <EOL> --  <EOL> -- Example 1: <EOL> --  <EOL> --     Input: arr = [-3, -4, 5], k = 3 <EOL> --     Output: [-4, -3, 5] <EOL> --  <EOL> -- Example 2: <EOL> --  <EOL> --     Input: arr = [4, -4, 4], k = 2 <EOL> --     Output: [4, 4] <EOL> --  <EOL> -- Example 3: <EOL> --  <EOL> --     Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 <EOL> --     Output: [2] <EOL> --  <EOL> -- Note: <EOL> --     1. The length of the array will be in the range of [1, 1000]. <EOL> --     2. The elements in the array will be in the range of [-1000, 1000]. <EOL> --     3. 0 <= k <= len(arr) <EOL> import Data.List (sort) <EOL> maximumK :: [Int] -> Int -> [Int] <EOL> maximumK arr k = reverse $ take k $", "gt": "reverse $ sort arr", "prediction": " reverse arr"}
{"input": "<s> -- Given an array arr of integers and a positive integer k, return a sorted list  <EOL> -- of length k with the maximum k numbers in arr. <EOL> --  <EOL> -- Example 1: <EOL> --  <EOL> --     Input: arr = [-3, -4, 5], k = 3 <EOL> --     Output: [-4, -3, 5] <EOL> --  <EOL> -- Example 2: <EOL> --  <EOL> --     Input: arr = [4, -4, 4], k = 2 <EOL> --     Output: [4, 4] <EOL> --  <EOL> -- Example 3: <EOL> --  <EOL> --     Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 <EOL> --     Output: [2] <EOL> --  <EOL> -- Note: <EOL> --     1. The length of the array will be in the range of [1, 1000]. <EOL> --     2. The elements in the array will be in the range of [-1000, 1000]. <EOL> --     3. 0 <= k <= len(arr) <EOL> import Data.List (sort) <EOL> maximumK :: [Int] -> Int -> [Int] <EOL> maximumK arr k = reverse $ take k $ reverse $", "gt": "sort arr", "prediction": " sort arr"}
{"input": "<s> -- Given an array arr of integers and a positive integer k, return a sorted list  <EOL> -- of length k with the maximum k numbers in arr. <EOL> --  <EOL> -- Example 1: <EOL> --  <EOL> --     Input: arr = [-3, -4, 5], k = 3 <EOL> --     Output: [-4, -3, 5] <EOL> --  <EOL> -- Example 2: <EOL> --  <EOL> --     Input: arr = [4, -4, 4], k = 2 <EOL> --     Output: [4, 4] <EOL> --  <EOL> -- Example 3: <EOL> --  <EOL> --     Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 <EOL> --     Output: [2] <EOL> --  <EOL> -- Note: <EOL> --     1. The length of the array will be in the range of [1, 1000]. <EOL> --     2. The elements in the array will be in the range of [-1000, 1000]. <EOL> --     3. 0 <= k <= len(arr) <EOL> import Data.List (sort) <EOL> maximumK :: [Int] -> Int -> [Int] <EOL> maximumK arr k = reverse $", "gt": "take k $ reverse $ sort arr", "prediction": " sort $ take k arr"}
{"input": "<s> -- Given an array arr of integers and a positive integer k, return a sorted list  <EOL> -- of length k with the maximum k numbers in arr. <EOL> --  <EOL> -- Example 1: <EOL> --  <EOL> --     Input: arr = [-3, -4, 5], k = 3 <EOL> --     Output: [-4, -3, 5] <EOL> --  <EOL> -- Example 2: <EOL> --  <EOL> --     Input: arr = [4, -4, 4], k = 2 <EOL> --     Output: [4, 4] <EOL> --  <EOL> -- Example 3: <EOL> --  <EOL> --     Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 <EOL> --     Output: [2] <EOL> --  <EOL> -- Note: <EOL> --     1. The length of the array will be in the range of [1, 1000]. <EOL> --     2. The elements in the array will be in the range of [-1000, 1000]. <EOL> --     3. 0 <= k <= len(arr) <EOL> import Data.List (sort) <EOL> maximumK :: [Int] -> Int -> [Int] <EOL> maximumK arr k =", "gt": "reverse $ take k $ reverse $ sort arr", "prediction": " sort"}
{"input": "<s> -- remove_vowels is a function that takes string and returns string without vowels. <EOL> -- >>> remove_vowels \"\" <EOL> -- \"\" <EOL> -- >>> remove_vowels \"abcdef\\nghijklm\" <EOL> -- \"bcdf\\nghjklm\" <EOL> -- >>> remove_vowels \"abcdef\" <EOL> -- \"bcdf\" <EOL> -- >>> remove_vowels \"aaaaa\" <EOL> -- \"\" <EOL> -- >>> remove_vowels \"aaBAA\" <EOL> -- \"B\" <EOL> -- >>> remove_vowels \"zbcd\" <EOL> -- \"zbcd\" <EOL> remove_vowels :: String -> String <EOL> remove_vowels =", "gt": "filter (`notElem` \"aeiouAEIOU\")", "prediction": " reverse isVowels"}
{"input": "<s> -- Given length of a side and high return area for a triangle. <EOL> -- >>> triangle_area 5 3 <EOL> -- 7.5 <EOL> triangle_area :: Double -> Double -> Double <EOL> triangle_area a h =", "gt": "a * h / 2.0", "prediction": " a"}
{"input": "<s> -- Given length of a side and high return area for a triangle. <EOL> -- >>> triangle_area 5 3 <EOL> -- 7.5 <EOL> triangle_area :: Double -> Double -> Double <EOL> triangle_area a h = a * h /", "gt": "2.0", "prediction": " 2"}
{"input": "<s> -- Add two numbers x and y <EOL> -- >>> add 2 3 <EOL> -- 5 <EOL> -- >>> add 5 7 <EOL> -- 12 <EOL> add :: Int -> Int -> Int <EOL> add =", "gt": "(+)", "prediction": " ("}
{"input": "<s> -- Your task is to implement a function that will simplify the expression <EOL> -- x * n. The function returns True if x * n evaluates to a whole number and False <EOL> -- otherwise. Both x and n, are string representation of a fraction, and have the following format, <EOL> -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers. <EOL> -- <EOL> -- You can assume that x, and n are valid fractions, and do not have zero as denominator. <EOL> -- <EOL> -- >>> simplify \"1/5\" \"5/1\" <EOL> -- True <EOL> -- >>> simplify \"1/6\" \"2/1\" <EOL> -- False <EOL> -- >>> simplify \"7/10\" \"10/2\" <EOL> -- False <EOL> import Data.List <EOL> import Data.Maybe <EOL> simplify :: String -> String -> Bool <EOL> simplify x n = numerator / denominator ==", "gt": "fromIntegral (round (numerator / denominator))", "prediction": " 0"}
{"input": "<s> -- Your task is to implement a function that will simplify the expression <EOL> -- x * n. The function returns True if x * n evaluates to a whole number and False <EOL> -- otherwise. Both x and n, are string representation of a fraction, and have the following format, <EOL> -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers. <EOL> -- <EOL> -- You can assume that x, and n are valid fractions, and do not have zero as denominator. <EOL> -- <EOL> -- >>> simplify \"1/5\" \"5/1\" <EOL> -- True <EOL> -- >>> simplify \"1/6\" \"2/1\" <EOL> -- False <EOL> -- >>> simplify \"7/10\" \"10/2\" <EOL> -- False <EOL> import Data.List <EOL> import Data.Maybe <EOL> simplify :: String -> String -> Bool <EOL> simplify x n = numerator / denominator == fromIntegral (round (numerator / denominator)) <EOL>   where <EOL>     a, b, c, d :: Double <EOL>     a = read (take (fromJust (elemIndex '/' x)) x) <EOL>     b = read (drop (fromJust (elemIndex '/' x) + 1) x) <EOL>     c = read (take (fromJust (elemIndex '/' n)) n) <EOL>     d = read (drop (fromJust (elemIndex '/' n) + 1) n) <EOL>     numerator, denominator :: Double <EOL>     numerator =", "gt": "a * c", "prediction": " read (take (fromJust (elemIndex '/' n)) x)"}
{"input": "<s> -- Your task is to implement a function that will simplify the expression <EOL> -- x * n. The function returns True if x * n evaluates to a whole number and False <EOL> -- otherwise. Both x and n, are string representation of a fraction, and have the following format, <EOL> -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers. <EOL> -- <EOL> -- You can assume that x, and n are valid fractions, and do not have zero as denominator. <EOL> -- <EOL> -- >>> simplify \"1/5\" \"5/1\" <EOL> -- True <EOL> -- >>> simplify \"1/6\" \"2/1\" <EOL> -- False <EOL> -- >>> simplify \"7/10\" \"10/2\" <EOL> -- False <EOL> import Data.List <EOL> import Data.Maybe <EOL> simplify :: String -> String -> Bool <EOL> simplify x n =", "gt": "numerator / denominator == fromIntegral (round (numerator / denominator))", "prediction": " not"}
{"input": "<s> -- Your task is to implement a function that will simplify the expression <EOL> -- x * n. The function returns True if x * n evaluates to a whole number and False <EOL> -- otherwise. Both x and n, are string representation of a fraction, and have the following format, <EOL> -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers. <EOL> -- <EOL> -- You can assume that x, and n are valid fractions, and do not have zero as denominator. <EOL> -- <EOL> -- >>> simplify \"1/5\" \"5/1\" <EOL> -- True <EOL> -- >>> simplify \"1/6\" \"2/1\" <EOL> -- False <EOL> -- >>> simplify \"7/10\" \"10/2\" <EOL> -- False <EOL> import Data.List <EOL> import Data.Maybe <EOL> simplify :: String -> String -> Bool <EOL> simplify x n = numerator / denominator == fromIntegral (round (numerator / denominator)) <EOL>   where <EOL>     a, b, c, d :: Double <EOL>     a = read (take (fromJust (elemIndex '/' x)) x) <EOL>     b = read (drop (fromJust (elemIndex '/' x) + 1) x) <EOL>     c = read (take (fromJust (elemIndex '/' n)) n) <EOL>     d =", "gt": "read (drop (fromJust (elemIndex '/' n) + 1) n)", "prediction": " read (drop (fromJust (elemIndex '/' n) + 1)) n"}
{"input": "<s> -- Your task is to implement a function that will simplify the expression <EOL> -- x * n. The function returns True if x * n evaluates to a whole number and False <EOL> -- otherwise. Both x and n, are string representation of a fraction, and have the following format, <EOL> -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers. <EOL> -- <EOL> -- You can assume that x, and n are valid fractions, and do not have zero as denominator. <EOL> -- <EOL> -- >>> simplify \"1/5\" \"5/1\" <EOL> -- True <EOL> -- >>> simplify \"1/6\" \"2/1\" <EOL> -- False <EOL> -- >>> simplify \"7/10\" \"10/2\" <EOL> -- False <EOL> import Data.List <EOL> import Data.Maybe <EOL> simplify :: String -> String -> Bool <EOL> simplify x n = numerator / denominator == fromIntegral (round (numerator / denominator)) <EOL>   where <EOL>     a, b, c, d :: Double <EOL>     a = read (take (fromJust (elemIndex '/' x)) x) <EOL>     b = read (drop (fromJust (elemIndex '/' x) + 1) x) <EOL>     c = read (take (fromJust (elemIndex '/' n)) n) <EOL>     d = read (drop (fromJust (elemIndex '/' n) + 1) n) <EOL>     numerator, denominator :: Double <EOL>     numerator = a * c <EOL>     denominator =", "gt": "b * d", "prediction": " b * d"}
{"input": "<s> -- You are given a list of integers. <EOL> -- You need to find the largest prime value and return the sum of its digits. <EOL> -- <EOL> -- Examples: <EOL> -- For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10 <EOL> -- For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25 <EOL> -- For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13 <EOL> -- For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11 <EOL> -- For lst = [0,81,12,3,1,21] the output should be 3 <EOL> -- For lst = [0,8,1,2,1,7] the output should be 7 <EOL> skjkasdkd :: [Int] -> Int <EOL> skjkasdkd lst = <EOL>   let isPrime n = <EOL>         null <EOL>           [ i <EOL>             | i <- [2 .. (floor (sqrt", "gt": "(fromIntegral n)))],", "prediction": " $ fromIntegral n)]"}
{"input": "<s> -- You are given a list of integers. <EOL> -- You need to find the largest prime value and return the sum of its digits. <EOL> -- <EOL> -- Examples: <EOL> -- For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10 <EOL> -- For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25 <EOL> -- For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13 <EOL> -- For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11 <EOL> -- For lst = [0,81,12,3,1,21] the output should be 3 <EOL> -- For lst = [0,8,1,2,1,7] the output should be 7 <EOL> skjkasdkd :: [Int] -> Int <EOL> skjkasdkd lst = <EOL>   let isPrime n = <EOL>         null <EOL>           [ i <EOL>             | i <- [2 .. (floor (sqrt (fromIntegral n)))], <EOL>               n `mod` i == 0 <EOL>           ] <EOL>       maxx = <EOL>         maximum <EOL>           [ i | i <-", "gt": "lst, isPrime i", "prediction": " [2 .. (floor (sqrt (fromIntegral n)))]"}
{"input": "<s> -- You are given a list of integers. <EOL> -- You need to find the largest prime value and return the sum of its digits. <EOL> -- <EOL> -- Examples: <EOL> -- For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10 <EOL> -- For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25 <EOL> -- For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13 <EOL> -- For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11 <EOL> -- For lst = [0,81,12,3,1,21] the output should be 3 <EOL> -- For lst = [0,8,1,2,1,7] the output should be 7 <EOL> skjkasdkd :: [Int] -> Int <EOL> skjkasdkd lst = <EOL>   let isPrime n = <EOL>         null <EOL>           [ i <EOL>             | i <- [2 .. (floor (sqrt (fromIntegral n)))], <EOL>               n `mod`", "gt": "i == 0", "prediction": " 10 == 0,"}
{"input": "<s> -- You are given a list of integers. <EOL> -- You need to find the largest prime value and return the sum of its digits. <EOL> -- <EOL> -- Examples: <EOL> -- For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10 <EOL> -- For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25 <EOL> -- For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13 <EOL> -- For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11 <EOL> -- For lst = [0,81,12,3,1,21] the output should be 3 <EOL> -- For lst = [0,8,1,2,1,7] the output should be 7 <EOL> skjkasdkd :: [Int] -> Int <EOL> skjkasdkd lst = <EOL>   let isPrime n = <EOL>         null <EOL>           [ i <EOL>             | i <-", "gt": "[2 .. (floor (sqrt (fromIntegral n)))],", "prediction": " lst"}
{"input": "<s> -- You are given a list of integers. <EOL> -- You need to find the largest prime value and return the sum of its digits. <EOL> -- <EOL> -- Examples: <EOL> -- For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10 <EOL> -- For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25 <EOL> -- For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13 <EOL> -- For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11 <EOL> -- For lst = [0,81,12,3,1,21] the output should be 3 <EOL> -- For lst = [0,8,1,2,1,7] the output should be 7 <EOL> skjkasdkd :: [Int] -> Int <EOL> skjkasdkd lst = <EOL>   let isPrime n = <EOL>         null <EOL>           [ i <EOL>             | i <- [2 .. (floor (sqrt (fromIntegral n)))], <EOL>               n `mod` i == 0 <EOL>           ] <EOL>       maxx = <EOL>         maximum <EOL>           [ i | i <- lst, isPrime i <EOL>           ] <EOL>    in sum [read [i] | i <-", "gt": "show maxx]", "prediction": " lst]"}
{"input": "<s> -- You are given a string s. <EOL> -- Your task is to check if the string is happy or not. <EOL> -- A string is happy if its length is at least 3 and every 3 consecutive letters are distinct <EOL> -- For example: <EOL> -- is_happy \"a\" => False <EOL> -- is_happy \"aa\" => False <EOL> -- is_happy \"abcd\" => True <EOL> -- is_happy \"aabb\" => False <EOL> -- is_happy \"adb\" => True <EOL> -- is_happy \"xyy\" => False <EOL> is_happy :: String -> Bool <EOL> is_happy s = length s >= 3 && and", "gt": "[s !! i /= s !! (i+1) && s !! (i+1) /= s !! (i+2) && s !! i /= s !! (i+2) | i <- [0..(length s - 3)]]", "prediction": " ("}
{"input": "<s> -- You are given a string s. <EOL> -- Your task is to check if the string is happy or not. <EOL> -- A string is happy if its length is at least 3 and every 3 consecutive letters are distinct <EOL> -- For example: <EOL> -- is_happy \"a\" => False <EOL> -- is_happy \"aa\" => False <EOL> -- is_happy \"abcd\" => True <EOL> -- is_happy \"aabb\" => False <EOL> -- is_happy \"adb\" => True <EOL> -- is_happy \"xyy\" => False <EOL> is_happy :: String -> Bool <EOL> is_happy s = length s >= 3 && and [s !! i /= s !! (i+1) && s !! (i+1) /= s !! (i+2) && s !! i /= s !! (i+2) | i <-", "gt": "[0..(length s - 3)]]", "prediction": " [1..]]"}
{"input": "<s> -- You are given a string s. <EOL> -- Your task is to check if the string is happy or not. <EOL> -- A string is happy if its length is at least 3 and every 3 consecutive letters are distinct <EOL> -- For example: <EOL> -- is_happy \"a\" => False <EOL> -- is_happy \"aa\" => False <EOL> -- is_happy \"abcd\" => True <EOL> -- is_happy \"aabb\" => False <EOL> -- is_happy \"adb\" => True <EOL> -- is_happy \"xyy\" => False <EOL> is_happy :: String -> Bool <EOL> is_happy s =", "gt": "length s >= 3 && and [s !! i /= s !! (i+1) && s !! (i+1) /= s !! (i+2) && s !! i /= s !! (i+2) | i <- [0..(length s - 3)]]", "prediction": " all"}
{"input": "<s> import Data.List (nub, sort) <EOL> -- Check if two words have the same characters. <EOL> -- >>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\" <EOL> -- True <EOL> -- >>> same_chars \"abcd\" \"dddddddabc\" <EOL> -- True <EOL> -- >>> same_chars \"dddddddabc\" \"abcd\" <EOL> -- True <EOL> -- >>> same_chars \"eabcd\" \"dddddddabc\" <EOL> -- False <EOL> -- >>> same_chars \"abcd\" \"dddddddabce\" <EOL> -- False <EOL> -- >>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddddabc\" <EOL> -- False <EOL> same_chars :: String -> String -> Bool <EOL> same_chars s0 s1 =", "gt": "sort (nub s0) == sort (nub s1)", "prediction": " s"}
{"input": "<s> import Data.List (nub, sort) <EOL> -- Check if two words have the same characters. <EOL> -- >>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\" <EOL> -- True <EOL> -- >>> same_chars \"abcd\" \"dddddddabc\" <EOL> -- True <EOL> -- >>> same_chars \"dddddddabc\" \"abcd\" <EOL> -- True <EOL> -- >>> same_chars \"eabcd\" \"dddddddabc\" <EOL> -- False <EOL> -- >>> same_chars \"abcd\" \"dddddddabce\" <EOL> -- False <EOL> -- >>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddddabc\" <EOL> -- False <EOL> same_chars :: String -> String -> Bool <EOL> same_chars s0 s1 = sort (nub s0) ==", "gt": "sort (nub s1)", "prediction": " sort (nub s1)"}
{"input": "<s> import Data.List <EOL> -- You are given a list of integers. <EOL> -- Write a function next_smallest() that returns the 2nd smallest element of the list. <EOL> -- Return None if there is no such element. <EOL> -- <EOL> -- next_smallest [1, 2, 3, 4, 5] == 2 <EOL> -- next_smallest [5, 1, 4, 3, 2] == 2 <EOL> -- next_smallest [] == None <EOL> -- next_smallest [1, 1] == None <EOL> next_smallest :: [Int] -> Maybe Int <EOL> next_smallest lst = <EOL>   if length (sort (nub lst)) < 2 <EOL>     then", "gt": "Nothing", "prediction": " Nothing"}
{"input": "<s> import Data.List <EOL> -- You are given a list of integers. <EOL> -- Write a function next_smallest() that returns the 2nd smallest element of the list. <EOL> -- Return None if there is no such element. <EOL> -- <EOL> -- next_smallest [1, 2, 3, 4, 5] == 2 <EOL> -- next_smallest [5, 1, 4, 3, 2] == 2 <EOL> -- next_smallest [] == None <EOL> -- next_smallest [1, 1] == None <EOL> next_smallest :: [Int] -> Maybe Int <EOL> next_smallest lst = <EOL>   if length (sort (nub lst)) < 2 <EOL>     then Nothing <EOL>     else", "gt": "Just (sort (nub lst) !! 1)", "prediction": " Just"}
{"input": "<s> import Data.List <EOL> -- You are given a list of integers. <EOL> -- Write a function next_smallest() that returns the 2nd smallest element of the list. <EOL> -- Return None if there is no such element. <EOL> -- <EOL> -- next_smallest [1, 2, 3, 4, 5] == 2 <EOL> -- next_smallest [5, 1, 4, 3, 2] == 2 <EOL> -- next_smallest [] == None <EOL> -- next_smallest [1, 1] == None <EOL> next_smallest :: [Int] -> Maybe Int <EOL> next_smallest lst = <EOL>   if length (sort (nub lst)) <", "gt": "2", "prediction": " 2"}
{"input": "<s> import Data.List <EOL> -- You are given a list of integers. <EOL> -- Write a function next_smallest() that returns the 2nd smallest element of the list. <EOL> -- Return None if there is no such element. <EOL> -- <EOL> -- next_smallest [1, 2, 3, 4, 5] == 2 <EOL> -- next_smallest [5, 1, 4, 3, 2] == 2 <EOL> -- next_smallest [] == None <EOL> -- next_smallest [1, 1] == None <EOL> next_smallest :: [Int] -> Maybe Int <EOL> next_smallest lst = <EOL>   if length", "gt": "(sort (nub lst)) < 2", "prediction": " lst <= 2"}
{"input": "<s> import Data.List (sort) <EOL> -- This function takes a list l and returns a list l' such that <EOL> -- l' is identical to l in the odd indicies, while its values at the even indicies are equal <EOL> -- to the values of the even indicies of l, but sorted. <EOL> -- >>> sort_even [1,2,3] <EOL> -- [1,2,3] <EOL> -- >>> sort_even [5,6,3,4] <EOL> -- [3,6,5,4] <EOL> sort_even :: [Int] -> [Int] <EOL> sort_even xs = replaceEverySecond xs (sort $ everySecond xs) <EOL>   where <EOL>     everySecond :: [Int] -> [Int] <EOL>     everySecond [] = [] <EOL>     everySecond (x:xs) = x : everySecond (drop 1 xs) <EOL>     replaceEverySecond :: [Int] -> [Int] -> [Int] <EOL>     replaceEverySecond [] _ = [] <EOL>     replaceEverySecond xs [] =", "gt": "xs", "prediction": " xs"}
{"input": "<s> import Data.List (sort) <EOL> -- This function takes a list l and returns a list l' such that <EOL> -- l' is identical to l in the odd indicies, while its values at the even indicies are equal <EOL> -- to the values of the even indicies of l, but sorted. <EOL> -- >>> sort_even [1,2,3] <EOL> -- [1,2,3] <EOL> -- >>> sort_even [5,6,3,4] <EOL> -- [3,6,5,4] <EOL> sort_even :: [Int] -> [Int] <EOL> sort_even xs = replaceEverySecond xs (sort $ everySecond xs) <EOL>   where <EOL>     everySecond :: [Int] -> [Int] <EOL>     everySecond [] = [] <EOL>     everySecond (x:xs) = x : everySecond (drop 1 xs) <EOL>     replaceEverySecond :: [Int] -> [Int] -> [Int] <EOL>     replaceEverySecond [] _ =", "gt": "[]", "prediction": " []"}
{"input": "<s> import Data.List (sort) <EOL> -- This function takes a list l and returns a list l' such that <EOL> -- l' is identical to l in the odd indicies, while its values at the even indicies are equal <EOL> -- to the values of the even indicies of l, but sorted. <EOL> -- >>> sort_even [1,2,3] <EOL> -- [1,2,3] <EOL> -- >>> sort_even [5,6,3,4] <EOL> -- [3,6,5,4] <EOL> sort_even :: [Int] -> [Int] <EOL> sort_even xs = replaceEverySecond xs (sort $ everySecond xs) <EOL>   where <EOL>     everySecond :: [Int] -> [Int] <EOL>     everySecond [] = [] <EOL>     everySecond (x:xs) =", "gt": "x : everySecond (drop 1 xs)", "prediction": " (x,xs) : (everySecond xs)"}
{"input": "<s> import Data.List (sort) <EOL> -- This function takes a list l and returns a list l' such that <EOL> -- l' is identical to l in the odd indicies, while its values at the even indicies are equal <EOL> -- to the values of the even indicies of l, but sorted. <EOL> -- >>> sort_even [1,2,3] <EOL> -- [1,2,3] <EOL> -- >>> sort_even [5,6,3,4] <EOL> -- [3,6,5,4] <EOL> sort_even :: [Int] -> [Int] <EOL> sort_even xs = replaceEverySecond xs (sort $ everySecond xs) <EOL>   where <EOL>     everySecond :: [Int] -> [Int] <EOL>     everySecond [] = [] <EOL>     everySecond (x:xs) = x : everySecond (drop 1 xs) <EOL>     replaceEverySecond :: [Int] -> [Int] -> [Int] <EOL>     replaceEverySecond [] _ = [] <EOL>     replaceEverySecond xs [] = xs <EOL>     replaceEverySecond (x:xs) (y:ys) = y : (take 1 xs ++", "gt": "replaceEverySecond (drop 1 xs) ys)", "prediction": " replaceEverySecond ys)"}
{"input": "<s> import Data.List (sort) <EOL> -- This function takes a list l and returns a list l' such that <EOL> -- l' is identical to l in the odd indicies, while its values at the even indicies are equal <EOL> -- to the values of the even indicies of l, but sorted. <EOL> -- >>> sort_even [1,2,3] <EOL> -- [1,2,3] <EOL> -- >>> sort_even [5,6,3,4] <EOL> -- [3,6,5,4] <EOL> sort_even :: [Int] -> [Int] <EOL> sort_even xs = replaceEverySecond xs (sort $ everySecond xs) <EOL>   where <EOL>     everySecond :: [Int] -> [Int] <EOL>     everySecond [] =", "gt": "[]", "prediction": " []"}
{"input": "<s> -- Given an array of integers, sort the integers that are between 1 and 9 inclusive, <EOL> -- reverse the resulting array, and then replace each digit by its corresponding name from <EOL> -- \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\". <EOL> --  <EOL> -- For example: <EOL> --   arr = [2, 1, 1, 4, 5, 8, 2, 3]    <EOL> --         -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8]  <EOL> --         -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1] <EOL> --   return [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"] <EOL> --      <EOL> --   If the array is empty, return an empty array: <EOL> --   arr = [] <EOL> --   return [] <EOL> --      <EOL> --   If the array has any strange number ignore it: <EOL> --   arr = [1, -1 , 55]  <EOL> --         -> sort arr -> [-1, 1, 55] <EOL> --         -> reverse arr -> [55, 1, -1] <EOL> --   return = ['One'] <EOL> import Data.List (sort) <EOL> by_length :: [Int] -> [String] <EOL> by_length xs = map toWord $ filter isDigit $ reverse $ sort xs <EOL>   where <EOL>     isDigit x = x >= 1 && x <= 9 <EOL>     toWord x = case x of <EOL>       1 -> \"One\" <EOL>       2 -> \"Two\" <EOL>       3 -> \"Three\" <EOL>       4 -> \"Four\" <EOL>       5 -> \"Five\" <EOL>       6 ->", "gt": "\"Six\"", "prediction": " \"Four\""}
{"input": "<s> -- Given an array of integers, sort the integers that are between 1 and 9 inclusive, <EOL> -- reverse the resulting array, and then replace each digit by its corresponding name from <EOL> -- \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\". <EOL> --  <EOL> -- For example: <EOL> --   arr = [2, 1, 1, 4, 5, 8, 2, 3]    <EOL> --         -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8]  <EOL> --         -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1] <EOL> --   return [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"] <EOL> --      <EOL> --   If the array is empty, return an empty array: <EOL> --   arr = [] <EOL> --   return [] <EOL> --      <EOL> --   If the array has any strange number ignore it: <EOL> --   arr = [1, -1 , 55]  <EOL> --         -> sort arr -> [-1, 1, 55] <EOL> --         -> reverse arr -> [55, 1, -1] <EOL> --   return = ['One'] <EOL> import Data.List (sort) <EOL> by_length :: [Int] -> [String] <EOL> by_length xs = map toWord $ filter isDigit $ reverse $ sort xs <EOL>   where <EOL>     isDigit x = x >= 1 && x <= 9 <EOL>     toWord x = case x of <EOL>       1 -> \"One\" <EOL>       2 -> \"Two\" <EOL>       3 -> \"Three\" <EOL>       4 -> \"Four\" <EOL>       5 -> \"Five\" <EOL>       6 -> \"Six\" <EOL>       7 -> \"Seven\" <EOL>       8 -> \"Eight\" <EOL>       9 ->", "gt": "\"Nine\"", "prediction": " \"Nine\""}
{"input": "<s> -- Given an array of integers, sort the integers that are between 1 and 9 inclusive, <EOL> -- reverse the resulting array, and then replace each digit by its corresponding name from <EOL> -- \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\". <EOL> --  <EOL> -- For example: <EOL> --   arr = [2, 1, 1, 4, 5, 8, 2, 3]    <EOL> --         -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8]  <EOL> --         -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1] <EOL> --   return [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"] <EOL> --      <EOL> --   If the array is empty, return an empty array: <EOL> --   arr = [] <EOL> --   return [] <EOL> --      <EOL> --   If the array has any strange number ignore it: <EOL> --   arr = [1, -1 , 55]  <EOL> --         -> sort arr -> [-1, 1, 55] <EOL> --         -> reverse arr -> [55, 1, -1] <EOL> --   return = ['One'] <EOL> import Data.List (sort) <EOL> by_length :: [Int] -> [String] <EOL> by_length xs = map toWord $ filter isDigit $ reverse $ sort xs <EOL>   where <EOL>     isDigit x = x >= 1 &&", "gt": "x <= 9", "prediction": " x <= 9"}
{"input": "<s> -- Given an array of integers, sort the integers that are between 1 and 9 inclusive, <EOL> -- reverse the resulting array, and then replace each digit by its corresponding name from <EOL> -- \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\". <EOL> --  <EOL> -- For example: <EOL> --   arr = [2, 1, 1, 4, 5, 8, 2, 3]    <EOL> --         -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8]  <EOL> --         -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1] <EOL> --   return [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"] <EOL> --      <EOL> --   If the array is empty, return an empty array: <EOL> --   arr = [] <EOL> --   return [] <EOL> --      <EOL> --   If the array has any strange number ignore it: <EOL> --   arr = [1, -1 , 55]  <EOL> --         -> sort arr -> [-1, 1, 55] <EOL> --         -> reverse arr -> [55, 1, -1] <EOL> --   return = ['One'] <EOL> import Data.List (sort) <EOL> by_length :: [Int] -> [String] <EOL> by_length xs = map toWord $ filter isDigit $ reverse $ sort xs <EOL>   where <EOL>     isDigit x = x >= 1 && x <= 9 <EOL>     toWord x = case x of <EOL>       1 -> \"One\" <EOL>       2 -> \"Two\" <EOL>       3 ->", "gt": "\"Three\"", "prediction": " \"Three\""}
{"input": "<s> -- Given an array of integers, sort the integers that are between 1 and 9 inclusive, <EOL> -- reverse the resulting array, and then replace each digit by its corresponding name from <EOL> -- \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\". <EOL> --  <EOL> -- For example: <EOL> --   arr = [2, 1, 1, 4, 5, 8, 2, 3]    <EOL> --         -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8]  <EOL> --         -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1] <EOL> --   return [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"] <EOL> --      <EOL> --   If the array is empty, return an empty array: <EOL> --   arr = [] <EOL> --   return [] <EOL> --      <EOL> --   If the array has any strange number ignore it: <EOL> --   arr = [1, -1 , 55]  <EOL> --         -> sort arr -> [-1, 1, 55] <EOL> --         -> reverse arr -> [55, 1, -1] <EOL> --   return = ['One'] <EOL> import Data.List (sort) <EOL> by_length :: [Int] -> [String] <EOL> by_length xs = map toWord $ filter isDigit $ reverse $", "gt": "sort xs", "prediction": " xs xs"}
{"input": "<s> -- Create a function that takes a value (string) representing a number <EOL> -- and returns the closest integer to it. If the number is equidistant <EOL> -- from two integers, round it away from zero. <EOL> --  <EOL> -- Examples <EOL> -- >>> closest_integer \"10\" <EOL> -- 10 <EOL> -- >>> closest_integer \"15.3\" <EOL> -- 15 <EOL> --  <EOL> -- Note: <EOL> -- Rounding away from zero means that if the given number is equidistant <EOL> -- from two integers, the one you should return is the one that is the <EOL> -- farthest from zero. For example closest_integer(\"14.5\") should <EOL> -- return 15 and closest_integer(\"-14.5\") should return -15. <EOL> closest_integer :: String -> Integer <EOL> closest_integer s = let n = read s :: Double <EOL>     in round", "gt": "n", "prediction": " ("}
{"input": "<s> -- Create a function that takes a value (string) representing a number <EOL> -- and returns the closest integer to it. If the number is equidistant <EOL> -- from two integers, round it away from zero. <EOL> --  <EOL> -- Examples <EOL> -- >>> closest_integer \"10\" <EOL> -- 10 <EOL> -- >>> closest_integer \"15.3\" <EOL> -- 15 <EOL> --  <EOL> -- Note: <EOL> -- Rounding away from zero means that if the given number is equidistant <EOL> -- from two integers, the one you should return is the one that is the <EOL> -- farthest from zero. For example closest_integer(\"14.5\") should <EOL> -- return 15 and closest_integer(\"-14.5\") should return -15. <EOL> closest_integer :: String -> Integer <EOL> closest_integer s = let n =", "gt": "read s :: Double", "prediction": " read s :: Integer"}
{"input": "<s> -- Create a function that takes a value (string) representing a number <EOL> -- and returns the closest integer to it. If the number is equidistant <EOL> -- from two integers, round it away from zero. <EOL> --  <EOL> -- Examples <EOL> -- >>> closest_integer \"10\" <EOL> -- 10 <EOL> -- >>> closest_integer \"15.3\" <EOL> -- 15 <EOL> --  <EOL> -- Note: <EOL> -- Rounding away from zero means that if the given number is equidistant <EOL> -- from two integers, the one you should return is the one that is the <EOL> -- farthest from zero. For example closest_integer(\"14.5\") should <EOL> -- return 15 and closest_integer(\"-14.5\") should return -15. <EOL> closest_integer :: String -> Integer <EOL> closest_integer s = let n = read s", "gt": ":: Double", "prediction": " :: Integer"}
{"input": "<s> -- Return a greatest common divisor of two integers a and b <EOL> -- >>> greatest_common_divisor 3 5 <EOL> -- 1 <EOL> -- >>> greatest_common_divisor 25 15 <EOL> -- 5 <EOL> greatest_common_divisor :: Int -> Int -> Int <EOL> greatest_common_divisor a b =", "gt": "gcd a b", "prediction": " if"}
{"input": "<s> -- Return a greatest common divisor of two integers a and b <EOL> -- >>> greatest_common_divisor 3 5 <EOL> -- 1 <EOL> -- >>> greatest_common_divisor 25 15 <EOL> -- 5 <EOL> greatest_common_divisor :: Int -> Int -> Int <EOL> greatest_common_divisor a b = gcd", "gt": "a b", "prediction": " a b"}
{"input": "<s> -- Given a positive integer n, return the product of the odd digits. <EOL> -- Return 0 if all digits are even. <EOL> -- For example: <EOL> -- digits 1  == 1 <EOL> -- digits 4  == 0 <EOL> -- digits 235 == 15 <EOL> digits :: Int -> Int <EOL> digits n = if odd_count == 0 then 0 else product <EOL>   where <EOL>     f :: Char -> (Int, Int) -> (Int, Int) <EOL>     (product, odd_count) =", "gt": "foldr f (1, 0) (show n)", "prediction": " if"}
{"input": "<s> -- Given a positive integer n, return the product of the odd digits. <EOL> -- Return 0 if all digits are even. <EOL> -- For example: <EOL> -- digits 1  == 1 <EOL> -- digits 4  == 0 <EOL> -- digits 235 == 15 <EOL> digits :: Int -> Int <EOL> digits n = if odd_count == 0 then", "gt": "0 else product", "prediction": " n else n `div` 2"}
{"input": "<s> -- Given a positive integer n, return the product of the odd digits. <EOL> -- Return 0 if all digits are even. <EOL> -- For example: <EOL> -- digits 1  == 1 <EOL> -- digits 4  == 0 <EOL> -- digits 235 == 15 <EOL> digits :: Int -> Int <EOL> digits n =", "gt": "if odd_count == 0 then 0 else product", "prediction": " product [1..n]"}
{"input": "<s> -- Given a positive integer n, return the product of the odd digits. <EOL> -- Return 0 if all digits are even. <EOL> -- For example: <EOL> -- digits 1  == 1 <EOL> -- digits 4  == 0 <EOL> -- digits 235 == 15 <EOL> digits :: Int -> Int <EOL> digits n = if odd_count == 0 then 0 else product <EOL>   where <EOL>     f :: Char -> (Int, Int) -> (Int, Int) <EOL>     (product, odd_count) = foldr f (1, 0) (show n) <EOL>     f digit (acc, count) <EOL>       | even int_digit = (acc, count) <EOL>       | otherwise = (acc * int_digit, count + 1) <EOL>       where <EOL>         int_digit :: Int <EOL>         int_digit =", "gt": "read [digit] :: Int", "prediction": " if"}
{"input": "<s> -- Given a positive integer n, return the product of the odd digits. <EOL> -- Return 0 if all digits are even. <EOL> -- For example: <EOL> -- digits 1  == 1 <EOL> -- digits 4  == 0 <EOL> -- digits 235 == 15 <EOL> digits :: Int -> Int <EOL> digits n = if odd_count == 0 then 0 else product <EOL>   where <EOL>     f :: Char -> (Int, Int) -> (Int, Int) <EOL>     (product, odd_count) = foldr f (1, 0) (show n) <EOL>     f digit (acc, count) <EOL>       | even int_digit = (acc, count) <EOL>       | otherwise =", "gt": "(acc * int_digit, count + 1)", "prediction": " (acc, count + digit)"}
{"input": "<s> import Data.List <EOL> -- Given a grid with N rows and N columns (N >= 2) and a positive integer k, <EOL> -- each cell of the grid contains a value. Every integer in the range [1, N * N] <EOL> -- inclusive appears exactly once on the cells of the grid. <EOL> --  <EOL> -- You have to find the minimum path of length k in the grid. You can start <EOL> -- from any cell, and in each step you can move to any of the neighbor cells, <EOL> -- in other words, you can go to cells which share an edge with you current <EOL> -- cell. <EOL> -- Please note that a path of length k means visiting exactly k cells (not <EOL> -- necessarily distinct). <EOL> -- You CANNOT go off the grid. <EOL> -- A path A (of length k) is considered less than a path B (of length k) if <EOL> -- after making the ordered lists of the values on the cells that A and B go <EOL> -- through (let's call them lst_A and lst_B), lst_A is lexicographically less <EOL> -- than lst_B, in other words, there exist an integer index i (1 <= i <= k) <EOL> -- such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have <EOL> -- lst_A[j] = lst_B[j]. <EOL> -- It is guaranteed that the answer is unique. <EOL> -- Return an ordered list of the values on the cells that the minimum path go through. <EOL> -- <EOL> -- Examples: <EOL> -- <EOL> --     Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3 <EOL> --     Output: [1, 2, 1] <EOL> -- <EOL> --     Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1 <EOL> --     Output: [1] <EOL> minPath :: [[Int]] -> Int -> [Int] <EOL> minPath grid k = seq [1, smallest_neighbor $ one_pos grid] k <EOL>     where <EOL>         one_pos :: [[Int]] -> (Int, Int) <EOL>         one_pos [] = (-1, -1) <EOL>         one_pos (x:xs) = case elemIndex 1 x of <EOL>             Just i -> (i, 0) <EOL>             Nothing -> case one_pos xs of <EOL>                 (-1, -1) -> (-1, -1) <EOL>                 (i, j) -> (i, j + 1) <EOL>         n = length grid <EOL>         neighbors :: (Int, Int) -> [(Int, Int)] <EOL>         neighbors (i, j) =", "gt": "filter (\\(x, y) -> x >= 0 && x < n && y >= 0 && y < n) [(i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)]", "prediction": " [("}
{"input": "<s> import Data.List <EOL> -- Given a grid with N rows and N columns (N >= 2) and a positive integer k, <EOL> -- each cell of the grid contains a value. Every integer in the range [1, N * N] <EOL> -- inclusive appears exactly once on the cells of the grid. <EOL> --  <EOL> -- You have to find the minimum path of length k in the grid. You can start <EOL> -- from any cell, and in each step you can move to any of the neighbor cells, <EOL> -- in other words, you can go to cells which share an edge with you current <EOL> -- cell. <EOL> -- Please note that a path of length k means visiting exactly k cells (not <EOL> -- necessarily distinct). <EOL> -- You CANNOT go off the grid. <EOL> -- A path A (of length k) is considered less than a path B (of length k) if <EOL> -- after making the ordered lists of the values on the cells that A and B go <EOL> -- through (let's call them lst_A and lst_B), lst_A is lexicographically less <EOL> -- than lst_B, in other words, there exist an integer index i (1 <= i <= k) <EOL> -- such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have <EOL> -- lst_A[j] = lst_B[j]. <EOL> -- It is guaranteed that the answer is unique. <EOL> -- Return an ordered list of the values on the cells that the minimum path go through. <EOL> -- <EOL> -- Examples: <EOL> -- <EOL> --     Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3 <EOL> --     Output: [1, 2, 1] <EOL> -- <EOL> --     Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1 <EOL> --     Output: [1] <EOL> minPath :: [[Int]] -> Int -> [Int] <EOL> minPath grid k =", "gt": "seq [1, smallest_neighbor $ one_pos grid] k", "prediction": " map"}
{"input": "<s> import Data.List <EOL> -- Given a grid with N rows and N columns (N >= 2) and a positive integer k, <EOL> -- each cell of the grid contains a value. Every integer in the range [1, N * N] <EOL> -- inclusive appears exactly once on the cells of the grid. <EOL> --  <EOL> -- You have to find the minimum path of length k in the grid. You can start <EOL> -- from any cell, and in each step you can move to any of the neighbor cells, <EOL> -- in other words, you can go to cells which share an edge with you current <EOL> -- cell. <EOL> -- Please note that a path of length k means visiting exactly k cells (not <EOL> -- necessarily distinct). <EOL> -- You CANNOT go off the grid. <EOL> -- A path A (of length k) is considered less than a path B (of length k) if <EOL> -- after making the ordered lists of the values on the cells that A and B go <EOL> -- through (let's call them lst_A and lst_B), lst_A is lexicographically less <EOL> -- than lst_B, in other words, there exist an integer index i (1 <= i <= k) <EOL> -- such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have <EOL> -- lst_A[j] = lst_B[j]. <EOL> -- It is guaranteed that the answer is unique. <EOL> -- Return an ordered list of the values on the cells that the minimum path go through. <EOL> -- <EOL> -- Examples: <EOL> -- <EOL> --     Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3 <EOL> --     Output: [1, 2, 1] <EOL> -- <EOL> --     Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1 <EOL> --     Output: [1] <EOL> minPath :: [[Int]] -> Int -> [Int] <EOL> minPath grid k = seq [1, smallest_neighbor $ one_pos grid] k <EOL>     where <EOL>         one_pos :: [[Int]] -> (Int, Int) <EOL>         one_pos [] = (-1, -1) <EOL>         one_pos (x:xs) = case elemIndex 1 x of <EOL>             Just i -> (i, 0) <EOL>             Nothing -> case one_pos xs of <EOL>                 (-1, -1) -> (-1, -1) <EOL>                 (i, j) -> (i, j + 1) <EOL>         n = length grid <EOL>         neighbors :: (Int, Int) -> [(Int, Int)] <EOL>         neighbors (i, j) = filter (\\(x, y) -> x >= 0 && x < n && y >= 0 && y < n) [(i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)] <EOL>         smallest_neighbor :: (Int, Int) -> Int <EOL>         smallest_neighbor (i, j) = minimum $ map (\\(x, y) -> grid !! x !! y) $", "gt": "neighbors (i, j)", "prediction": " zip [1..] neighbors"}
{"input": "<s> import Data.List <EOL> -- Given a grid with N rows and N columns (N >= 2) and a positive integer k, <EOL> -- each cell of the grid contains a value. Every integer in the range [1, N * N] <EOL> -- inclusive appears exactly once on the cells of the grid. <EOL> --  <EOL> -- You have to find the minimum path of length k in the grid. You can start <EOL> -- from any cell, and in each step you can move to any of the neighbor cells, <EOL> -- in other words, you can go to cells which share an edge with you current <EOL> -- cell. <EOL> -- Please note that a path of length k means visiting exactly k cells (not <EOL> -- necessarily distinct). <EOL> -- You CANNOT go off the grid. <EOL> -- A path A (of length k) is considered less than a path B (of length k) if <EOL> -- after making the ordered lists of the values on the cells that A and B go <EOL> -- through (let's call them lst_A and lst_B), lst_A is lexicographically less <EOL> -- than lst_B, in other words, there exist an integer index i (1 <= i <= k) <EOL> -- such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have <EOL> -- lst_A[j] = lst_B[j]. <EOL> -- It is guaranteed that the answer is unique. <EOL> -- Return an ordered list of the values on the cells that the minimum path go through. <EOL> -- <EOL> -- Examples: <EOL> -- <EOL> --     Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3 <EOL> --     Output: [1, 2, 1] <EOL> -- <EOL> --     Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1 <EOL> --     Output: [1] <EOL> minPath :: [[Int]] -> Int -> [Int] <EOL> minPath grid k = seq [1, smallest_neighbor $ one_pos grid] k <EOL>     where <EOL>         one_pos :: [[Int]] -> (Int, Int) <EOL>         one_pos [] = (-1, -1) <EOL>         one_pos (x:xs) =", "gt": "case elemIndex 1 x of", "prediction": " ("}
{"input": "<s> import Data.List <EOL> -- Given a grid with N rows and N columns (N >= 2) and a positive integer k, <EOL> -- each cell of the grid contains a value. Every integer in the range [1, N * N] <EOL> -- inclusive appears exactly once on the cells of the grid. <EOL> --  <EOL> -- You have to find the minimum path of length k in the grid. You can start <EOL> -- from any cell, and in each step you can move to any of the neighbor cells, <EOL> -- in other words, you can go to cells which share an edge with you current <EOL> -- cell. <EOL> -- Please note that a path of length k means visiting exactly k cells (not <EOL> -- necessarily distinct). <EOL> -- You CANNOT go off the grid. <EOL> -- A path A (of length k) is considered less than a path B (of length k) if <EOL> -- after making the ordered lists of the values on the cells that A and B go <EOL> -- through (let's call them lst_A and lst_B), lst_A is lexicographically less <EOL> -- than lst_B, in other words, there exist an integer index i (1 <= i <= k) <EOL> -- such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have <EOL> -- lst_A[j] = lst_B[j]. <EOL> -- It is guaranteed that the answer is unique. <EOL> -- Return an ordered list of the values on the cells that the minimum path go through. <EOL> -- <EOL> -- Examples: <EOL> -- <EOL> --     Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3 <EOL> --     Output: [1, 2, 1] <EOL> -- <EOL> --     Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1 <EOL> --     Output: [1] <EOL> minPath :: [[Int]] -> Int -> [Int] <EOL> minPath grid k = seq [1, smallest_neighbor $ one_pos grid] k <EOL>     where <EOL>         one_pos :: [[Int]] -> (Int, Int) <EOL>         one_pos [] =", "gt": "(-1, -1)", "prediction": " (0, k)"}
{"input": "<s> -- Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence. <EOL> --  <EOL> -- The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined <EOL> -- as follows: start with any positive integer n. Then each term is obtained from the  <EOL> -- previous term as follows: if the previous term is even, the next term is one half of  <EOL> -- the previous term. If the previous term is odd, the next term is 3 times the previous <EOL> -- term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1. <EOL> --  <EOL> -- Note:  <EOL> --     1. Collatz(1) is [1]. <EOL> --     2. returned list sorted in increasing order. <EOL> --  <EOL> -- For example: <EOL> -- get_odd_collatz 5 returns [1,5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5. <EOL> import Data.List (sort) <EOL> get_odd_collatz :: Int -> [Int] <EOL> get_odd_collatz n = sort $ filter odd $ collatz n <EOL>   where <EOL>     collatz :: Int -> [Int] <EOL>     collatz 1 = [1] <EOL>     collatz x <EOL>       | even x =", "gt": "x : collatz (x `div` 2)", "prediction": " collatz (x+1)"}
{"input": "<s> -- Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence. <EOL> --  <EOL> -- The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined <EOL> -- as follows: start with any positive integer n. Then each term is obtained from the  <EOL> -- previous term as follows: if the previous term is even, the next term is one half of  <EOL> -- the previous term. If the previous term is odd, the next term is 3 times the previous <EOL> -- term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1. <EOL> --  <EOL> -- Note:  <EOL> --     1. Collatz(1) is [1]. <EOL> --     2. returned list sorted in increasing order. <EOL> --  <EOL> -- For example: <EOL> -- get_odd_collatz 5 returns [1,5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5. <EOL> import Data.List (sort) <EOL> get_odd_collatz :: Int -> [Int] <EOL> get_odd_collatz n = sort $ filter odd $ collatz n <EOL>   where <EOL>     collatz :: Int -> [Int] <EOL>     collatz 1 =", "gt": "[1]", "prediction": " [1]"}
{"input": "<s> -- Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence. <EOL> --  <EOL> -- The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined <EOL> -- as follows: start with any positive integer n. Then each term is obtained from the  <EOL> -- previous term as follows: if the previous term is even, the next term is one half of  <EOL> -- the previous term. If the previous term is odd, the next term is 3 times the previous <EOL> -- term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1. <EOL> --  <EOL> -- Note:  <EOL> --     1. Collatz(1) is [1]. <EOL> --     2. returned list sorted in increasing order. <EOL> --  <EOL> -- For example: <EOL> -- get_odd_collatz 5 returns [1,5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5. <EOL> import Data.List (sort) <EOL> get_odd_collatz :: Int -> [Int] <EOL> get_odd_collatz n = sort $ filter odd $ collatz n <EOL>   where <EOL>     collatz :: Int -> [Int] <EOL>     collatz 1 = [1] <EOL>     collatz x <EOL>       | even x = x : collatz (x `div` 2) <EOL>       | otherwise = x : collatz (x * 3 +", "gt": "1)", "prediction": " 1)"}
{"input": "<s> -- Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence. <EOL> --  <EOL> -- The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined <EOL> -- as follows: start with any positive integer n. Then each term is obtained from the  <EOL> -- previous term as follows: if the previous term is even, the next term is one half of  <EOL> -- the previous term. If the previous term is odd, the next term is 3 times the previous <EOL> -- term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1. <EOL> --  <EOL> -- Note:  <EOL> --     1. Collatz(1) is [1]. <EOL> --     2. returned list sorted in increasing order. <EOL> --  <EOL> -- For example: <EOL> -- get_odd_collatz 5 returns [1,5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5. <EOL> import Data.List (sort) <EOL> get_odd_collatz :: Int -> [Int] <EOL> get_odd_collatz n = sort $ filter odd $ collatz n <EOL>   where <EOL>     collatz :: Int -> [Int] <EOL>     collatz 1 = [1] <EOL>     collatz x <EOL>       | even x = x : collatz", "gt": "(x `div` 2)", "prediction": " (x+1)"}
{"input": "<s> -- Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence. <EOL> --  <EOL> -- The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined <EOL> -- as follows: start with any positive integer n. Then each term is obtained from the  <EOL> -- previous term as follows: if the previous term is even, the next term is one half of  <EOL> -- the previous term. If the previous term is odd, the next term is 3 times the previous <EOL> -- term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1. <EOL> --  <EOL> -- Note:  <EOL> --     1. Collatz(1) is [1]. <EOL> --     2. returned list sorted in increasing order. <EOL> --  <EOL> -- For example: <EOL> -- get_odd_collatz 5 returns [1,5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5. <EOL> import Data.List (sort) <EOL> get_odd_collatz :: Int -> [Int] <EOL> get_odd_collatz n = sort $ filter odd $ collatz n <EOL>   where <EOL>     collatz :: Int -> [Int] <EOL>     collatz 1 = [1] <EOL>     collatz x <EOL>       | even x = x : collatz (x `div` 2) <EOL>       | otherwise = x : collatz", "gt": "(x * 3 + 1)", "prediction": " (x `div` 2)"}
{"input": "<s> -- Given a positive integer n, you have to make a pile of n levels of stones. <EOL> -- The first level has n stones. <EOL> -- The number of stones in the next level is: <EOL> --     - the next odd number if n is odd. <EOL> --     - the next even number if n is even. <EOL> -- Return the number of stones in each level in a list, where element at index <EOL> -- i represents the number of stones in the level (i+1). <EOL> -- <EOL> -- Examples: <EOL> -- >>> make_a_pile 3 <EOL> -- [3,5,7] <EOL> make_a_pile :: Int -> [Int] <EOL> make_a_pile n = <EOL>   [ n +", "gt": "2 * i", "prediction": " 1 .. n - 1 ]"}
{"input": "<s> -- Given a positive integer n, you have to make a pile of n levels of stones. <EOL> -- The first level has n stones. <EOL> -- The number of stones in the next level is: <EOL> --     - the next odd number if n is odd. <EOL> --     - the next even number if n is even. <EOL> -- Return the number of stones in each level in a list, where element at index <EOL> -- i represents the number of stones in the level (i+1). <EOL> -- <EOL> -- Examples: <EOL> -- >>> make_a_pile 3 <EOL> -- [3,5,7] <EOL> make_a_pile :: Int -> [Int] <EOL> make_a_pile n = <EOL>   [ n + 2 * i <EOL>     | i <-", "gt": "[0 .. n - 1]", "prediction": " [1..n]"}
{"input": "<s> -- Given a positive integer n, you have to make a pile of n levels of stones. <EOL> -- The first level has n stones. <EOL> -- The number of stones in the next level is: <EOL> --     - the next odd number if n is odd. <EOL> --     - the next even number if n is even. <EOL> -- Return the number of stones in each level in a list, where element at index <EOL> -- i represents the number of stones in the level (i+1). <EOL> -- <EOL> -- Examples: <EOL> -- >>> make_a_pile 3 <EOL> -- [3,5,7] <EOL> make_a_pile :: Int -> [Int] <EOL> make_a_pile n = <EOL>   [ n + 2 * i <EOL>     | i <- [0 ..", "gt": "n - 1]", "prediction": " n - 1]"}
{"input": "<s> -- Given a positive integer n, return the count of the numbers of n-digit <EOL> -- positive integers that start or end with 1. <EOL> starts_one_ends :: Int -> Int <EOL> starts_one_ends n = if n == 1 then 1", "gt": "else 18 * (10 ^ (n - 2))", "prediction": " else 0"}
{"input": "<s> -- Given a positive integer n, return the count of the numbers of n-digit <EOL> -- positive integers that start or end with 1. <EOL> starts_one_ends :: Int -> Int <EOL> starts_one_ends n =", "gt": "if n == 1 then 1 else 18 * (10 ^ (n - 2))", "prediction": " if"}
{"input": "<s> -- Given a positive integer n, return the count of the numbers of n-digit <EOL> -- positive integers that start or end with 1. <EOL> starts_one_ends :: Int -> Int <EOL> starts_one_ends n = if n == 1", "gt": "then 1 else 18 * (10 ^ (n - 2))", "prediction": " then"}
{"input": "<s> import Data.List <EOL> -- You'll be given a string of words, and your task is to count the number <EOL> -- of boredoms. A boredom is a sentence that starts with the word \"I\". <EOL> -- Sentences are delimited by '.', '?' or '!'. <EOL> -- For example: <EOL> -- >>> is_bored \"Hello world\" <EOL> -- 0 <EOL> -- >>> is_bored \"The sky is blue. The sun is shining. I love this weather\" <EOL> -- 1 <EOL> is_bored :: String -> Int <EOL> is_bored s = <EOL>   sum <EOL>     [ 1 <EOL>       | sentence <- splitOnDelimiters s, <EOL>         take 2 sentence == \"I \" <EOL>     ] <EOL> -- Helper function to split the string based on delimiters '.', '!', and '?' <EOL> splitOnDelimiters :: String -> [String] <EOL> splitOnDelimiters [] = [] <EOL> splitOnDelimiters s = case break (`elem` \".?!\") s of <EOL>   (sentence, []) -> [sentence] <EOL>   (sentence, (_ : rest)) -> sentence :", "gt": "splitOnDelimiters (dropWhile (`elem` \" \") rest)", "prediction": " rest"}
{"input": "<s> import Data.List <EOL> -- You'll be given a string of words, and your task is to count the number <EOL> -- of boredoms. A boredom is a sentence that starts with the word \"I\". <EOL> -- Sentences are delimited by '.', '?' or '!'. <EOL> -- For example: <EOL> -- >>> is_bored \"Hello world\" <EOL> -- 0 <EOL> -- >>> is_bored \"The sky is blue. The sun is shining. I love this weather\" <EOL> -- 1 <EOL> is_bored :: String -> Int <EOL> is_bored s = <EOL>   sum <EOL>     [ 1 <EOL>       | sentence <- splitOnDelimiters s, <EOL>         take 2 sentence == \"I \" <EOL>     ] <EOL> -- Helper function to split the string based on delimiters '.', '!', and '?' <EOL> splitOnDelimiters :: String -> [String] <EOL> splitOnDelimiters [] = [] <EOL> splitOnDelimiters s = case break", "gt": "(`elem` \".?!\") s of", "prediction": " (Space s of"}
{"input": "<s> import Data.List <EOL> -- You'll be given a string of words, and your task is to count the number <EOL> -- of boredoms. A boredom is a sentence that starts with the word \"I\". <EOL> -- Sentences are delimited by '.', '?' or '!'. <EOL> -- For example: <EOL> -- >>> is_bored \"Hello world\" <EOL> -- 0 <EOL> -- >>> is_bored \"The sky is blue. The sun is shining. I love this weather\" <EOL> -- 1 <EOL> is_bored :: String -> Int <EOL> is_bored s = <EOL>   sum <EOL>     [ 1 <EOL>       | sentence <- splitOnDelimiters s, <EOL>         take 2 sentence == \"I \" <EOL>     ] <EOL> -- Helper function to split the string based on delimiters '.', '!', and '?' <EOL> splitOnDelimiters :: String -> [String] <EOL> splitOnDelimiters [] = [] <EOL> splitOnDelimiters s = case break (`elem` \".?!\") s of <EOL>   (sentence, []) ->", "gt": "[sentence]", "prediction": " sentence"}
{"input": "<s> import Data.List <EOL> -- You'll be given a string of words, and your task is to count the number <EOL> -- of boredoms. A boredom is a sentence that starts with the word \"I\". <EOL> -- Sentences are delimited by '.', '?' or '!'. <EOL> -- For example: <EOL> -- >>> is_bored \"Hello world\" <EOL> -- 0 <EOL> -- >>> is_bored \"The sky is blue. The sun is shining. I love this weather\" <EOL> -- 1 <EOL> is_bored :: String -> Int <EOL> is_bored s = <EOL>   sum <EOL>     [ 1 <EOL>       | sentence <- splitOnDelimiters s, <EOL>         take 2 sentence ==", "gt": "\"I \"", "prediction": " \"I\""}
{"input": "<s> import Data.List <EOL> -- You'll be given a string of words, and your task is to count the number <EOL> -- of boredoms. A boredom is a sentence that starts with the word \"I\". <EOL> -- Sentences are delimited by '.', '?' or '!'. <EOL> -- For example: <EOL> -- >>> is_bored \"Hello world\" <EOL> -- 0 <EOL> -- >>> is_bored \"The sky is blue. The sun is shining. I love this weather\" <EOL> -- 1 <EOL> is_bored :: String -> Int <EOL> is_bored s = <EOL>   sum <EOL>     [ 1 <EOL>       | sentence <- splitOnDelimiters s, <EOL>         take 2 sentence == \"I \" <EOL>     ] <EOL> -- Helper function to split the string based on delimiters '.', '!', and '?' <EOL> splitOnDelimiters :: String -> [String] <EOL> splitOnDelimiters [] = [] <EOL> splitOnDelimiters s = case break (`elem` \".?!\") s of <EOL>   (sentence, []) -> [sentence] <EOL>   (sentence, (_ : rest)) -> sentence : splitOnDelimiters (dropWhile", "gt": "(`elem` \" \") rest)", "prediction": " isSpace rest)"}
{"input": "<s> import Data.Char <EOL> -- In this task, you will be given a string that represents a number of apples and oranges <EOL> -- that are distributed in a basket of fruit this basket contains <EOL> -- apples, oranges, and mango fruits. Given the string that represents the total number of <EOL> -- the oranges and apples and an integer that represent the total number of the fruits <EOL> -- in the basket return the number of the mango fruits in the basket. <EOL> -- for examble: <EOL> -- fruit_distribution \"5 apples and 6 oranges\" 19 ->19 - 5 - 6 = 8 <EOL> -- fruit_distribution \"0 apples and 1 oranges\" 3 -> 3 - 0 - 1 = 2 <EOL> -- fruit_distribution \"2 apples and 3 oranges\" 100 -> 100 - 2 - 3 = 95 <EOL> -- fruit_distribution \"100 apples and 1 oranges\" 120 -> 120 - 100 - 1 = 19 <EOL> fruit_distribution :: String -> Int -> Int <EOL> fruit_distribution s n = n - sum (map read (words (filter (\\x ->", "gt": "isDigit x || isSpace x) s)) :: [Int])", "prediction": " x `mod` n == 0) s)))"}
{"input": "<s> import Data.Char <EOL> -- In this task, you will be given a string that represents a number of apples and oranges <EOL> -- that are distributed in a basket of fruit this basket contains <EOL> -- apples, oranges, and mango fruits. Given the string that represents the total number of <EOL> -- the oranges and apples and an integer that represent the total number of the fruits <EOL> -- in the basket return the number of the mango fruits in the basket. <EOL> -- for examble: <EOL> -- fruit_distribution \"5 apples and 6 oranges\" 19 ->19 - 5 - 6 = 8 <EOL> -- fruit_distribution \"0 apples and 1 oranges\" 3 -> 3 - 0 - 1 = 2 <EOL> -- fruit_distribution \"2 apples and 3 oranges\" 100 -> 100 - 2 - 3 = 95 <EOL> -- fruit_distribution \"100 apples and 1 oranges\" 120 -> 120 - 100 - 1 = 19 <EOL> fruit_distribution :: String -> Int -> Int <EOL> fruit_distribution s n =", "gt": "n - sum (map read (words (filter (\\x -> isDigit x || isSpace x) s)) :: [Int])", "prediction": " undefined"}
{"input": "<s> import Data.List <EOL> -- Write a function that takes a string and returns an ordered version of it. <EOL> -- Ordered version of string, is a string where all words (separated by space) <EOL> -- are replaced by a new word where all the characters arranged in <EOL> -- ascending order based on ascii value. <EOL> -- Note: You should keep the order of words and blank spaces in the sentence. <EOL> --  <EOL> -- For example: <EOL> -- anti_shuffle \"Hi\" returns \"Hi\" <EOL> -- anti_shuffle \"hello\" returns \"ehllo\" <EOL> -- anti_shuffle \"Hello World!!!\" returns \"Hello !!!Wdlor\" <EOL> anti_shuffle :: String -> String <EOL> anti_shuffle s = unwords [sort i | i <-", "gt": "words s]", "prediction": " words s]"}
{"input": "<s> import Data.List <EOL> -- Write a function that takes a string and returns an ordered version of it. <EOL> -- Ordered version of string, is a string where all words (separated by space) <EOL> -- are replaced by a new word where all the characters arranged in <EOL> -- ascending order based on ascii value. <EOL> -- Note: You should keep the order of words and blank spaces in the sentence. <EOL> --  <EOL> -- For example: <EOL> -- anti_shuffle \"Hi\" returns \"Hi\" <EOL> -- anti_shuffle \"hello\" returns \"ehllo\" <EOL> -- anti_shuffle \"Hello World!!!\" returns \"Hello !!!Wdlor\" <EOL> anti_shuffle :: String -> String <EOL> anti_shuffle s =", "gt": "unwords [sort i | i <- words s]", "prediction": " undefined"}
{"input": "<s> import Data.List <EOL> -- Write a function that takes a string and returns an ordered version of it. <EOL> -- Ordered version of string, is a string where all words (separated by space) <EOL> -- are replaced by a new word where all the characters arranged in <EOL> -- ascending order based on ascii value. <EOL> -- Note: You should keep the order of words and blank spaces in the sentence. <EOL> --  <EOL> -- For example: <EOL> -- anti_shuffle \"Hi\" returns \"Hi\" <EOL> -- anti_shuffle \"hello\" returns \"ehllo\" <EOL> -- anti_shuffle \"Hello World!!!\" returns \"Hello !!!Wdlor\" <EOL> anti_shuffle :: String -> String <EOL> anti_shuffle s = unwords", "gt": "[sort i | i <- words s]", "prediction": " $"}
{"input": "<s> -- Input to this function is a string represented multiple groups for nested parentheses separated by spaces. <EOL> -- For each of the group, output the deepest level of nesting of parentheses. <EOL> -- E.g. (()()) has maximum two levels of nesting while ((())) has three. <EOL> -- <EOL> -- >>> parse_nested_parens \"(()()) ((())) () ((())()())\" <EOL> -- [2,3,1,3] <EOL> parse_nested_parens :: String -> [Int] <EOL> parse_nested_parens paren_string = get_paren_depths paren_string 0 [] <EOL>     where <EOL>         get_paren_depths :: String -> Int -> [Int] -> [Int] <EOL>         get_paren_depths \"\" _ max_depths = max_depths <EOL>         get_paren_depths ('(':cs) 0 max_depths = get_paren_depths cs 1 (max_depths ++ [1]) <EOL>         get_paren_depths ('(':cs) depth max_depths = get_paren_depths cs (depth + 1) ((reverse . tail . reverse $ max_depths) ++ [max (head $ reverse max_depths) (depth + 1)]) <EOL>         get_paren_depths (')':cs) depth max_depths =", "gt": "get_paren_depths cs (depth - 1) max_depths", "prediction": " get_paren_depths cs depth max_depths"}
{"input": "<s> -- Input to this function is a string represented multiple groups for nested parentheses separated by spaces. <EOL> -- For each of the group, output the deepest level of nesting of parentheses. <EOL> -- E.g. (()()) has maximum two levels of nesting while ((())) has three. <EOL> -- <EOL> -- >>> parse_nested_parens \"(()()) ((())) () ((())()())\" <EOL> -- [2,3,1,3] <EOL> parse_nested_parens :: String -> [Int] <EOL> parse_nested_parens paren_string = get_paren_depths paren_string 0 [] <EOL>     where <EOL>         get_paren_depths :: String -> Int -> [Int] -> [Int] <EOL>         get_paren_depths \"\" _ max_depths = max_depths <EOL>         get_paren_depths ('(':cs) 0 max_depths = get_paren_depths cs 1 (max_depths ++ [1]) <EOL>         get_paren_depths ('(':cs) depth max_depths = get_paren_depths cs (depth + 1) ((reverse . tail . reverse $ max_depths) ++", "gt": "[max (head $ reverse max_depths) (depth + 1)])", "prediction": " cs)"}
{"input": "<s> -- Input to this function is a string represented multiple groups for nested parentheses separated by spaces. <EOL> -- For each of the group, output the deepest level of nesting of parentheses. <EOL> -- E.g. (()()) has maximum two levels of nesting while ((())) has three. <EOL> -- <EOL> -- >>> parse_nested_parens \"(()()) ((())) () ((())()())\" <EOL> -- [2,3,1,3] <EOL> parse_nested_parens :: String -> [Int] <EOL> parse_nested_parens paren_string = get_paren_depths paren_string 0 [] <EOL>     where <EOL>         get_paren_depths :: String -> Int -> [Int] -> [Int] <EOL>         get_paren_depths \"\" _ max_depths = max_depths <EOL>         get_paren_depths ('(':cs) 0 max_depths = get_paren_depths cs 1 (max_depths ++ [1]) <EOL>         get_paren_depths ('(':cs) depth max_depths = get_paren_depths cs (depth + 1) ((reverse . tail . reverse $ max_depths) ++ [max (head $ reverse max_depths) (depth + 1)]) <EOL>         get_paren_depths (')':cs) depth max_depths = get_paren_depths cs (depth - 1) max_depths <EOL>         get_paren_depths (_:cs) depth max_depths =", "gt": "get_paren_depths cs depth max_depths", "prediction": " get_paren_depths cs (depth + 1) max_depths"}
{"input": "<s> -- Input to this function is a string represented multiple groups for nested parentheses separated by spaces. <EOL> -- For each of the group, output the deepest level of nesting of parentheses. <EOL> -- E.g. (()()) has maximum two levels of nesting while ((())) has three. <EOL> -- <EOL> -- >>> parse_nested_parens \"(()()) ((())) () ((())()())\" <EOL> -- [2,3,1,3] <EOL> parse_nested_parens :: String -> [Int] <EOL> parse_nested_parens paren_string = get_paren_depths paren_string 0 [] <EOL>     where <EOL>         get_paren_depths :: String -> Int -> [Int] -> [Int] <EOL>         get_paren_depths \"\" _ max_depths = max_depths <EOL>         get_paren_depths ('(':cs) 0 max_depths =", "gt": "get_paren_depths cs 1 (max_depths ++ [1])", "prediction": " get_paren_depths cs 0 max_depths"}
{"input": "<s> -- Input to this function is a string represented multiple groups for nested parentheses separated by spaces. <EOL> -- For each of the group, output the deepest level of nesting of parentheses. <EOL> -- E.g. (()()) has maximum two levels of nesting while ((())) has three. <EOL> -- <EOL> -- >>> parse_nested_parens \"(()()) ((())) () ((())()())\" <EOL> -- [2,3,1,3] <EOL> parse_nested_parens :: String -> [Int] <EOL> parse_nested_parens paren_string = get_paren_depths paren_string 0 [] <EOL>     where <EOL>         get_paren_depths :: String -> Int -> [Int] -> [Int] <EOL>         get_paren_depths \"\" _ max_depths = max_depths <EOL>         get_paren_depths ('(':cs) 0 max_depths = get_paren_depths cs 1", "gt": "(max_depths ++ [1])", "prediction": " max_depths"}
{"input": "<s> import Data.Char <EOL> -- Create a function encrypt that takes a string as an argument and <EOL> -- returns a string encrypted with the alphabet being rotated. <EOL> -- The alphabet should be rotated in a manner such that the letters <EOL> -- shift down by two multiplied to two places. <EOL> -- For example: <EOL> -- >>> encrypt \"hi\" <EOL> -- \"lm\" <EOL> -- >>> encrypt \"asdfghjkl\" <EOL> -- \"ewhjklnop\" <EOL> -- >>> encrypt \"gf\" <EOL> -- \"kj\" <EOL> -- >>> encrypt \"et\" <EOL> -- \"ix\" <EOL> encrypt :: String -> String <EOL> encrypt s = <EOL>   let d = ['a' .. 'z'] <EOL>    in [ d !! ((fromEnum c - fromEnum 'a' + 2 * 2) `mod` 26) <EOL>         | c <-", "gt": "s", "prediction": " [' ]"}
{"input": "<s> import Data.Char <EOL> -- Create a function encrypt that takes a string as an argument and <EOL> -- returns a string encrypted with the alphabet being rotated. <EOL> -- The alphabet should be rotated in a manner such that the letters <EOL> -- shift down by two multiplied to two places. <EOL> -- For example: <EOL> -- >>> encrypt \"hi\" <EOL> -- \"lm\" <EOL> -- >>> encrypt \"asdfghjkl\" <EOL> -- \"ewhjklnop\" <EOL> -- >>> encrypt \"gf\" <EOL> -- \"kj\" <EOL> -- >>> encrypt \"et\" <EOL> -- \"ix\" <EOL> encrypt :: String -> String <EOL> encrypt s = <EOL>   let d = ['a' .. 'z'] <EOL>    in [ d !! ((fromEnum c - fromEnum 'a' + 2 * 2) `mod`", "gt": "26)", "prediction": " 26)"}
{"input": "<s> import Data.Char <EOL> -- Create a function encrypt that takes a string as an argument and <EOL> -- returns a string encrypted with the alphabet being rotated. <EOL> -- The alphabet should be rotated in a manner such that the letters <EOL> -- shift down by two multiplied to two places. <EOL> -- For example: <EOL> -- >>> encrypt \"hi\" <EOL> -- \"lm\" <EOL> -- >>> encrypt \"asdfghjkl\" <EOL> -- \"ewhjklnop\" <EOL> -- >>> encrypt \"gf\" <EOL> -- \"kj\" <EOL> -- >>> encrypt \"et\" <EOL> -- \"ix\" <EOL> encrypt :: String -> String <EOL> encrypt s = <EOL>   let d =", "gt": "['a' .. 'z']", "prediction": " ord s"}
{"input": "<s> import Data.Char <EOL> -- Create a function encrypt that takes a string as an argument and <EOL> -- returns a string encrypted with the alphabet being rotated. <EOL> -- The alphabet should be rotated in a manner such that the letters <EOL> -- shift down by two multiplied to two places. <EOL> -- For example: <EOL> -- >>> encrypt \"hi\" <EOL> -- \"lm\" <EOL> -- >>> encrypt \"asdfghjkl\" <EOL> -- \"ewhjklnop\" <EOL> -- >>> encrypt \"gf\" <EOL> -- \"kj\" <EOL> -- >>> encrypt \"et\" <EOL> -- \"ix\" <EOL> encrypt :: String -> String <EOL> encrypt s = <EOL>   let d = ['a' .. 'z'] <EOL>    in [ d !! ((fromEnum c - fromEnum 'a' +", "gt": "2 * 2) `mod` 26)", "prediction": " 1) `mod` 26)"}
{"input": "<s> import Data.Char <EOL> -- Create a function encrypt that takes a string as an argument and <EOL> -- returns a string encrypted with the alphabet being rotated. <EOL> -- The alphabet should be rotated in a manner such that the letters <EOL> -- shift down by two multiplied to two places. <EOL> -- For example: <EOL> -- >>> encrypt \"hi\" <EOL> -- \"lm\" <EOL> -- >>> encrypt \"asdfghjkl\" <EOL> -- \"ewhjklnop\" <EOL> -- >>> encrypt \"gf\" <EOL> -- \"kj\" <EOL> -- >>> encrypt \"et\" <EOL> -- \"ix\" <EOL> encrypt :: String -> String <EOL> encrypt s = <EOL>   let d = ['a' .. 'z'] <EOL>    in [ d !!", "gt": "((fromEnum c - fromEnum 'a' + 2 * 2) `mod` 26)", "prediction": " i"}
{"input": "<s> -- You are given a list of two strings, both strings consist of open <EOL> -- parentheses '(' or close parentheses ')' only. <EOL> -- Your job is to check if it is possible to concatenate the two strings in <EOL> -- some order, that the resulting string will be good. <EOL> -- A string S is considered to be good if and only if all parentheses in S <EOL> -- are balanced. For example: the string '(())()' is good, while the string <EOL> -- '())' is not. <EOL> -- Return 'Yes' if there's a way to make a good string, and return 'No' otherwise. <EOL> --  <EOL> -- Examples: <EOL> -- match_parens [\"()(\", \")\"] == \"Yes\" <EOL> -- match_parens [\")\", \")\"] == \"No\" <EOL> match_parens :: [String] -> String <EOL> match_parens [s1, s2] = if check (s1 ++ s2) ||", "gt": "check (s2 ++ s1) then \"Yes\" else \"No\"", "prediction": " check (s2 ++ s1)"}
{"input": "<s> -- You are given a list of two strings, both strings consist of open <EOL> -- parentheses '(' or close parentheses ')' only. <EOL> -- Your job is to check if it is possible to concatenate the two strings in <EOL> -- some order, that the resulting string will be good. <EOL> -- A string S is considered to be good if and only if all parentheses in S <EOL> -- are balanced. For example: the string '(())()' is good, while the string <EOL> -- '())' is not. <EOL> -- Return 'Yes' if there's a way to make a good string, and return 'No' otherwise. <EOL> --  <EOL> -- Examples: <EOL> -- match_parens [\"()(\", \")\"] == \"Yes\" <EOL> -- match_parens [\")\", \")\"] == \"No\" <EOL> match_parens :: [String] -> String <EOL> match_parens [s1, s2] = if check (s1 ++ s2) || check (s2 ++ s1) then \"Yes\" else \"No\" <EOL>   where <EOL>     check :: String -> Bool <EOL>     check s = go s 0 <EOL>     go :: String -> Int -> Bool <EOL>     go [] n = n == 0 <EOL>     go ('(':xs) n =", "gt": "go xs (n+1)", "prediction": " go xs (n - 1)"}
{"input": "<s> -- You are given a list of two strings, both strings consist of open <EOL> -- parentheses '(' or close parentheses ')' only. <EOL> -- Your job is to check if it is possible to concatenate the two strings in <EOL> -- some order, that the resulting string will be good. <EOL> -- A string S is considered to be good if and only if all parentheses in S <EOL> -- are balanced. For example: the string '(())()' is good, while the string <EOL> -- '())' is not. <EOL> -- Return 'Yes' if there's a way to make a good string, and return 'No' otherwise. <EOL> --  <EOL> -- Examples: <EOL> -- match_parens [\"()(\", \")\"] == \"Yes\" <EOL> -- match_parens [\")\", \")\"] == \"No\" <EOL> match_parens :: [String] -> String <EOL> match_parens [s1, s2] = if", "gt": "check (s1 ++ s2) || check (s2 ++ s1) then \"Yes\" else \"No\"", "prediction": " s1 == s2"}
{"input": "<s> -- You are given a list of two strings, both strings consist of open <EOL> -- parentheses '(' or close parentheses ')' only. <EOL> -- Your job is to check if it is possible to concatenate the two strings in <EOL> -- some order, that the resulting string will be good. <EOL> -- A string S is considered to be good if and only if all parentheses in S <EOL> -- are balanced. For example: the string '(())()' is good, while the string <EOL> -- '())' is not. <EOL> -- Return 'Yes' if there's a way to make a good string, and return 'No' otherwise. <EOL> --  <EOL> -- Examples: <EOL> -- match_parens [\"()(\", \")\"] == \"Yes\" <EOL> -- match_parens [\")\", \")\"] == \"No\" <EOL> match_parens :: [String] -> String <EOL> match_parens [s1, s2] = if check (s1 ++ s2) || check (s2 ++ s1) then \"Yes\" else \"No\" <EOL>   where <EOL>     check :: String -> Bool <EOL>     check s = go s 0 <EOL>     go :: String -> Int -> Bool <EOL>     go [] n =", "gt": "n == 0", "prediction": " False"}
{"input": "<s> -- You are given a list of two strings, both strings consist of open <EOL> -- parentheses '(' or close parentheses ')' only. <EOL> -- Your job is to check if it is possible to concatenate the two strings in <EOL> -- some order, that the resulting string will be good. <EOL> -- A string S is considered to be good if and only if all parentheses in S <EOL> -- are balanced. For example: the string '(())()' is good, while the string <EOL> -- '())' is not. <EOL> -- Return 'Yes' if there's a way to make a good string, and return 'No' otherwise. <EOL> --  <EOL> -- Examples: <EOL> -- match_parens [\"()(\", \")\"] == \"Yes\" <EOL> -- match_parens [\")\", \")\"] == \"No\" <EOL> match_parens :: [String] -> String <EOL> match_parens [s1, s2] = if check (s1 ++ s2) || check (s2 ++ s1) then \"Yes\" else \"No\" <EOL>   where <EOL>     check :: String -> Bool <EOL>     check s = go s 0 <EOL>     go :: String -> Int -> Bool <EOL>     go [] n = n == 0 <EOL>     go ('(':xs) n = go xs (n+1) <EOL>     go (')':xs) n =", "gt": "n > 0 && go xs (n-1)", "prediction": " go xs (n+1)"}
{"input": "<s> import Data.List <EOL> is_palindrome :: String -> Bool <EOL> is_palindrome string = string == reverse string <EOL> -- Find the shortest palindrome that begins with a supplied string. <EOL> -- Algorithm idea is simple: <EOL> -- - Find the longest postfix of supplied string that is a palindrome. <EOL> -- - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix. <EOL> -- >>> make_palindrome \"\" <EOL> -- \"\" <EOL> -- >>> make_palindrome \"cat\" <EOL> -- \"catac\" <EOL> -- >>> make_palindrome \"cata\" <EOL> -- \"catac\" <EOL> make_palindrome :: String -> String <EOL> make_palindrome string <EOL>     | null string = \"\" <EOL>     | otherwise =", "gt": "string ++ reverse (take beginning_of_suffix string)", "prediction": " reverse string"}
{"input": "<s> import Data.List <EOL> is_palindrome :: String -> Bool <EOL> is_palindrome string = string == reverse string <EOL> -- Find the shortest palindrome that begins with a supplied string. <EOL> -- Algorithm idea is simple: <EOL> -- - Find the longest postfix of supplied string that is a palindrome. <EOL> -- - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix. <EOL> -- >>> make_palindrome \"\" <EOL> -- \"\" <EOL> -- >>> make_palindrome \"cat\" <EOL> -- \"catac\" <EOL> -- >>> make_palindrome \"cata\" <EOL> -- \"catac\" <EOL> make_palindrome :: String -> String <EOL> make_palindrome string <EOL>     | null string = \"\" <EOL>     | otherwise = string ++ reverse", "gt": "(take beginning_of_suffix string)", "prediction": " string"}
{"input": "<s> import Data.List <EOL> is_palindrome :: String -> Bool <EOL> is_palindrome string = string ==", "gt": "reverse string", "prediction": " reverse string"}
{"input": "<s> import Data.List <EOL> is_palindrome :: String -> Bool <EOL> is_palindrome string =", "gt": "string == reverse string", "prediction": " ("}
{"input": "<s> import Data.List <EOL> is_palindrome :: String -> Bool <EOL> is_palindrome string = string == reverse string <EOL> -- Find the shortest palindrome that begins with a supplied string. <EOL> -- Algorithm idea is simple: <EOL> -- - Find the longest postfix of supplied string that is a palindrome. <EOL> -- - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix. <EOL> -- >>> make_palindrome \"\" <EOL> -- \"\" <EOL> -- >>> make_palindrome \"cat\" <EOL> -- \"catac\" <EOL> -- >>> make_palindrome \"cata\" <EOL> -- \"catac\" <EOL> make_palindrome :: String -> String <EOL> make_palindrome string <EOL>     | null string = \"\" <EOL>     | otherwise = string ++ reverse (take beginning_of_suffix string) <EOL>     where <EOL>         beginning_of_suffix = length $ takeWhile", "gt": "(not . is_palindrome) $ tails string", "prediction": " (== ' ') string"}
{"input": "<s> import Data.List <EOL> import Data.Ord <EOL> -- Out of list of strings, return the longest one. Return the first one in case of multiple <EOL> -- strings of the same length. Return Nothing in case the input list is empty. <EOL> -- >>> longest [] <EOL> -- Nothing <EOL> -- >>> longest [\"a\", \"b\", \"c\"] <EOL> -- Just \"a\" <EOL> -- >>> longest [\"a\", \"bb\", \"ccc\"] <EOL> -- Just \"ccc\" <EOL> longest :: [String] -> Maybe String <EOL> longest strings = case", "gt": "strings of", "prediction": " length strings of"}
{"input": "<s> import Data.List <EOL> import Data.Ord <EOL> -- Out of list of strings, return the longest one. Return the first one in case of multiple <EOL> -- strings of the same length. Return Nothing in case the input list is empty. <EOL> -- >>> longest [] <EOL> -- Nothing <EOL> -- >>> longest [\"a\", \"b\", \"c\"] <EOL> -- Just \"a\" <EOL> -- >>> longest [\"a\", \"bb\", \"ccc\"] <EOL> -- Just \"ccc\" <EOL> longest :: [String] -> Maybe String <EOL> longest strings = case strings of <EOL>     [] ->", "gt": "Nothing", "prediction": " Nothing"}
{"input": "<s> import Data.List <EOL> import Data.Ord <EOL> -- Out of list of strings, return the longest one. Return the first one in case of multiple <EOL> -- strings of the same length. Return Nothing in case the input list is empty. <EOL> -- >>> longest [] <EOL> -- Nothing <EOL> -- >>> longest [\"a\", \"b\", \"c\"] <EOL> -- Just \"a\" <EOL> -- >>> longest [\"a\", \"bb\", \"ccc\"] <EOL> -- Just \"ccc\" <EOL> longest :: [String] -> Maybe String <EOL> longest strings = case strings of <EOL>     [] -> Nothing <EOL>     _ -> Just $ maximumBy (comparing length) $", "gt": "reverse strings", "prediction": " map (head &&& id)"}
{"input": "<s> import Data.List <EOL> import Data.Ord <EOL> -- Out of list of strings, return the longest one. Return the first one in case of multiple <EOL> -- strings of the same length. Return Nothing in case the input list is empty. <EOL> -- >>> longest [] <EOL> -- Nothing <EOL> -- >>> longest [\"a\", \"b\", \"c\"] <EOL> -- Just \"a\" <EOL> -- >>> longest [\"a\", \"bb\", \"ccc\"] <EOL> -- Just \"ccc\" <EOL> longest :: [String] -> Maybe String <EOL> longest strings = case strings of <EOL>     [] -> Nothing <EOL>     _ ->", "gt": "Just $ maximumBy (comparing length) $ reverse strings", "prediction": " Nothing"}
{"input": "<s> import Data.List <EOL> import Data.Ord <EOL> -- Out of list of strings, return the longest one. Return the first one in case of multiple <EOL> -- strings of the same length. Return Nothing in case the input list is empty. <EOL> -- >>> longest [] <EOL> -- Nothing <EOL> -- >>> longest [\"a\", \"b\", \"c\"] <EOL> -- Just \"a\" <EOL> -- >>> longest [\"a\", \"bb\", \"ccc\"] <EOL> -- Just \"ccc\" <EOL> longest :: [String] -> Maybe String <EOL> longest strings = case strings of <EOL>     [] -> Nothing <EOL>     _ -> Just $ maximumBy", "gt": "(comparing length) $ reverse strings", "prediction": " (compare `on` snd) (map (length &&& head) (sortBy (compare `on` fst) (map (length &&& head) (sortOn fst)))"}
{"input": "<s> import Data.List <EOL> -- From a supplied list of numbers (of length at least two) select and return two that are the closest to each <EOL> -- other and return them in order (smaller number, larger number). <EOL> -- >>> find_closest_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.2] <EOL> -- (2.0,2.2) <EOL> -- >>> find_closest_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.0] <EOL> -- (2.0,2.0) <EOL> find_closest_elements :: [Float] -> (Float, Float) <EOL> find_closest_elements numbers =", "gt": "head $ sortOn (\\(x, y) -> abs (x - y)) [(x,y) | (x:ys) <- tails numbers, y <- ys]", "prediction": " undefined"}
{"input": "<s> import Data.List <EOL> -- From a supplied list of numbers (of length at least two) select and return two that are the closest to each <EOL> -- other and return them in order (smaller number, larger number). <EOL> -- >>> find_closest_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.2] <EOL> -- (2.0,2.2) <EOL> -- >>> find_closest_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.0] <EOL> -- (2.0,2.0) <EOL> find_closest_elements :: [Float] -> (Float, Float) <EOL> find_closest_elements numbers = head $ sortOn", "gt": "(\\(x, y) -> abs (x - y)) [(x,y) | (x:ys) <- tails numbers, y <- ys]", "prediction": " fstcomparing fst) numbers"}
{"input": "<s> import Data.List <EOL> -- From a supplied list of numbers (of length at least two) select and return two that are the closest to each <EOL> -- other and return them in order (smaller number, larger number). <EOL> -- >>> find_closest_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.2] <EOL> -- (2.0,2.2) <EOL> -- >>> find_closest_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.0] <EOL> -- (2.0,2.0) <EOL> find_closest_elements :: [Float] -> (Float, Float) <EOL> find_closest_elements numbers = head $ sortOn (\\(x, y) -> abs (x - y))", "gt": "[(x,y) | (x:ys) <- tails numbers, y <- ys]", "prediction": " ("}
{"input": "<s> import Data.List <EOL> -- From a supplied list of numbers (of length at least two) select and return two that are the closest to each <EOL> -- other and return them in order (smaller number, larger number). <EOL> -- >>> find_closest_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.2] <EOL> -- (2.0,2.2) <EOL> -- >>> find_closest_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.0] <EOL> -- (2.0,2.0) <EOL> find_closest_elements :: [Float] -> (Float, Float) <EOL> find_closest_elements numbers = head $ sortOn (\\(x, y) ->", "gt": "abs (x - y)) [(x,y) | (x:ys) <- tails numbers, y <- ys]", "prediction": " compare x y) numbers"}
{"input": "<s> import Data.List <EOL> -- From a supplied list of numbers (of length at least two) select and return two that are the closest to each <EOL> -- other and return them in order (smaller number, larger number). <EOL> -- >>> find_closest_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.2] <EOL> -- (2.0,2.2) <EOL> -- >>> find_closest_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.0] <EOL> -- (2.0,2.0) <EOL> find_closest_elements :: [Float] -> (Float, Float) <EOL> find_closest_elements numbers = head $ sortOn (\\(x, y) -> abs (x - y)) [(x,y) | (x:ys) <-", "gt": "tails numbers, y <- ys]", "prediction": " numbers]"}
{"input": "<s> -- Create a function that takes a string as input which contains only square brackets. <EOL> -- The function should return True if and only if there is a valid subsequence of brackets <EOL> -- where at least one bracket in the subsequence is nested. <EOL> -- <EOL> -- >>> is_nested \"[[]]\" <EOL> -- True <EOL> -- >>> is_nested \"[]]]]]]][[[[[]\" <EOL> -- False <EOL> -- >>> is_nested \"[][]\" <EOL> -- False <EOL> -- >>> is_nested \"[]\" <EOL> -- False <EOL> -- >>> is_nested \"[[][]]\" <EOL> -- True <EOL> -- >>> is_nested \"[[]][[\" <EOL> -- True <EOL> is_nested :: String -> Bool <EOL> is_nested string = is_nested' string 0 [] [] <EOL>   where <EOL>     is_nested' :: String -> Int -> [Int] -> [Int] -> Bool <EOL>     is_nested' ('[' : cs) index opening_bracket_index closing_bracket_index = is_nested' cs (index + 1) (opening_bracket_index ++ [index]) closing_bracket_index <EOL>     is_nested' (']' : cs) index opening_bracket_index closing_bracket_index = is_nested' cs (index + 1) opening_bracket_index ([index] ++ closing_bracket_index) <EOL>     is_nested' \"\" index opening_bracket_index closing_bracket_index <EOL>       | index < 3 = False <EOL>       | otherwise = is_nested'' opening_bracket_index closing_bracket_index 0 (length closing_bracket_index) <EOL>       where <EOL>         is_nested'' :: [Int] -> [Int] -> Int -> Int -> Bool <EOL>         is_nested'' _ [] cnt l = cnt >= 2 <EOL>         is_nested'' [] _ cnt l = cnt >= 2 <EOL>         is_nested'' (o : os) (c : cs) cnt l <EOL>           | o < c && cnt < l =", "gt": "is_nested'' os cs (cnt + 1) l", "prediction": " False"}
{"input": "<s> -- Create a function that takes a string as input which contains only square brackets. <EOL> -- The function should return True if and only if there is a valid subsequence of brackets <EOL> -- where at least one bracket in the subsequence is nested. <EOL> -- <EOL> -- >>> is_nested \"[[]]\" <EOL> -- True <EOL> -- >>> is_nested \"[]]]]]]][[[[[]\" <EOL> -- False <EOL> -- >>> is_nested \"[][]\" <EOL> -- False <EOL> -- >>> is_nested \"[]\" <EOL> -- False <EOL> -- >>> is_nested \"[[][]]\" <EOL> -- True <EOL> -- >>> is_nested \"[[]][[\" <EOL> -- True <EOL> is_nested :: String -> Bool <EOL> is_nested string = is_nested' string 0 [] [] <EOL>   where <EOL>     is_nested' :: String -> Int -> [Int] -> [Int] -> Bool <EOL>     is_nested' ('[' : cs) index opening_bracket_index closing_bracket_index = is_nested' cs (index + 1) (opening_bracket_index ++ [index]) closing_bracket_index <EOL>     is_nested' (']' : cs) index opening_bracket_index closing_bracket_index =", "gt": "is_nested' cs (index + 1) opening_bracket_index ([index] ++ closing_bracket_index)", "prediction": " False"}
{"input": "<s> -- Create a function that takes a string as input which contains only square brackets. <EOL> -- The function should return True if and only if there is a valid subsequence of brackets <EOL> -- where at least one bracket in the subsequence is nested. <EOL> -- <EOL> -- >>> is_nested \"[[]]\" <EOL> -- True <EOL> -- >>> is_nested \"[]]]]]]][[[[[]\" <EOL> -- False <EOL> -- >>> is_nested \"[][]\" <EOL> -- False <EOL> -- >>> is_nested \"[]\" <EOL> -- False <EOL> -- >>> is_nested \"[[][]]\" <EOL> -- True <EOL> -- >>> is_nested \"[[]][[\" <EOL> -- True <EOL> is_nested :: String -> Bool <EOL> is_nested string = is_nested' string 0 [] [] <EOL>   where <EOL>     is_nested' :: String -> Int -> [Int] -> [Int] -> Bool <EOL>     is_nested' ('[' : cs) index opening_bracket_index closing_bracket_index = is_nested' cs (index + 1) (opening_bracket_index ++ [index]) closing_bracket_index <EOL>     is_nested' (']' : cs) index opening_bracket_index closing_bracket_index = is_nested' cs (index + 1) opening_bracket_index ([index] ++ closing_bracket_index) <EOL>     is_nested' \"\" index opening_bracket_index closing_bracket_index <EOL>       | index < 3 = False <EOL>       | otherwise = is_nested'' opening_bracket_index closing_bracket_index 0 (length closing_bracket_index) <EOL>       where <EOL>         is_nested'' :: [Int] -> [Int] -> Int -> Int -> Bool <EOL>         is_nested'' _ [] cnt l = cnt >= 2 <EOL>         is_nested'' [] _ cnt l =", "gt": "cnt >= 2", "prediction": " cnt >= 3"}
{"input": "<s> -- Create a function that takes a string as input which contains only square brackets. <EOL> -- The function should return True if and only if there is a valid subsequence of brackets <EOL> -- where at least one bracket in the subsequence is nested. <EOL> -- <EOL> -- >>> is_nested \"[[]]\" <EOL> -- True <EOL> -- >>> is_nested \"[]]]]]]][[[[[]\" <EOL> -- False <EOL> -- >>> is_nested \"[][]\" <EOL> -- False <EOL> -- >>> is_nested \"[]\" <EOL> -- False <EOL> -- >>> is_nested \"[[][]]\" <EOL> -- True <EOL> -- >>> is_nested \"[[]][[\" <EOL> -- True <EOL> is_nested :: String -> Bool <EOL> is_nested string = is_nested' string 0 [] [] <EOL>   where <EOL>     is_nested' :: String -> Int -> [Int] -> [Int] -> Bool <EOL>     is_nested' ('[' : cs) index opening_bracket_index closing_bracket_index = is_nested' cs (index + 1) (opening_bracket_index", "gt": "++ [index]) closing_bracket_index", "prediction": " + 1) closing_bracket_index"}
{"input": "<s> -- Create a function that takes a string as input which contains only square brackets. <EOL> -- The function should return True if and only if there is a valid subsequence of brackets <EOL> -- where at least one bracket in the subsequence is nested. <EOL> -- <EOL> -- >>> is_nested \"[[]]\" <EOL> -- True <EOL> -- >>> is_nested \"[]]]]]]][[[[[]\" <EOL> -- False <EOL> -- >>> is_nested \"[][]\" <EOL> -- False <EOL> -- >>> is_nested \"[]\" <EOL> -- False <EOL> -- >>> is_nested \"[[][]]\" <EOL> -- True <EOL> -- >>> is_nested \"[[]][[\" <EOL> -- True <EOL> is_nested :: String -> Bool <EOL> is_nested string = is_nested' string 0 [] [] <EOL>   where <EOL>     is_nested' :: String -> Int -> [Int] -> [Int] -> Bool <EOL>     is_nested' ('[' : cs) index opening_bracket_index closing_bracket_index = is_nested' cs (index + 1) (opening_bracket_index ++ [index]) closing_bracket_index <EOL>     is_nested' (']' : cs) index opening_bracket_index closing_bracket_index = is_nested' cs (index + 1) opening_bracket_index ([index]", "gt": "++ closing_bracket_index)", "prediction": " ++ [index]) closing_bracket_index"}
{"input": "<s> -- Given the lengths of the three sides of a triangle. Return True if the three <EOL> -- sides form a right-angled triangle, False otherwise. <EOL> -- A right-angled triangle is a triangle in which one angle is right angle or <EOL> -- 90 degree. <EOL> -- Example: <EOL> -- >>> right_angle_triangle 3 4 5 <EOL> -- True <EOL> -- >>> right_angle_triangle 1 2 3 <EOL> -- False <EOL> right_angle_triangle :: Int -> Int -> Int -> Bool <EOL> right_angle_triangle a b c = a * a == b * b + c * c ||", "gt": "b * b == a * a + c * c || c * c == a * a + b * b", "prediction": " c"}
{"input": "<s> -- Given the lengths of the three sides of a triangle. Return True if the three <EOL> -- sides form a right-angled triangle, False otherwise. <EOL> -- A right-angled triangle is a triangle in which one angle is right angle or <EOL> -- 90 degree. <EOL> -- Example: <EOL> -- >>> right_angle_triangle 3 4 5 <EOL> -- True <EOL> -- >>> right_angle_triangle 1 2 3 <EOL> -- False <EOL> right_angle_triangle :: Int -> Int -> Int -> Bool <EOL> right_angle_triangle a b c =", "gt": "a * a == b * b + c * c || b * b == a * a + c * c || c * c == a * a + b * b", "prediction": " ("}
{"input": "<s> -- Given the lengths of the three sides of a triangle. Return True if the three <EOL> -- sides form a right-angled triangle, False otherwise. <EOL> -- A right-angled triangle is a triangle in which one angle is right angle or <EOL> -- 90 degree. <EOL> -- Example: <EOL> -- >>> right_angle_triangle 3 4 5 <EOL> -- True <EOL> -- >>> right_angle_triangle 1 2 3 <EOL> -- False <EOL> right_angle_triangle :: Int -> Int -> Int -> Bool <EOL> right_angle_triangle a b c = a * a == b * b + c * c || b * b == a * a + c * c ||", "gt": "c * c == a * a + b * b", "prediction": " a"}
{"input": "<s> -- Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in <EOL> -- the last couple centuries. However, what people don't know is Tribonacci sequence. <EOL> -- Tribonacci sequence is defined by the recurrence: <EOL> -- tri 1 = 3 <EOL> -- tri n = 1 + n / 2, if n is even. <EOL> -- tri n =  tri (n - 1) + tri (n - 2) + tri (n + 1), if n is odd. <EOL> -- For example: <EOL> -- tri 2 = 1 + (2 / 2) = 2 <EOL> -- tri 4 = 3 <EOL> -- tri 3 = tri 2 + tri 1 + tri 4 <EOL> --       = 2 + 3 + 3 = 8 <EOL> -- You are given a non-negative integer number n, you have to a return a list of the <EOL> -- first n + 1 numbers of the Tribonacci sequence. <EOL> -- Examples: <EOL> -- tri 3 = [1, 3, 2, 8] <EOL> tri :: Int -> [Int] <EOL> tri n =", "gt": "map tri' [0..n]", "prediction": " ["}
{"input": "<s> -- Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in <EOL> -- the last couple centuries. However, what people don't know is Tribonacci sequence. <EOL> -- Tribonacci sequence is defined by the recurrence: <EOL> -- tri 1 = 3 <EOL> -- tri n = 1 + n / 2, if n is even. <EOL> -- tri n =  tri (n - 1) + tri (n - 2) + tri (n + 1), if n is odd. <EOL> -- For example: <EOL> -- tri 2 = 1 + (2 / 2) = 2 <EOL> -- tri 4 = 3 <EOL> -- tri 3 = tri 2 + tri 1 + tri 4 <EOL> --       = 2 + 3 + 3 = 8 <EOL> -- You are given a non-negative integer number n, you have to a return a list of the <EOL> -- first n + 1 numbers of the Tribonacci sequence. <EOL> -- Examples: <EOL> -- tri 3 = [1, 3, 2, 8] <EOL> tri :: Int -> [Int] <EOL> tri n = map tri' [0..n] <EOL>     where <EOL>         tri' :: Int -> Int <EOL>         tri' 0 = 1 <EOL>         tri' 1 = 3 <EOL>         tri' n <EOL>             | even n = 1 + n `div` 2 <EOL>             | otherwise = tri' (n - 1) +", "gt": "tri' (n - 2) + tri' (n + 1)", "prediction": " tri' (n - 2)"}
{"input": "<s> -- Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in <EOL> -- the last couple centuries. However, what people don't know is Tribonacci sequence. <EOL> -- Tribonacci sequence is defined by the recurrence: <EOL> -- tri 1 = 3 <EOL> -- tri n = 1 + n / 2, if n is even. <EOL> -- tri n =  tri (n - 1) + tri (n - 2) + tri (n + 1), if n is odd. <EOL> -- For example: <EOL> -- tri 2 = 1 + (2 / 2) = 2 <EOL> -- tri 4 = 3 <EOL> -- tri 3 = tri 2 + tri 1 + tri 4 <EOL> --       = 2 + 3 + 3 = 8 <EOL> -- You are given a non-negative integer number n, you have to a return a list of the <EOL> -- first n + 1 numbers of the Tribonacci sequence. <EOL> -- Examples: <EOL> -- tri 3 = [1, 3, 2, 8] <EOL> tri :: Int -> [Int] <EOL> tri n = map tri' [0..n] <EOL>     where <EOL>         tri' :: Int -> Int <EOL>         tri' 0 = 1 <EOL>         tri' 1 = 3 <EOL>         tri' n <EOL>             | even n =", "gt": "1 + n `div` 2", "prediction": " tri' (n - 1)"}
{"input": "<s> -- Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in <EOL> -- the last couple centuries. However, what people don't know is Tribonacci sequence. <EOL> -- Tribonacci sequence is defined by the recurrence: <EOL> -- tri 1 = 3 <EOL> -- tri n = 1 + n / 2, if n is even. <EOL> -- tri n =  tri (n - 1) + tri (n - 2) + tri (n + 1), if n is odd. <EOL> -- For example: <EOL> -- tri 2 = 1 + (2 / 2) = 2 <EOL> -- tri 4 = 3 <EOL> -- tri 3 = tri 2 + tri 1 + tri 4 <EOL> --       = 2 + 3 + 3 = 8 <EOL> -- You are given a non-negative integer number n, you have to a return a list of the <EOL> -- first n + 1 numbers of the Tribonacci sequence. <EOL> -- Examples: <EOL> -- tri 3 = [1, 3, 2, 8] <EOL> tri :: Int -> [Int] <EOL> tri n = map tri' [0..n] <EOL>     where <EOL>         tri' :: Int -> Int <EOL>         tri' 0 = 1 <EOL>         tri' 1 =", "gt": "3", "prediction": " 1"}
{"input": "<s> -- Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in <EOL> -- the last couple centuries. However, what people don't know is Tribonacci sequence. <EOL> -- Tribonacci sequence is defined by the recurrence: <EOL> -- tri 1 = 3 <EOL> -- tri n = 1 + n / 2, if n is even. <EOL> -- tri n =  tri (n - 1) + tri (n - 2) + tri (n + 1), if n is odd. <EOL> -- For example: <EOL> -- tri 2 = 1 + (2 / 2) = 2 <EOL> -- tri 4 = 3 <EOL> -- tri 3 = tri 2 + tri 1 + tri 4 <EOL> --       = 2 + 3 + 3 = 8 <EOL> -- You are given a non-negative integer number n, you have to a return a list of the <EOL> -- first n + 1 numbers of the Tribonacci sequence. <EOL> -- Examples: <EOL> -- tri 3 = [1, 3, 2, 8] <EOL> tri :: Int -> [Int] <EOL> tri n = map tri' [0..n] <EOL>     where <EOL>         tri' :: Int -> Int <EOL>         tri' 0 =", "gt": "1", "prediction": " 1"}
{"input": "<s> -- Write a function that accepts a list of strings. <EOL> -- The list contains different words. Return the word with maximum number <EOL> -- of unique characters. If multiple strings have maximum number of unique <EOL> -- characters, return the one which comes first in lexicographical order. <EOL> -- <EOL> -- >>> find_max [\"name\", \"of\", \"string\"] <EOL> -- \"string\" <EOL> -- >>> find_max [\"name\", \"enam\", \"game\"] <EOL> -- \"enam\" <EOL> -- >>> find_max [\"aaaaaaa\", \"bb\" ,\"cc\"] <EOL> -- \"aaaaaaa\" <EOL> import Data.List (nub, sort) <EOL> find_max :: [String] -> String <EOL> find_max words <EOL>   | words == [] = \"\" <EOL>   | otherwise = head $ filter (\\x -> (length . nub) x == maximum (map", "gt": "(length . nub) words)) $ sort words", "prediction": " lengthlength . nub) words))"}
{"input": "<s> -- Write a function that accepts a list of strings. <EOL> -- The list contains different words. Return the word with maximum number <EOL> -- of unique characters. If multiple strings have maximum number of unique <EOL> -- characters, return the one which comes first in lexicographical order. <EOL> -- <EOL> -- >>> find_max [\"name\", \"of\", \"string\"] <EOL> -- \"string\" <EOL> -- >>> find_max [\"name\", \"enam\", \"game\"] <EOL> -- \"enam\" <EOL> -- >>> find_max [\"aaaaaaa\", \"bb\" ,\"cc\"] <EOL> -- \"aaaaaaa\" <EOL> import Data.List (nub, sort) <EOL> find_max :: [String] -> String <EOL> find_max words <EOL>   | words == [] = \"\" <EOL>   | otherwise = head $ filter (\\x -> (length . nub) x == maximum (map (length . nub) words)) $", "gt": "sort words", "prediction": " sort"}
{"input": "<s> -- Write a function that accepts a list of strings. <EOL> -- The list contains different words. Return the word with maximum number <EOL> -- of unique characters. If multiple strings have maximum number of unique <EOL> -- characters, return the one which comes first in lexicographical order. <EOL> -- <EOL> -- >>> find_max [\"name\", \"of\", \"string\"] <EOL> -- \"string\" <EOL> -- >>> find_max [\"name\", \"enam\", \"game\"] <EOL> -- \"enam\" <EOL> -- >>> find_max [\"aaaaaaa\", \"bb\" ,\"cc\"] <EOL> -- \"aaaaaaa\" <EOL> import Data.List (nub, sort) <EOL> find_max :: [String] -> String <EOL> find_max words <EOL>   | words == [] = \"\" <EOL>   | otherwise = head $ filter (\\x ->", "gt": "(length . nub) x == maximum (map (length . nub) words)) $ sort words", "prediction": " length x > 0) (sort words)"}
{"input": "<s> -- Write a function that accepts a list of strings. <EOL> -- The list contains different words. Return the word with maximum number <EOL> -- of unique characters. If multiple strings have maximum number of unique <EOL> -- characters, return the one which comes first in lexicographical order. <EOL> -- <EOL> -- >>> find_max [\"name\", \"of\", \"string\"] <EOL> -- \"string\" <EOL> -- >>> find_max [\"name\", \"enam\", \"game\"] <EOL> -- \"enam\" <EOL> -- >>> find_max [\"aaaaaaa\", \"bb\" ,\"cc\"] <EOL> -- \"aaaaaaa\" <EOL> import Data.List (nub, sort) <EOL> find_max :: [String] -> String <EOL> find_max words <EOL>   | words == [] =", "gt": "\"\"", "prediction": " []"}
{"input": "<s> -- Write a function that accepts a list of strings. <EOL> -- The list contains different words. Return the word with maximum number <EOL> -- of unique characters. If multiple strings have maximum number of unique <EOL> -- characters, return the one which comes first in lexicographical order. <EOL> -- <EOL> -- >>> find_max [\"name\", \"of\", \"string\"] <EOL> -- \"string\" <EOL> -- >>> find_max [\"name\", \"enam\", \"game\"] <EOL> -- \"enam\" <EOL> -- >>> find_max [\"aaaaaaa\", \"bb\" ,\"cc\"] <EOL> -- \"aaaaaaa\" <EOL> import Data.List (nub, sort) <EOL> find_max :: [String] -> String <EOL> find_max words <EOL>   | words == [] = \"\" <EOL>   | otherwise =", "gt": "head $ filter (\\x -> (length . nub) x == maximum (map (length . nub) words)) $ sort words", "prediction": " head"}
{"input": "<s> -- returns encoded string by cycling groups of three characters. <EOL> encode_cyclic :: String -> String <EOL> encode_cyclic = concatMap (\\x ->", "gt": "if length x == 3 then tail x ++ [head x] else x) . chunksOf 3", "prediction": " map x ++ \"\\n\")"}
{"input": "<s> -- returns encoded string by cycling groups of three characters. <EOL> encode_cyclic :: String -> String <EOL> encode_cyclic = concatMap (\\x -> if length x == 3 then tail x ++ [head x] else x) . chunksOf 3 <EOL>   where <EOL>     chunksOf :: Int -> [a] -> [[a]] <EOL>     chunksOf _ [] = [] <EOL>     chunksOf n xs = take n xs :", "gt": "chunksOf n (drop n xs)", "prediction": " (map encode_cycle (drop n xs))"}
{"input": "<s> -- returns encoded string by cycling groups of three characters. <EOL> encode_cyclic :: String -> String <EOL> encode_cyclic = concatMap (\\x -> if length x == 3 then tail x ++ [head x] else x) . chunksOf 3 <EOL>   where <EOL>     chunksOf :: Int -> [a] -> [[a]] <EOL>     chunksOf _ [] = [] <EOL>     chunksOf n xs =", "gt": "take n xs : chunksOf n (drop n xs)", "prediction": " let"}
{"input": "<s> -- returns encoded string by cycling groups of three characters. <EOL> encode_cyclic :: String -> String <EOL> encode_cyclic = concatMap (\\x -> if length x == 3 then tail x ++ [head x] else", "gt": "x) . chunksOf 3", "prediction": " [head x])"}
{"input": "<s> -- returns encoded string by cycling groups of three characters. <EOL> encode_cyclic :: String -> String <EOL> encode_cyclic = concatMap (\\x -> if length x == 3 then tail x ++ [head x] else x) . chunksOf 3 <EOL>   where <EOL>     chunksOf :: Int -> [a] -> [[a]] <EOL>     chunksOf _ [] = [] <EOL>     chunksOf n xs = take n xs : chunksOf n (drop n xs) <EOL> -- takes as input string encoded with encode_cyclic function. Returns decoded string. <EOL> decode_cyclic :: String -> String <EOL> decode_cyclic = encode_cyclic .", "gt": "encode_cyclic", "prediction": " map"}
{"input": "<s> -- Given an array arr of integers, find the minimum number of elements that <EOL> -- need to be changed to make the array palindromic. A palindromic array is an array that <EOL> -- is read the same backwards and forwards. In one change, you can change one element to any other element. <EOL> -- <EOL> -- For example: <EOL> -- smallest_change [1,2,3,5,4,7,9,6] == 4 <EOL> -- smallest_change [1, 2, 3, 4, 3, 2, 2] == 1 <EOL> -- smallest_change [1, 2, 3, 2, 1] == 0 <EOL> smallest_change :: [Int] -> Int <EOL> smallest_change arr =", "gt": "length [i | i <- [0..(length arr `div` 2 - 1)], arr !! i /= arr !! (length arr - i - 1)]", "prediction": " maximum"}
{"input": "<s> -- Given an array arr of integers, find the minimum number of elements that <EOL> -- need to be changed to make the array palindromic. A palindromic array is an array that <EOL> -- is read the same backwards and forwards. In one change, you can change one element to any other element. <EOL> -- <EOL> -- For example: <EOL> -- smallest_change [1,2,3,5,4,7,9,6] == 4 <EOL> -- smallest_change [1, 2, 3, 4, 3, 2, 2] == 1 <EOL> -- smallest_change [1, 2, 3, 2, 1] == 0 <EOL> smallest_change :: [Int] -> Int <EOL> smallest_change arr = length [i | i <- [0..(length arr `div` 2 - 1)], arr !! i /= arr !!", "gt": "(length arr - i - 1)]", "prediction": " i]"}
{"input": "<s> -- pairs_sum_to_zero takes a list of integers as an input. <EOL> -- it returns True if there are two distinct elements in the list that <EOL> -- sum to zero, and False otherwise. <EOL> -- >>> pairs_sum_to_zero [1,3,5,0] <EOL> -- False <EOL> -- >>> pairs_sum_to_zero [1,3,-2,1] <EOL> -- False <EOL> -- >>> pairs_sum_to_zero [1,2,3,7] <EOL> -- False <EOL> -- >>> pairs_sum_to_zero [2,4,-5,3,5,7] <EOL> -- True <EOL> -- >>> pairs_sum_to_zero [1] <EOL> -- False <EOL> pairs_sum_to_zero :: [Int] -> Bool <EOL> pairs_sum_to_zero xs = any (\\(a, b) ->", "gt": "a + b == 0) $ pairs xs", "prediction": " a == b) xs"}
{"input": "<s> -- pairs_sum_to_zero takes a list of integers as an input. <EOL> -- it returns True if there are two distinct elements in the list that <EOL> -- sum to zero, and False otherwise. <EOL> -- >>> pairs_sum_to_zero [1,3,5,0] <EOL> -- False <EOL> -- >>> pairs_sum_to_zero [1,3,-2,1] <EOL> -- False <EOL> -- >>> pairs_sum_to_zero [1,2,3,7] <EOL> -- False <EOL> -- >>> pairs_sum_to_zero [2,4,-5,3,5,7] <EOL> -- True <EOL> -- >>> pairs_sum_to_zero [1] <EOL> -- False <EOL> pairs_sum_to_zero :: [Int] -> Bool <EOL> pairs_sum_to_zero xs = any (\\(a, b) -> a + b == 0) $ pairs xs <EOL>   where <EOL>     pairs [] =", "gt": "[]", "prediction": " []"}
{"input": "<s> -- pairs_sum_to_zero takes a list of integers as an input. <EOL> -- it returns True if there are two distinct elements in the list that <EOL> -- sum to zero, and False otherwise. <EOL> -- >>> pairs_sum_to_zero [1,3,5,0] <EOL> -- False <EOL> -- >>> pairs_sum_to_zero [1,3,-2,1] <EOL> -- False <EOL> -- >>> pairs_sum_to_zero [1,2,3,7] <EOL> -- False <EOL> -- >>> pairs_sum_to_zero [2,4,-5,3,5,7] <EOL> -- True <EOL> -- >>> pairs_sum_to_zero [1] <EOL> -- False <EOL> pairs_sum_to_zero :: [Int] -> Bool <EOL> pairs_sum_to_zero xs =", "gt": "any (\\(a, b) -> a + b == 0) $ pairs xs", "prediction": " sum"}
{"input": "<s> -- pairs_sum_to_zero takes a list of integers as an input. <EOL> -- it returns True if there are two distinct elements in the list that <EOL> -- sum to zero, and False otherwise. <EOL> -- >>> pairs_sum_to_zero [1,3,5,0] <EOL> -- False <EOL> -- >>> pairs_sum_to_zero [1,3,-2,1] <EOL> -- False <EOL> -- >>> pairs_sum_to_zero [1,2,3,7] <EOL> -- False <EOL> -- >>> pairs_sum_to_zero [2,4,-5,3,5,7] <EOL> -- True <EOL> -- >>> pairs_sum_to_zero [1] <EOL> -- False <EOL> pairs_sum_to_zero :: [Int] -> Bool <EOL> pairs_sum_to_zero xs = any (\\(a, b) -> a + b == 0) $ pairs xs <EOL>   where <EOL>     pairs [] = [] <EOL>     pairs (x:xs) =", "gt": "[(x, y) | y <- xs] ++ pairs xs", "prediction": " x"}
{"input": "<s> -- pairs_sum_to_zero takes a list of integers as an input. <EOL> -- it returns True if there are two distinct elements in the list that <EOL> -- sum to zero, and False otherwise. <EOL> -- >>> pairs_sum_to_zero [1,3,5,0] <EOL> -- False <EOL> -- >>> pairs_sum_to_zero [1,3,-2,1] <EOL> -- False <EOL> -- >>> pairs_sum_to_zero [1,2,3,7] <EOL> -- False <EOL> -- >>> pairs_sum_to_zero [2,4,-5,3,5,7] <EOL> -- True <EOL> -- >>> pairs_sum_to_zero [1] <EOL> -- False <EOL> pairs_sum_to_zero :: [Int] -> Bool <EOL> pairs_sum_to_zero xs = any (\\(a, b) -> a + b == 0) $", "gt": "pairs xs", "prediction": " zip xs [0..]"}
{"input": "<s> -- Implement a function that takes an non-negative integer and returns an array of the first n <EOL> -- integers that are prime numbers and less than n. <EOL> -- for example: <EOL> -- count_up_to 5 => [2,3] <EOL> -- count_up_to 11 => [2,3,5,7] <EOL> -- count_up_to 0 => [] <EOL> -- count_up_to 20 => [2,3,5,7,11,13,17,19] <EOL> -- count_up_to 1 => [] <EOL> -- count_up_to 18 => [2,3,5,7,11,13,17] <EOL> count_up_to :: Int -> [Int] <EOL> count_up_to n = <EOL>   [ i <EOL>     | i <- [2 .. (n - 1)], <EOL>       is_prime i <EOL>   ] <EOL>   where <EOL>     is_prime n = <EOL>       null <EOL>         [ i <EOL>           | i <-", "gt": "[2 .. (n - 1)],", "prediction": " [1 .. n],"}
{"input": "<s> -- Implement a function that takes an non-negative integer and returns an array of the first n <EOL> -- integers that are prime numbers and less than n. <EOL> -- for example: <EOL> -- count_up_to 5 => [2,3] <EOL> -- count_up_to 11 => [2,3,5,7] <EOL> -- count_up_to 0 => [] <EOL> -- count_up_to 20 => [2,3,5,7,11,13,17,19] <EOL> -- count_up_to 1 => [] <EOL> -- count_up_to 18 => [2,3,5,7,11,13,17] <EOL> count_up_to :: Int -> [Int] <EOL> count_up_to n = <EOL>   [ i <EOL>     | i <- [2 .. (n - 1)], <EOL>       is_prime i <EOL>   ] <EOL>   where <EOL>     is_prime n = <EOL>       null <EOL>         [ i <EOL>           | i <- [2 ..", "gt": "(n - 1)],", "prediction": " ( - 1],"}
{"input": "<s> -- Implement a function that takes an non-negative integer and returns an array of the first n <EOL> -- integers that are prime numbers and less than n. <EOL> -- for example: <EOL> -- count_up_to 5 => [2,3] <EOL> -- count_up_to 11 => [2,3,5,7] <EOL> -- count_up_to 0 => [] <EOL> -- count_up_to 20 => [2,3,5,7,11,13,17,19] <EOL> -- count_up_to 1 => [] <EOL> -- count_up_to 18 => [2,3,5,7,11,13,17] <EOL> count_up_to :: Int -> [Int] <EOL> count_up_to n = <EOL>   [ i <EOL>     | i <-", "gt": "[2 .. (n - 1)],", "prediction": " [1..n]"}
{"input": "<s> -- Implement a function that takes an non-negative integer and returns an array of the first n <EOL> -- integers that are prime numbers and less than n. <EOL> -- for example: <EOL> -- count_up_to 5 => [2,3] <EOL> -- count_up_to 11 => [2,3,5,7] <EOL> -- count_up_to 0 => [] <EOL> -- count_up_to 20 => [2,3,5,7,11,13,17,19] <EOL> -- count_up_to 1 => [] <EOL> -- count_up_to 18 => [2,3,5,7,11,13,17] <EOL> count_up_to :: Int -> [Int] <EOL> count_up_to n = <EOL>   [ i <EOL>     | i <- [2 .. (n - 1)], <EOL>       is_prime i <EOL>   ] <EOL>   where <EOL>     is_prime n = <EOL>       null <EOL>         [ i <EOL>           | i <- [2 .. (n - 1)], <EOL>             n `mod`", "gt": "i == 0", "prediction": " n == 0"}
{"input": "<s> -- Implement a function that takes an non-negative integer and returns an array of the first n <EOL> -- integers that are prime numbers and less than n. <EOL> -- for example: <EOL> -- count_up_to 5 => [2,3] <EOL> -- count_up_to 11 => [2,3,5,7] <EOL> -- count_up_to 0 => [] <EOL> -- count_up_to 20 => [2,3,5,7,11,13,17,19] <EOL> -- count_up_to 1 => [] <EOL> -- count_up_to 18 => [2,3,5,7,11,13,17] <EOL> count_up_to :: Int -> [Int] <EOL> count_up_to n = <EOL>   [ i <EOL>     | i <- [2 .. (n - 1)], <EOL>       is_prime", "gt": "i", "prediction": " (i `mod` n)"}
{"input": "<s> -- There are eight planets in our solar system: the closest to the Sun <EOL> -- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, <EOL> -- Uranus, Neptune. <EOL> -- Write a function that takes two planet names as strings planet1 and planet2. <EOL> -- The function should return a tuple containing all planets whose orbits are <EOL> -- located between the orbit of planet1 and the orbit of planet2, sorted by <EOL> -- the proximity to the sun. <EOL> -- The function should return an empty tuple if planet1 or planet2 <EOL> -- are not correct planet names. <EOL> -- Examples <EOL> -- >>> bf \"Jupiter\" \"Neptune\" <EOL> -- [\"Saturn\", \"Uranus\"] <EOL> -- >>> bf \"Earth\" \"Mercury\" <EOL> -- [\"Venus\"] <EOL> -- >>> bf \"Mercury\" \"Uranus\" <EOL> -- [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"] <EOL> bf :: String -> String -> [String] <EOL> bf planet1 planet2 = <EOL>   if planet1 `elem` planet_names && planet2 `elem` planet_names && planet1 /= planet2 <EOL>     then <EOL>       if planet1_index < planet2_index <EOL>         then take (planet2_index - planet1_index - 1) (drop (planet1_index + 1) planet_names) <EOL>         else take (planet1_index - planet2_index - 1) (drop (planet2_index + 1) planet_names) <EOL>     else [] <EOL>   where <EOL>     planet_names :: [String] <EOL>     planet_names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"] <EOL>     planet1_index :: Int <EOL>     planet1_index = head [i | (i, x) <- zip [0 ..] planet_names, x == planet1] <EOL>     planet2_index :: Int <EOL>     planet2_index = head [i | (i, x) <-", "gt": "zip [0 ..] planet_names, x == planet2]", "prediction": " zip [0 ..] planet_names, x == planet2]"}
{"input": "<s> -- There are eight planets in our solar system: the closest to the Sun <EOL> -- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, <EOL> -- Uranus, Neptune. <EOL> -- Write a function that takes two planet names as strings planet1 and planet2. <EOL> -- The function should return a tuple containing all planets whose orbits are <EOL> -- located between the orbit of planet1 and the orbit of planet2, sorted by <EOL> -- the proximity to the sun. <EOL> -- The function should return an empty tuple if planet1 or planet2 <EOL> -- are not correct planet names. <EOL> -- Examples <EOL> -- >>> bf \"Jupiter\" \"Neptune\" <EOL> -- [\"Saturn\", \"Uranus\"] <EOL> -- >>> bf \"Earth\" \"Mercury\" <EOL> -- [\"Venus\"] <EOL> -- >>> bf \"Mercury\" \"Uranus\" <EOL> -- [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"] <EOL> bf :: String -> String -> [String] <EOL> bf planet1 planet2 = <EOL>   if planet1 `elem` planet_names && planet2 `elem` planet_names && planet1 /= planet2 <EOL>     then <EOL>       if planet1_index < planet2_index <EOL>         then", "gt": "take (planet2_index - planet1_index - 1) (drop (planet1_index + 1) planet_names)", "prediction": " ["}
{"input": "<s> -- There are eight planets in our solar system: the closest to the Sun <EOL> -- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, <EOL> -- Uranus, Neptune. <EOL> -- Write a function that takes two planet names as strings planet1 and planet2. <EOL> -- The function should return a tuple containing all planets whose orbits are <EOL> -- located between the orbit of planet1 and the orbit of planet2, sorted by <EOL> -- the proximity to the sun. <EOL> -- The function should return an empty tuple if planet1 or planet2 <EOL> -- are not correct planet names. <EOL> -- Examples <EOL> -- >>> bf \"Jupiter\" \"Neptune\" <EOL> -- [\"Saturn\", \"Uranus\"] <EOL> -- >>> bf \"Earth\" \"Mercury\" <EOL> -- [\"Venus\"] <EOL> -- >>> bf \"Mercury\" \"Uranus\" <EOL> -- [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"] <EOL> bf :: String -> String -> [String] <EOL> bf planet1 planet2 = <EOL>   if planet1 `elem` planet_names && planet2 `elem` planet_names &&", "gt": "planet1 /= planet2", "prediction": " plan"}
{"input": "<s> -- There are eight planets in our solar system: the closest to the Sun <EOL> -- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, <EOL> -- Uranus, Neptune. <EOL> -- Write a function that takes two planet names as strings planet1 and planet2. <EOL> -- The function should return a tuple containing all planets whose orbits are <EOL> -- located between the orbit of planet1 and the orbit of planet2, sorted by <EOL> -- the proximity to the sun. <EOL> -- The function should return an empty tuple if planet1 or planet2 <EOL> -- are not correct planet names. <EOL> -- Examples <EOL> -- >>> bf \"Jupiter\" \"Neptune\" <EOL> -- [\"Saturn\", \"Uranus\"] <EOL> -- >>> bf \"Earth\" \"Mercury\" <EOL> -- [\"Venus\"] <EOL> -- >>> bf \"Mercury\" \"Uranus\" <EOL> -- [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"] <EOL> bf :: String -> String -> [String] <EOL> bf planet1 planet2 = <EOL>   if planet1 `elem` planet_names && planet2 `elem` planet_names && planet1 /= planet2 <EOL>     then <EOL>       if planet1_index < planet2_index <EOL>         then take (planet2_index - planet1_index - 1) (drop (planet1_index + 1) planet_names) <EOL>         else take (planet1_index - planet2_index - 1) (drop (planet2_index + 1) planet_names) <EOL>     else [] <EOL>   where <EOL>     planet_names :: [String] <EOL>     planet_names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"] <EOL>     planet1_index :: Int <EOL>     planet1_index =", "gt": "head [i | (i, x) <- zip [0 ..] planet_names, x == planet1]", "prediction": " 0"}
{"input": "<s> -- There are eight planets in our solar system: the closest to the Sun <EOL> -- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, <EOL> -- Uranus, Neptune. <EOL> -- Write a function that takes two planet names as strings planet1 and planet2. <EOL> -- The function should return a tuple containing all planets whose orbits are <EOL> -- located between the orbit of planet1 and the orbit of planet2, sorted by <EOL> -- the proximity to the sun. <EOL> -- The function should return an empty tuple if planet1 or planet2 <EOL> -- are not correct planet names. <EOL> -- Examples <EOL> -- >>> bf \"Jupiter\" \"Neptune\" <EOL> -- [\"Saturn\", \"Uranus\"] <EOL> -- >>> bf \"Earth\" \"Mercury\" <EOL> -- [\"Venus\"] <EOL> -- >>> bf \"Mercury\" \"Uranus\" <EOL> -- [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"] <EOL> bf :: String -> String -> [String] <EOL> bf planet1 planet2 = <EOL>   if planet1 `elem` planet_names && planet2 `elem` planet_names && planet1 /= planet2 <EOL>     then <EOL>       if planet1_index < planet2_index <EOL>         then take (planet2_index - planet1_index - 1) (drop (planet1_index + 1) planet_names) <EOL>         else take (planet1_index - planet2_index - 1) (drop (planet2_index + 1) planet_names) <EOL>     else [] <EOL>   where <EOL>     planet_names :: [String] <EOL>     planet_names =", "gt": "[\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]", "prediction": " map"}
{"input": "<s> -- Return length of given string <EOL> strlen :: String -> Int <EOL> strlen string =", "gt": "length string", "prediction": " length"}
{"input": "<s> -- Return length of given string <EOL> strlen :: String -> Int <EOL> strlen string = length", "gt": "string", "prediction": " $"}
{"input": "<s> -- Return maximum element in the list. <EOL> -- >>> max_element [1,2,3] <EOL> -- 3 <EOL> -- >>> max_element [5,3,-5,2,-3,3,9,0,123,1,-10] <EOL> -- 123 <EOL> max_element :: [Int] -> Int <EOL> max_element =", "gt": "maximum", "prediction": " foldr max 0"}
{"input": "<s> -- Write a function that takes an integer a and returns True <EOL> -- if this ingeger is a cube of some integer number. <EOL> -- Note: you may assume the input is always valid. <EOL> -- Examples: <EOL> -- iscube 1 ==> True <EOL> -- iscube 2 ==> False <EOL> -- iscube (-1) ==> True <EOL> -- iscube 64 ==> True <EOL> -- iscube 0 ==> True <EOL> -- iscube 180 ==> False <EOL> iscube :: Int -> Bool <EOL> iscube a = let b =", "gt": "abs a", "prediction": " a * a"}
{"input": "<s> -- Write a function that takes an integer a and returns True <EOL> -- if this ingeger is a cube of some integer number. <EOL> -- Note: you may assume the input is always valid. <EOL> -- Examples: <EOL> -- iscube 1 ==> True <EOL> -- iscube 2 ==> False <EOL> -- iscube (-1) ==> True <EOL> -- iscube 64 ==> True <EOL> -- iscube 0 ==> True <EOL> -- iscube 180 ==> False <EOL> iscube :: Int -> Bool <EOL> iscube a = let b = abs a <EOL>            in round", "gt": "(fromIntegral b ** (1.0 / 3.0)) ^ 3 == b", "prediction": " (b * b) == a"}
{"input": "<s> import Data.List <EOL> -- Given an array representing a branch of a tree that has non-negative integer nodes <EOL> -- your task is to pluck one of the nodes and return it. <EOL> -- The plucked node should be the node with the smallest even value. <EOL> -- If multiple nodes with the same smallest even value are found return the node that has smallest index. <EOL> -- <EOL> -- The plucked node should be returned in a list, [ smalest_value, its index ], <EOL> -- If there are no even values or the given array is empty, return []. <EOL> -- <EOL> -- Example 1: <EOL> --     Input: [4,2,3] <EOL> --     Output: [2, 1] <EOL> --     Explanation: 2 has the smallest even value, and 2 has the smallest index. <EOL> -- <EOL> -- Example 2: <EOL> --     Input: [1,2,3] <EOL> --     Output: [2, 1] <EOL> --     Explanation: 2 has the smallest even value, and 2 has the smallest index. <EOL> -- <EOL> -- Example 3: <EOL> --     Input: [] <EOL> --     Output: [] <EOL> -- <EOL> -- Example 4: <EOL> --     Input: [5, 0, 3, 0, 4, 2] <EOL> --     Output: [0, 1] <EOL> --     Explanation: 0 is the smallest value, but  there are two zeros, <EOL> --                  so we will choose the first zero, which has the smallest index. <EOL> -- <EOL> -- Constraints: <EOL> --     * 1 <= nodes.length <= 10000 <EOL> --     * 0 <= node.value <EOL> pluck :: [Int] -> [Int] <EOL> pluck arr = if length arr == 0 then []", "gt": "else [minimum evens, head (elemIndices (minimum evens) arr)]", "prediction": " else"}
{"input": "<s> import Data.List <EOL> -- Given an array representing a branch of a tree that has non-negative integer nodes <EOL> -- your task is to pluck one of the nodes and return it. <EOL> -- The plucked node should be the node with the smallest even value. <EOL> -- If multiple nodes with the same smallest even value are found return the node that has smallest index. <EOL> -- <EOL> -- The plucked node should be returned in a list, [ smalest_value, its index ], <EOL> -- If there are no even values or the given array is empty, return []. <EOL> -- <EOL> -- Example 1: <EOL> --     Input: [4,2,3] <EOL> --     Output: [2, 1] <EOL> --     Explanation: 2 has the smallest even value, and 2 has the smallest index. <EOL> -- <EOL> -- Example 2: <EOL> --     Input: [1,2,3] <EOL> --     Output: [2, 1] <EOL> --     Explanation: 2 has the smallest even value, and 2 has the smallest index. <EOL> -- <EOL> -- Example 3: <EOL> --     Input: [] <EOL> --     Output: [] <EOL> -- <EOL> -- Example 4: <EOL> --     Input: [5, 0, 3, 0, 4, 2] <EOL> --     Output: [0, 1] <EOL> --     Explanation: 0 is the smallest value, but  there are two zeros, <EOL> --                  so we will choose the first zero, which has the smallest index. <EOL> -- <EOL> -- Constraints: <EOL> --     * 1 <= nodes.length <= 10000 <EOL> --     * 0 <= node.value <EOL> pluck :: [Int] -> [Int] <EOL> pluck arr = if length arr == 0 then [] else [minimum evens, head (elemIndices (minimum evens) arr)] <EOL>     where  <EOL>         evens :: [Int] <EOL>         evens =", "gt": "filter even arr", "prediction": " ["}
{"input": "<s> import Data.List <EOL> -- Given an array representing a branch of a tree that has non-negative integer nodes <EOL> -- your task is to pluck one of the nodes and return it. <EOL> -- The plucked node should be the node with the smallest even value. <EOL> -- If multiple nodes with the same smallest even value are found return the node that has smallest index. <EOL> -- <EOL> -- The plucked node should be returned in a list, [ smalest_value, its index ], <EOL> -- If there are no even values or the given array is empty, return []. <EOL> -- <EOL> -- Example 1: <EOL> --     Input: [4,2,3] <EOL> --     Output: [2, 1] <EOL> --     Explanation: 2 has the smallest even value, and 2 has the smallest index. <EOL> -- <EOL> -- Example 2: <EOL> --     Input: [1,2,3] <EOL> --     Output: [2, 1] <EOL> --     Explanation: 2 has the smallest even value, and 2 has the smallest index. <EOL> -- <EOL> -- Example 3: <EOL> --     Input: [] <EOL> --     Output: [] <EOL> -- <EOL> -- Example 4: <EOL> --     Input: [5, 0, 3, 0, 4, 2] <EOL> --     Output: [0, 1] <EOL> --     Explanation: 0 is the smallest value, but  there are two zeros, <EOL> --                  so we will choose the first zero, which has the smallest index. <EOL> -- <EOL> -- Constraints: <EOL> --     * 1 <= nodes.length <= 10000 <EOL> --     * 0 <= node.value <EOL> pluck :: [Int] -> [Int] <EOL> pluck arr =", "gt": "if length arr == 0 then [] else [minimum evens, head (elemIndices (minimum evens) arr)]", "prediction": " undefined"}
{"input": "<s> -- You are given a rectangular grid of wells. Each row represents a single well, <EOL> -- and each 1 in a row represents a single unit of water. <EOL> -- Each well has a corresponding bucket that can be used to extract water from it,  <EOL> -- and all buckets have the same capacity. <EOL> -- Your task is to use the buckets to empty the wells. <EOL> -- Output the number of times you need to lower the buckets. <EOL> --  <EOL> -- Example 1: <EOL> --     Input:  <EOL> --         grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]] <EOL> --         bucket_capacity : 1 <EOL> --     Output: 6 <EOL> -- <EOL> -- Example 2: <EOL> --     Input:  <EOL> --         grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]] <EOL> --         bucket_capacity : 2 <EOL> --     Output: 5 <EOL> --  <EOL> -- Example 3: <EOL> --     Input:  <EOL> --         grid : [[0,0,0], [0,0,0]] <EOL> --         bucket_capacity : 5 <EOL> --     Output: 0 <EOL> --  <EOL> -- constraints: <EOL> --     * all wells have the same length <EOL> --     * 1 <= grid.length <= 10^2 <EOL> --     * 1 <= grid[:,1].length <= 10^2 <EOL> --     * grid[i][j] -> 0 | 1 <EOL> --     * 1 <= capacity <= 10 <EOL> max_fill :: [[Int]] -> Int -> Int <EOL> max_fill grid capacity = sum $ map (ceiling . (/ fromIntegral capacity) . fromIntegral . sum) $", "gt": "grid", "prediction": " grid"}
{"input": "<s> -- You are given a rectangular grid of wells. Each row represents a single well, <EOL> -- and each 1 in a row represents a single unit of water. <EOL> -- Each well has a corresponding bucket that can be used to extract water from it,  <EOL> -- and all buckets have the same capacity. <EOL> -- Your task is to use the buckets to empty the wells. <EOL> -- Output the number of times you need to lower the buckets. <EOL> --  <EOL> -- Example 1: <EOL> --     Input:  <EOL> --         grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]] <EOL> --         bucket_capacity : 1 <EOL> --     Output: 6 <EOL> -- <EOL> -- Example 2: <EOL> --     Input:  <EOL> --         grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]] <EOL> --         bucket_capacity : 2 <EOL> --     Output: 5 <EOL> --  <EOL> -- Example 3: <EOL> --     Input:  <EOL> --         grid : [[0,0,0], [0,0,0]] <EOL> --         bucket_capacity : 5 <EOL> --     Output: 0 <EOL> --  <EOL> -- constraints: <EOL> --     * all wells have the same length <EOL> --     * 1 <= grid.length <= 10^2 <EOL> --     * 1 <= grid[:,1].length <= 10^2 <EOL> --     * grid[i][j] -> 0 | 1 <EOL> --     * 1 <= capacity <= 10 <EOL> max_fill :: [[Int]] -> Int -> Int <EOL> max_fill grid capacity = sum $ map", "gt": "(ceiling . (/ fromIntegral capacity) . fromIntegral . sum) $ grid", "prediction": " (length . head) grid"}
{"input": "<s> -- You are given a rectangular grid of wells. Each row represents a single well, <EOL> -- and each 1 in a row represents a single unit of water. <EOL> -- Each well has a corresponding bucket that can be used to extract water from it,  <EOL> -- and all buckets have the same capacity. <EOL> -- Your task is to use the buckets to empty the wells. <EOL> -- Output the number of times you need to lower the buckets. <EOL> --  <EOL> -- Example 1: <EOL> --     Input:  <EOL> --         grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]] <EOL> --         bucket_capacity : 1 <EOL> --     Output: 6 <EOL> -- <EOL> -- Example 2: <EOL> --     Input:  <EOL> --         grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]] <EOL> --         bucket_capacity : 2 <EOL> --     Output: 5 <EOL> --  <EOL> -- Example 3: <EOL> --     Input:  <EOL> --         grid : [[0,0,0], [0,0,0]] <EOL> --         bucket_capacity : 5 <EOL> --     Output: 0 <EOL> --  <EOL> -- constraints: <EOL> --     * all wells have the same length <EOL> --     * 1 <= grid.length <= 10^2 <EOL> --     * 1 <= grid[:,1].length <= 10^2 <EOL> --     * grid[i][j] -> 0 | 1 <EOL> --     * 1 <= capacity <= 10 <EOL> max_fill :: [[Int]] -> Int -> Int <EOL> max_fill grid capacity = sum $ map (ceiling . (/ fromIntegral capacity) .", "gt": "fromIntegral . sum) $ grid", "prediction": " length) grid"}
{"input": "<s> -- You are given a rectangular grid of wells. Each row represents a single well, <EOL> -- and each 1 in a row represents a single unit of water. <EOL> -- Each well has a corresponding bucket that can be used to extract water from it,  <EOL> -- and all buckets have the same capacity. <EOL> -- Your task is to use the buckets to empty the wells. <EOL> -- Output the number of times you need to lower the buckets. <EOL> --  <EOL> -- Example 1: <EOL> --     Input:  <EOL> --         grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]] <EOL> --         bucket_capacity : 1 <EOL> --     Output: 6 <EOL> -- <EOL> -- Example 2: <EOL> --     Input:  <EOL> --         grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]] <EOL> --         bucket_capacity : 2 <EOL> --     Output: 5 <EOL> --  <EOL> -- Example 3: <EOL> --     Input:  <EOL> --         grid : [[0,0,0], [0,0,0]] <EOL> --         bucket_capacity : 5 <EOL> --     Output: 0 <EOL> --  <EOL> -- constraints: <EOL> --     * all wells have the same length <EOL> --     * 1 <= grid.length <= 10^2 <EOL> --     * 1 <= grid[:,1].length <= 10^2 <EOL> --     * grid[i][j] -> 0 | 1 <EOL> --     * 1 <= capacity <= 10 <EOL> max_fill :: [[Int]] -> Int -> Int <EOL> max_fill grid capacity = sum $ map (ceiling . (/ fromIntegral", "gt": "capacity) . fromIntegral . sum) $ grid", "prediction": " capacity)) grid"}
{"input": "<s> -- A simple program which should return the value of x if n is <EOL> -- a prime number and should return the value of y otherwise. <EOL> -- <EOL> -- Examples: <EOL> -- >>> x_or_y 7 34 12 <EOL> -- 34 <EOL> -- >>> x_or_y 15 8 5 <EOL> -- 5 <EOL> x_or_y :: Int -> Int -> Int -> Int <EOL> x_or_y n x y =", "gt": "if n == 1 then y else if length [i | i <- [2 .. n - 1], n `mod` i == 0] > 0 then y else x", "prediction": " x"}
{"input": "<s> -- A simple program which should return the value of x if n is <EOL> -- a prime number and should return the value of y otherwise. <EOL> -- <EOL> -- Examples: <EOL> -- >>> x_or_y 7 34 12 <EOL> -- 34 <EOL> -- >>> x_or_y 15 8 5 <EOL> -- 5 <EOL> x_or_y :: Int -> Int -> Int -> Int <EOL> x_or_y n x y = if n == 1 then y else if length [i |", "gt": "i <- [2 .. n - 1], n `mod` i == 0] > 0 then y else x", "prediction": " i <- [1..n], x `mod` i == 0 then x else y"}
{"input": "<s> -- A simple program which should return the value of x if n is <EOL> -- a prime number and should return the value of y otherwise. <EOL> -- <EOL> -- Examples: <EOL> -- >>> x_or_y 7 34 12 <EOL> -- 34 <EOL> -- >>> x_or_y 15 8 5 <EOL> -- 5 <EOL> x_or_y :: Int -> Int -> Int -> Int <EOL> x_or_y n x y = if n == 1 then y else if length [i | i <- [2 .. n - 1], n `mod` i == 0] > 0 then", "gt": "y else x", "prediction": " x else y"}
{"input": "<s> -- Imagine a road that's a perfectly straight infinitely long line. <EOL> -- n cars are driving left to right;  simultaneously, a different set of n cars <EOL> -- are driving right to left.   The two sets of cars start out being very far from <EOL> -- each other.  All cars move in the same speed.  Two cars are said to collide <EOL> -- when a car that's moving left to right hits a car that's moving right to left. <EOL> -- However, the cars are infinitely sturdy and strong; as a result, they continue moving <EOL> -- in their trajectory as if they did not collide. <EOL> --  <EOL> -- This function outputs the number of such collisions. <EOL> car_race_collision :: Int -> Int <EOL> car_race_collision n = n^", "gt": "2", "prediction": "2"}
{"input": "<s> -- Imagine a road that's a perfectly straight infinitely long line. <EOL> -- n cars are driving left to right;  simultaneously, a different set of n cars <EOL> -- are driving right to left.   The two sets of cars start out being very far from <EOL> -- each other.  All cars move in the same speed.  Two cars are said to collide <EOL> -- when a car that's moving left to right hits a car that's moving right to left. <EOL> -- However, the cars are infinitely sturdy and strong; as a result, they continue moving <EOL> -- in their trajectory as if they did not collide. <EOL> --  <EOL> -- This function outputs the number of such collisions. <EOL> car_race_collision :: Int -> Int <EOL> car_race_collision n =", "gt": "n^ 2", "prediction": " undefined"}
{"input": "<s> -- Your task is to write a function that returns true if a number x is a simple <EOL> -- power of n and false in other cases. <EOL> -- x is a simple power of n if n**int=x <EOL> -- For example: <EOL> -- is_simple_power 1 4 => true <EOL> -- is_simple_power 2 2 => true <EOL> -- is_simple_power 8 2 => true <EOL> -- is_simple_power 3 2 => false <EOL> -- is_simple_power 3 1 => false <EOL> -- is_simple_power 5 3 => false <EOL> is_simple_power :: Int -> Int -> Bool <EOL> is_simple_power x n = or [n ^ i == x |", "gt": "i <- [0..x]]", "prediction": " i <- [1..n]]"}
{"input": "<s> -- Your task is to write a function that returns true if a number x is a simple <EOL> -- power of n and false in other cases. <EOL> -- x is a simple power of n if n**int=x <EOL> -- For example: <EOL> -- is_simple_power 1 4 => true <EOL> -- is_simple_power 2 2 => true <EOL> -- is_simple_power 8 2 => true <EOL> -- is_simple_power 3 2 => false <EOL> -- is_simple_power 3 1 => false <EOL> -- is_simple_power 5 3 => false <EOL> is_simple_power :: Int -> Int -> Bool <EOL> is_simple_power x n =", "gt": "or [n ^ i == x | i <- [0..x]]", "prediction": " x"}
{"input": "<s> import Data.Char <EOL> -- Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you <EOL> -- should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the <EOL> -- alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25 <EOL> -- Examples <EOL> -- split_words \"Hello world!\" \u279e [\"Hello\",\"world!\"] <EOL> -- split_words \"Hello,world!\" \u279e [\"Hello\",\"world!\"] <EOL> -- split_words \"abcdef\" == 3  <EOL> split_words :: String -> Either Int [String] <EOL> split_words txt <EOL>   | ' ' `elem` txt = Right $ words txt <EOL>   | ',' `elem` txt =", "gt": "Right $ words $ map (\\c -> if c == ',' then ' ' else c) txt", "prediction": " Left"}
{"input": "<s> import Data.Char <EOL> -- Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you <EOL> -- should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the <EOL> -- alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25 <EOL> -- Examples <EOL> -- split_words \"Hello world!\" \u279e [\"Hello\",\"world!\"] <EOL> -- split_words \"Hello,world!\" \u279e [\"Hello\",\"world!\"] <EOL> -- split_words \"abcdef\" == 3  <EOL> split_words :: String -> Either Int [String] <EOL> split_words txt <EOL>   | ' ' `elem` txt = Right $ words txt <EOL>   | ',' `elem` txt = Right $ words $ map (\\c -> if c == ',' then ' ' else c) txt <EOL>   | otherwise = Left $ length $ filter", "gt": "(\\c -> isLower c && even (ord c)) txt", "prediction": " isnot . isSpace) txt"}
{"input": "<s> import Data.Char <EOL> -- Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you <EOL> -- should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the <EOL> -- alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25 <EOL> -- Examples <EOL> -- split_words \"Hello world!\" \u279e [\"Hello\",\"world!\"] <EOL> -- split_words \"Hello,world!\" \u279e [\"Hello\",\"world!\"] <EOL> -- split_words \"abcdef\" == 3  <EOL> split_words :: String -> Either Int [String] <EOL> split_words txt <EOL>   | ' ' `elem` txt = Right $ words txt <EOL>   | ',' `elem` txt = Right $ words $ map (\\c -> if c == ',' then ' ' else c) txt <EOL>   | otherwise =", "gt": "Left $ length $ filter (\\c -> isLower c && even (ord c)) txt", "prediction": " Left 0"}
{"input": "<s> import Data.Char <EOL> -- Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you <EOL> -- should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the <EOL> -- alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25 <EOL> -- Examples <EOL> -- split_words \"Hello world!\" \u279e [\"Hello\",\"world!\"] <EOL> -- split_words \"Hello,world!\" \u279e [\"Hello\",\"world!\"] <EOL> -- split_words \"abcdef\" == 3  <EOL> split_words :: String -> Either Int [String] <EOL> split_words txt <EOL>   | ' ' `elem` txt =", "gt": "Right $ words txt", "prediction": " Left 0"}
{"input": "<s> import Data.Char <EOL> -- Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you <EOL> -- should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the <EOL> -- alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25 <EOL> -- Examples <EOL> -- split_words \"Hello world!\" \u279e [\"Hello\",\"world!\"] <EOL> -- split_words \"Hello,world!\" \u279e [\"Hello\",\"world!\"] <EOL> -- split_words \"abcdef\" == 3  <EOL> split_words :: String -> Either Int [String] <EOL> split_words txt <EOL>   | ' ' `elem` txt = Right $ words txt <EOL>   | ',' `elem` txt = Right $ words $", "gt": "map (\\c -> if c == ',' then ' ' else c) txt", "prediction": " dropWhile isSpace txt"}
{"input": "<s> roundTo :: Double -> Int -> Double <EOL> roundTo x n = (fromInteger $ round $ x * (10^n)) / (10.0^^n) <EOL> -- Evaluates polynomial with coefficients xs at point x. <EOL> -- return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n <EOL> poly :: [Double] -> Double -> Double <EOL> poly coeffs x = sum [coeff * x ** fromIntegral i | (i, coeff) <- zip [0..] coeffs] <EOL> -- xs are coefficients of a polynomial. <EOL> -- find_zero find x such that poly(x) = 0. <EOL> -- find_zero returns only only zero point, even if there are many. <EOL> -- Moreover, find_zero only takes list xs having even number of coefficients <EOL> -- and largest non zero coefficient as it guarantees <EOL> -- a solution. <EOL> -- >>> roundTo (find_zero [1,2]) 2 -- f(x) = 1 + 2x <EOL> -- -0.5 <EOL> -- >>> roundTo (find_zero [-6,11,-6,1]) 2 -- (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 <EOL> -- 1.0 <EOL> find_zero :: [Double] -> Double <EOL> find_zero coeffs = go (-1.0) 1.0 <EOL>     where <EOL>         go :: Double -> Double -> Double <EOL>         go begin end <EOL>             | abs (end - begin) < 1e-10 = begin <EOL>             | otherwise = <EOL>                 let center = (begin + end) / 2.0 in <EOL>                     if", "gt": "poly coeffs center * poly coeffs begin > 0", "prediction": " abs (end - begin) < 1e-10"}
{"input": "<s> roundTo :: Double -> Int -> Double <EOL> roundTo x n = (fromInteger $ round $ x * (10^n)) / (10.0^^n) <EOL> -- Evaluates polynomial with coefficients xs at point x. <EOL> -- return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n <EOL> poly :: [Double] -> Double -> Double <EOL> poly coeffs x = sum [coeff * x ** fromIntegral i | (i, coeff) <- zip [0..] coeffs] <EOL> -- xs are coefficients of a polynomial. <EOL> -- find_zero find x such that poly(x) = 0. <EOL> -- find_zero returns only only zero point, even if there are many. <EOL> -- Moreover, find_zero only takes list xs having even number of coefficients <EOL> -- and largest non zero coefficient as it guarantees <EOL> -- a solution. <EOL> -- >>> roundTo (find_zero [1,2]) 2 -- f(x) = 1 + 2x <EOL> -- -0.5 <EOL> -- >>> roundTo (find_zero [-6,11,-6,1]) 2 -- (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 <EOL> -- 1.0 <EOL> find_zero :: [Double] -> Double <EOL> find_zero coeffs = go (-1.0) 1.0 <EOL>     where <EOL>         go :: Double -> Double -> Double <EOL>         go begin end <EOL>             | abs (end - begin) < 1e-10 = begin <EOL>             | otherwise = <EOL>                 let center = (begin + end) / 2.0 in <EOL>                     if poly coeffs center * poly coeffs begin > 0 <EOL>                         then", "gt": "go center end", "prediction": " 1.0"}
{"input": "<s> roundTo :: Double -> Int -> Double <EOL> roundTo x n = (fromInteger $ round $ x * (10^n)) / (10.0^^n) <EOL> -- Evaluates polynomial with coefficients xs at point x. <EOL> -- return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n <EOL> poly :: [Double] -> Double -> Double <EOL> poly coeffs x = sum [coeff * x ** fromIntegral i | (i, coeff) <- zip [0..] coeffs] <EOL> -- xs are coefficients of a polynomial. <EOL> -- find_zero find x such that poly(x) = 0. <EOL> -- find_zero returns only only zero point, even if there are many. <EOL> -- Moreover, find_zero only takes list xs having even number of coefficients <EOL> -- and largest non zero coefficient as it guarantees <EOL> -- a solution. <EOL> -- >>> roundTo (find_zero [1,2]) 2 -- f(x) = 1 + 2x <EOL> -- -0.5 <EOL> -- >>> roundTo (find_zero [-6,11,-6,1]) 2 -- (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 <EOL> -- 1.0 <EOL> find_zero :: [Double] -> Double <EOL> find_zero coeffs = go (-1.0) 1.0 <EOL>     where <EOL>         go :: Double -> Double -> Double <EOL>         go begin end <EOL>             | abs (end - begin) < 1e-10 = begin <EOL>             | otherwise = <EOL>                 let center =", "gt": "(begin + end) / 2.0 in", "prediction": " end - begin"}
{"input": "<s> roundTo :: Double -> Int -> Double <EOL> roundTo x n =", "gt": "(fromInteger $ round $ x * (10^n)) / (10.0^^n)", "prediction": " round (x / fromIntegral n)"}
{"input": "<s> roundTo :: Double -> Int -> Double <EOL> roundTo x n = (fromInteger $ round $ x * (10^n)) / (10.0^^n) <EOL> -- Evaluates polynomial with coefficients xs at point x. <EOL> -- return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n <EOL> poly :: [Double] -> Double -> Double <EOL> poly coeffs x = sum [coeff * x ** fromIntegral i | (i, coeff) <-", "gt": "zip [0..] coeffs]", "prediction": " zip [0..] $ iterate (*x) 1]"}
{"input": "<s> -- Return True if all numbers in the list l are below threshold t. <EOL> -- >>> below_threshold [1,2,4,10] 100 <EOL> -- True <EOL> -- >>> below_threshold [1,20,4,10] 5 <EOL> -- False <EOL> below_threshold :: [Int] -> Int -> Bool <EOL> below_threshold numbers threshold =", "gt": "all (< threshold) numbers", "prediction": " and"}
{"input": "<s> -- Write a function which sorts the given list of integers <EOL> -- in ascending order according to the sum of their digits. <EOL> -- Note: if there are several items with similar sum of their digits, <EOL> -- order them based on their index in original list. <EOL> -- <EOL> -- For example: <EOL> -- >>> order_by_points [1, 11, -1, -11, -12] <EOL> -- [-1, -11, 1, -12, 11] <EOL> -- >>> order_by_points [] <EOL> -- [] <EOL> import Data.List (sortBy) <EOL> -- Remember that if the number is negative, you need to not parse the first '-' and multiply the first number of the sum by -1 <EOL> order_by_points :: [Int] -> [Int] <EOL> order_by_points nums =", "gt": "sortBy (\\x y -> compare (digits_sum x) (digits_sum y)) nums", "prediction": " undefined"}
{"input": "<s> -- Write a function which sorts the given list of integers <EOL> -- in ascending order according to the sum of their digits. <EOL> -- Note: if there are several items with similar sum of their digits, <EOL> -- order them based on their index in original list. <EOL> -- <EOL> -- For example: <EOL> -- >>> order_by_points [1, 11, -1, -11, -12] <EOL> -- [-1, -11, 1, -12, 11] <EOL> -- >>> order_by_points [] <EOL> -- [] <EOL> import Data.List (sortBy) <EOL> -- Remember that if the number is negative, you need to not parse the first '-' and multiply the first number of the sum by -1 <EOL> order_by_points :: [Int] -> [Int] <EOL> order_by_points nums = sortBy (\\x y -> compare (digits_sum x) (digits_sum y)) nums <EOL> digits_sum :: Int -> Int <EOL> digits_sum n <EOL>   | n < 0 = sum $ ((read [(show n) !! 1] :: Int) * (-1)) : map (\\x -> read [x] :: Int) (drop 2 (show n)) <EOL>   | otherwise =", "gt": "sum $ map (\\x -> read [x] :: Int) (show n)", "prediction": " 0"}
{"input": "<s> -- Write a function which sorts the given list of integers <EOL> -- in ascending order according to the sum of their digits. <EOL> -- Note: if there are several items with similar sum of their digits, <EOL> -- order them based on their index in original list. <EOL> -- <EOL> -- For example: <EOL> -- >>> order_by_points [1, 11, -1, -11, -12] <EOL> -- [-1, -11, 1, -12, 11] <EOL> -- >>> order_by_points [] <EOL> -- [] <EOL> import Data.List (sortBy) <EOL> -- Remember that if the number is negative, you need to not parse the first '-' and multiply the first number of the sum by -1 <EOL> order_by_points :: [Int] -> [Int] <EOL> order_by_points nums = sortBy (\\x y -> compare (digits_sum x) (digits_sum y)) nums <EOL> digits_sum :: Int -> Int <EOL> digits_sum n <EOL>   | n < 0 = sum $ ((read [(show n) !! 1] :: Int) * (-1)) : map (\\x ->", "gt": "read [x] :: Int) (drop 2 (show n))", "prediction": " read (show x) :: Int) nums"}
{"input": "<s> -- Write a function which sorts the given list of integers <EOL> -- in ascending order according to the sum of their digits. <EOL> -- Note: if there are several items with similar sum of their digits, <EOL> -- order them based on their index in original list. <EOL> -- <EOL> -- For example: <EOL> -- >>> order_by_points [1, 11, -1, -11, -12] <EOL> -- [-1, -11, 1, -12, 11] <EOL> -- >>> order_by_points [] <EOL> -- [] <EOL> import Data.List (sortBy) <EOL> -- Remember that if the number is negative, you need to not parse the first '-' and multiply the first number of the sum by -1 <EOL> order_by_points :: [Int] -> [Int] <EOL> order_by_points nums = sortBy (\\x y -> compare (digits_sum x) (digits_sum y)) nums <EOL> digits_sum :: Int -> Int <EOL> digits_sum n <EOL>   | n < 0 =", "gt": "sum $ ((read [(show n) !! 1] :: Int) * (-1)) : map (\\x -> read [x] :: Int) (drop 2 (show n))", "prediction": " n"}
{"input": "<s> -- Write a function which sorts the given list of integers <EOL> -- in ascending order according to the sum of their digits. <EOL> -- Note: if there are several items with similar sum of their digits, <EOL> -- order them based on their index in original list. <EOL> -- <EOL> -- For example: <EOL> -- >>> order_by_points [1, 11, -1, -11, -12] <EOL> -- [-1, -11, 1, -12, 11] <EOL> -- >>> order_by_points [] <EOL> -- [] <EOL> import Data.List (sortBy) <EOL> -- Remember that if the number is negative, you need to not parse the first '-' and multiply the first number of the sum by -1 <EOL> order_by_points :: [Int] -> [Int] <EOL> order_by_points nums = sortBy (\\x y -> compare (digits_sum x) (digits_sum y)) nums <EOL> digits_sum :: Int -> Int <EOL> digits_sum n <EOL>   | n < 0 = sum $ ((read [(show n) !! 1] :: Int) * (-1)) : map (\\x -> read [x] :: Int) (drop 2 (show n)) <EOL>   | otherwise = sum $ map (\\x ->", "gt": "read [x] :: Int) (show n)", "prediction": " read [x] :: Int) (drop 1 (show n))"}
{"input": "<s> -- Change numerical base of input number x to base. <EOL> -- return string representation after the conversion. <EOL> -- base numbers are less than 10. <EOL> -- >>> change_base 8 3 <EOL> -- \"22\" <EOL> -- >>> change_base 8 2 <EOL> -- \"1000\" <EOL> -- >>> change_base 7 2 <EOL> -- \"111\" <EOL> change_base :: Int -> Int -> String <EOL> change_base x base =", "gt": "reverse $ change_base' x", "prediction": " let"}
{"input": "<s> -- Change numerical base of input number x to base. <EOL> -- return string representation after the conversion. <EOL> -- base numbers are less than 10. <EOL> -- >>> change_base 8 3 <EOL> -- \"22\" <EOL> -- >>> change_base 8 2 <EOL> -- \"1000\" <EOL> -- >>> change_base 7 2 <EOL> -- \"111\" <EOL> change_base :: Int -> Int -> String <EOL> change_base x base = reverse $ change_base' x <EOL>   where <EOL>     change_base' :: Int -> String  <EOL>     change_base' 0 = \"\" <EOL>     change_base' x =", "gt": "show (x `mod` base) ++ change_base' (x `div` base)", "prediction": " ("}
{"input": "<s> -- Change numerical base of input number x to base. <EOL> -- return string representation after the conversion. <EOL> -- base numbers are less than 10. <EOL> -- >>> change_base 8 3 <EOL> -- \"22\" <EOL> -- >>> change_base 8 2 <EOL> -- \"1000\" <EOL> -- >>> change_base 7 2 <EOL> -- \"111\" <EOL> change_base :: Int -> Int -> String <EOL> change_base x base = reverse $ change_base' x <EOL>   where <EOL>     change_base' :: Int -> String  <EOL>     change_base' 0 = \"\" <EOL>     change_base' x = show (x `mod` base) ++", "gt": "change_base' (x `div` base)", "prediction": " \"0\""}
{"input": "<s> -- Change numerical base of input number x to base. <EOL> -- return string representation after the conversion. <EOL> -- base numbers are less than 10. <EOL> -- >>> change_base 8 3 <EOL> -- \"22\" <EOL> -- >>> change_base 8 2 <EOL> -- \"1000\" <EOL> -- >>> change_base 7 2 <EOL> -- \"111\" <EOL> change_base :: Int -> Int -> String <EOL> change_base x base = reverse $ change_base' x <EOL>   where <EOL>     change_base' :: Int -> String  <EOL>     change_base' 0 =", "gt": "\"\"", "prediction": " \"\""}
{"input": "<s> -- Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions. <EOL> -- <EOL> -- <EOL> -- Examples <EOL> -- solution [5, 8, 7, 1] ==> 12 <EOL> -- solution [3, 3, 3, 3, 3] ==> 9 <EOL> -- solution [30, 13, 24, 321] ==> 0 <EOL> solution :: [Int] -> Int <EOL> solution lst = <EOL>   sum <EOL>     [ x <EOL>       | (idx, x) <-", "gt": "zip [0 ..] lst,", "prediction": " zip [1..] lst"}
{"input": "<s> -- Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions. <EOL> -- <EOL> -- <EOL> -- Examples <EOL> -- solution [5, 8, 7, 1] ==> 12 <EOL> -- solution [3, 3, 3, 3, 3] ==> 9 <EOL> -- solution [30, 13, 24, 321] ==> 0 <EOL> solution :: [Int] -> Int <EOL> solution lst = <EOL>   sum <EOL>     [ x <EOL>       | (idx, x) <- zip [0 ..] lst, <EOL>         even idx, <EOL>         odd", "gt": "x", "prediction": " x = x"}
{"input": "<s> -- Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions. <EOL> -- <EOL> -- <EOL> -- Examples <EOL> -- solution [5, 8, 7, 1] ==> 12 <EOL> -- solution [3, 3, 3, 3, 3] ==> 9 <EOL> -- solution [30, 13, 24, 321] ==> 0 <EOL> solution :: [Int] -> Int <EOL> solution lst = <EOL>   sum <EOL>     [ x <EOL>       | (idx, x) <- zip [0 ..] lst, <EOL>         even", "gt": "idx,", "prediction": "Sum"}
{"input": "<s> -- Given a non-empty array of integers arr and an integer k, return <EOL> -- the sum of the elements with at most two digits from the first k elements of arr. <EOL> --  <EOL> -- Example: <EOL> --  <EOL> --     Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4 <EOL> --     Output: 24 # sum of 21 + 3 <EOL> --  <EOL> -- Constraints: <EOL> --     1. 1 <= len(arr) <= 100 <EOL> --     2. 1 <= k <= len(arr) <EOL> add_elements :: [Int] -> Int -> Int <EOL> add_elements arr k = sum [x | x <- take k arr,", "gt": "length (show x) <= 2]", "prediction": " x x 2 == 0]"}
{"input": "<s> -- Given a non-empty array of integers arr and an integer k, return <EOL> -- the sum of the elements with at most two digits from the first k elements of arr. <EOL> --  <EOL> -- Example: <EOL> --  <EOL> --     Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4 <EOL> --     Output: 24 # sum of 21 + 3 <EOL> --  <EOL> -- Constraints: <EOL> --     1. 1 <= len(arr) <= 100 <EOL> --     2. 1 <= k <= len(arr) <EOL> add_elements :: [Int] -> Int -> Int <EOL> add_elements arr k =", "gt": "sum [x | x <- take k arr, length (show x) <= 2]", "prediction": " sum"}
{"input": "<s> -- Given a non-empty array of integers arr and an integer k, return <EOL> -- the sum of the elements with at most two digits from the first k elements of arr. <EOL> --  <EOL> -- Example: <EOL> --  <EOL> --     Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4 <EOL> --     Output: 24 # sum of 21 + 3 <EOL> --  <EOL> -- Constraints: <EOL> --     1. 1 <= len(arr) <= 100 <EOL> --     2. 1 <= k <= len(arr) <EOL> add_elements :: [Int] -> Int -> Int <EOL> add_elements arr k = sum [x | x <-", "gt": "take k arr, length (show x) <= 2]", "prediction": " arr, mod k x == 0]"}
{"input": "<s> -- Given a non-empty array of integers arr and an integer k, return <EOL> -- the sum of the elements with at most two digits from the first k elements of arr. <EOL> --  <EOL> -- Example: <EOL> --  <EOL> --     Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4 <EOL> --     Output: 24 # sum of 21 + 3 <EOL> --  <EOL> -- Constraints: <EOL> --     1. 1 <= len(arr) <= 100 <EOL> --     2. 1 <= k <= len(arr) <EOL> add_elements :: [Int] -> Int -> Int <EOL> add_elements arr k = sum", "gt": "[x | x <- take k arr, length (show x) <= 2]", "prediction": " $ zipWith (+) arr (repeat k)"}
{"input": "<s> import Data.Char <EOL> -- Given a dictionary, return True if all keys are strings in lower <EOL> -- case or all keys are strings in upper case, else return False. <EOL> -- The function should return False is the given dictionary is empty. <EOL> -- Examples: <EOL> -- check_dict_case [(\"a\",\"apple\"), (\"b\",\"banana\")] should return True. <EOL> -- check_dict_case [(\"a\",\"apple\"), (\"A\",\"banana\"), (\"B\",\"banana\")] should return False. <EOL> -- check_dict_case [(\"a\",\"apple\"), (\"8\",\"banana\"), (\"a\",\"apple\")] should return False. <EOL> -- check_dict_case [(\"Name\",\"John\"), (\"Age\",\"36\"), (\"City\",\"Houston\")] should return False. <EOL> -- check_dict_case [(\"STATE\",\"NC\"), (\"ZIP\",\"12345\")] should return True. <EOL> check_dict_case :: [(String, String)] -> Bool <EOL> check_dict_case dict = <EOL>   length dict >", "gt": "0", "prediction": " 0"}
{"input": "<s> import Data.Char <EOL> -- Given a dictionary, return True if all keys are strings in lower <EOL> -- case or all keys are strings in upper case, else return False. <EOL> -- The function should return False is the given dictionary is empty. <EOL> -- Examples: <EOL> -- check_dict_case [(\"a\",\"apple\"), (\"b\",\"banana\")] should return True. <EOL> -- check_dict_case [(\"a\",\"apple\"), (\"A\",\"banana\"), (\"B\",\"banana\")] should return False. <EOL> -- check_dict_case [(\"a\",\"apple\"), (\"8\",\"banana\"), (\"a\",\"apple\")] should return False. <EOL> -- check_dict_case [(\"Name\",\"John\"), (\"Age\",\"36\"), (\"City\",\"Houston\")] should return False. <EOL> -- check_dict_case [(\"STATE\",\"NC\"), (\"ZIP\",\"12345\")] should return True. <EOL> check_dict_case :: [(String, String)] -> Bool <EOL> check_dict_case dict = <EOL>   length dict > 0 <EOL>     && all (\\x ->", "gt": "all isUpper x) keys", "prediction": " length x > 0) dict"}
{"input": "<s> import Data.Char <EOL> -- Given a dictionary, return True if all keys are strings in lower <EOL> -- case or all keys are strings in upper case, else return False. <EOL> -- The function should return False is the given dictionary is empty. <EOL> -- Examples: <EOL> -- check_dict_case [(\"a\",\"apple\"), (\"b\",\"banana\")] should return True. <EOL> -- check_dict_case [(\"a\",\"apple\"), (\"A\",\"banana\"), (\"B\",\"banana\")] should return False. <EOL> -- check_dict_case [(\"a\",\"apple\"), (\"8\",\"banana\"), (\"a\",\"apple\")] should return False. <EOL> -- check_dict_case [(\"Name\",\"John\"), (\"Age\",\"36\"), (\"City\",\"Houston\")] should return False. <EOL> -- check_dict_case [(\"STATE\",\"NC\"), (\"ZIP\",\"12345\")] should return True. <EOL> check_dict_case :: [(String, String)] -> Bool <EOL> check_dict_case dict = <EOL>   length dict > 0 <EOL>     && all (\\x -> all isUpper x) keys <EOL>     || all <EOL>       (\\x ->", "gt": "all isLower x)", "prediction": " length x > 0) keys"}
{"input": "<s> import Data.Char <EOL> -- Given a dictionary, return True if all keys are strings in lower <EOL> -- case or all keys are strings in upper case, else return False. <EOL> -- The function should return False is the given dictionary is empty. <EOL> -- Examples: <EOL> -- check_dict_case [(\"a\",\"apple\"), (\"b\",\"banana\")] should return True. <EOL> -- check_dict_case [(\"a\",\"apple\"), (\"A\",\"banana\"), (\"B\",\"banana\")] should return False. <EOL> -- check_dict_case [(\"a\",\"apple\"), (\"8\",\"banana\"), (\"a\",\"apple\")] should return False. <EOL> -- check_dict_case [(\"Name\",\"John\"), (\"Age\",\"36\"), (\"City\",\"Houston\")] should return False. <EOL> -- check_dict_case [(\"STATE\",\"NC\"), (\"ZIP\",\"12345\")] should return True. <EOL> check_dict_case :: [(String, String)] -> Bool <EOL> check_dict_case dict = <EOL>   length dict > 0 <EOL>     && all (\\x -> all isUpper x) keys <EOL>     || all <EOL>       (\\x -> all isLower x) <EOL>       keys <EOL>   where <EOL>     keys = map", "gt": "fst dict", "prediction": " (Lower keys"}
{"input": "<s> import Data.Char (isLetter) <EOL> check_if_last_char_is_a_letter :: String -> Bool <EOL> check_if_last_char_is_a_letter [] =", "gt": "False", "prediction": " False"}
{"input": "<s> import Data.Char (isLetter) <EOL> check_if_last_char_is_a_letter :: String -> Bool <EOL> check_if_last_char_is_a_letter [] = False <EOL> check_if_last_char_is_a_letter txt =", "gt": "isLetter $ last txt", "prediction": " is"}
{"input": "<s> -- Complete the function that takes two integers and returns <EOL> -- the product of their unit digits. <EOL> -- Assume the input is always valid. <EOL> -- Examples: <EOL> -- multiply 148 412 should return 16. <EOL> -- multiply 19 28 should return 72. <EOL> -- multiply 2020 1851 should return 0. <EOL> -- multiply 14 (-15) should return 20. <EOL> multiply :: Int -> Int -> Int <EOL> multiply a b = <EOL>   abs", "gt": "(a `mod` 10)", "prediction": " (a * b)"}
{"input": "<s> -- Complete the function that takes two integers and returns <EOL> -- the product of their unit digits. <EOL> -- Assume the input is always valid. <EOL> -- Examples: <EOL> -- multiply 148 412 should return 16. <EOL> -- multiply 19 28 should return 72. <EOL> -- multiply 2020 1851 should return 0. <EOL> -- multiply 14 (-15) should return 20. <EOL> multiply :: Int -> Int -> Int <EOL> multiply a b = <EOL>   abs (a `mod` 10) <EOL>     * abs", "gt": "(b `mod` 10)", "prediction": " (b `mod` 10)"}
{"input": "<s> -- Given two positive integers a and b, return the even digits between a <EOL> -- and b, in ascending order. <EOL> -- <EOL> -- For example: <EOL> -- >>> generate_integers 2 8 <EOL> -- [2, 4, 6, 8] <EOL> -- >>> generate_integers 8 2 <EOL> -- [2, 4, 6, 8] <EOL> -- >>> generate_integers 10 14 <EOL> -- [] <EOL> generate_integers :: Int -> Int -> [Int] <EOL> generate_integers a b = [i | i <-", "gt": "[max 2 (min a b) .. min 8 (max a b)], even i]", "prediction": " [a..b], mod i 2 == 0]"}
{"input": "<s> -- Given two positive integers a and b, return the even digits between a <EOL> -- and b, in ascending order. <EOL> -- <EOL> -- For example: <EOL> -- >>> generate_integers 2 8 <EOL> -- [2, 4, 6, 8] <EOL> -- >>> generate_integers 8 2 <EOL> -- [2, 4, 6, 8] <EOL> -- >>> generate_integers 10 14 <EOL> -- [] <EOL> generate_integers :: Int -> Int -> [Int] <EOL> generate_integers a b =", "gt": "[i | i <- [max 2 (min a b) .. min 8 (max a b)], even i]", "prediction": " map"}
{"input": "<s> -- The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows: <EOL> -- fib4(0) -> 0 <EOL> -- fib4(1) -> 0 <EOL> -- fib4(2) -> 2 <EOL> -- fib4(3) -> 0 <EOL> -- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). <EOL> -- Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion. <EOL> -- >>> fib4 5 <EOL> -- 4 <EOL> -- >>> fib4 6 <EOL> -- 8 <EOL> -- >>> fib4 7 <EOL> -- 14 <EOL> fib4 :: Int -> Int <EOL> fib4 n = fib4' n 0 0 2 0 <EOL>   where <EOL>     fib4' :: Int -> Int -> Int -> Int -> Int -> Int <EOL>     fib4' 0 a b c d = a <EOL>     fib4' 1 a b c d = b <EOL>     fib4' 2 a b c d = c <EOL>     fib4' 3 a b c d = d <EOL>     fib4' n a b c d =", "gt": "fib4' (n - 1) b c d (a + b + c + d)", "prediction": " fib4' (n-1) a b c d"}
{"input": "<s> -- The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows: <EOL> -- fib4(0) -> 0 <EOL> -- fib4(1) -> 0 <EOL> -- fib4(2) -> 2 <EOL> -- fib4(3) -> 0 <EOL> -- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). <EOL> -- Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion. <EOL> -- >>> fib4 5 <EOL> -- 4 <EOL> -- >>> fib4 6 <EOL> -- 8 <EOL> -- >>> fib4 7 <EOL> -- 14 <EOL> fib4 :: Int -> Int <EOL> fib4 n = fib4' n 0 0 2 0 <EOL>   where <EOL>     fib4' :: Int -> Int -> Int -> Int -> Int -> Int <EOL>     fib4' 0 a b c d = a <EOL>     fib4' 1 a b c d = b <EOL>     fib4' 2 a b c d = c <EOL>     fib4' 3 a b c d = d <EOL>     fib4' n a b c d = fib4' (n - 1) b c d", "gt": "(a + b + c + d)", "prediction": " 0"}
{"input": "<s> -- The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows: <EOL> -- fib4(0) -> 0 <EOL> -- fib4(1) -> 0 <EOL> -- fib4(2) -> 2 <EOL> -- fib4(3) -> 0 <EOL> -- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). <EOL> -- Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion. <EOL> -- >>> fib4 5 <EOL> -- 4 <EOL> -- >>> fib4 6 <EOL> -- 8 <EOL> -- >>> fib4 7 <EOL> -- 14 <EOL> fib4 :: Int -> Int <EOL> fib4 n = fib4' n 0 0 2 0 <EOL>   where <EOL>     fib4' :: Int -> Int -> Int -> Int -> Int -> Int <EOL>     fib4' 0 a b c d = a <EOL>     fib4' 1 a b c d =", "gt": "b", "prediction": " a4' (a+1) b c d"}
{"input": "<s> -- The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows: <EOL> -- fib4(0) -> 0 <EOL> -- fib4(1) -> 0 <EOL> -- fib4(2) -> 2 <EOL> -- fib4(3) -> 0 <EOL> -- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). <EOL> -- Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion. <EOL> -- >>> fib4 5 <EOL> -- 4 <EOL> -- >>> fib4 6 <EOL> -- 8 <EOL> -- >>> fib4 7 <EOL> -- 14 <EOL> fib4 :: Int -> Int <EOL> fib4 n = fib4' n 0 0 2 0 <EOL>   where <EOL>     fib4' :: Int -> Int -> Int -> Int -> Int -> Int <EOL>     fib4' 0 a b c d = a <EOL>     fib4' 1 a b c d = b <EOL>     fib4' 2 a b c d =", "gt": "c", "prediction": " csmu"}
{"input": "<s> -- The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows: <EOL> -- fib4(0) -> 0 <EOL> -- fib4(1) -> 0 <EOL> -- fib4(2) -> 2 <EOL> -- fib4(3) -> 0 <EOL> -- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). <EOL> -- Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion. <EOL> -- >>> fib4 5 <EOL> -- 4 <EOL> -- >>> fib4 6 <EOL> -- 8 <EOL> -- >>> fib4 7 <EOL> -- 14 <EOL> fib4 :: Int -> Int <EOL> fib4 n = fib4' n 0 0 2 0 <EOL>   where <EOL>     fib4' :: Int -> Int -> Int -> Int -> Int -> Int <EOL>     fib4' 0 a b c d =", "gt": "a", "prediction": " a"}
{"input": "<s> -- Given a string s and a natural number n, you have been tasked to implement  <EOL> -- a function that returns a list of all words from string s that contain exactly  <EOL> -- n consonants, in order these words appear in the string s. <EOL> -- If the string s is empty then the function should return an empty list. <EOL> -- Note: you may assume the input string contains only letters and spaces. <EOL> -- Examples: <EOL> -- select_words \"Mary had a little lamb\" 4 ==> [\"little\"] <EOL> -- select_words \"Mary had a little lamb\" 3 ==> [\"Mary\", \"lamb\"] <EOL> -- select_words \"simple white space\" 2 ==> [] <EOL> -- select_words \"Hello world\" 4 ==> [\"world\"] <EOL> -- select_words \"Uncle sam\" 3 ==> [\"Uncle\"] <EOL> import Data.Char (toLower) <EOL> select_words :: String -> Int -> [String] <EOL> select_words s n = filter (\\word ->", "gt": "countConsonants word == n) $ words s", "prediction": " word word > n) (words s)"}
{"input": "<s> -- Given a string s and a natural number n, you have been tasked to implement  <EOL> -- a function that returns a list of all words from string s that contain exactly  <EOL> -- n consonants, in order these words appear in the string s. <EOL> -- If the string s is empty then the function should return an empty list. <EOL> -- Note: you may assume the input string contains only letters and spaces. <EOL> -- Examples: <EOL> -- select_words \"Mary had a little lamb\" 4 ==> [\"little\"] <EOL> -- select_words \"Mary had a little lamb\" 3 ==> [\"Mary\", \"lamb\"] <EOL> -- select_words \"simple white space\" 2 ==> [] <EOL> -- select_words \"Hello world\" 4 ==> [\"world\"] <EOL> -- select_words \"Uncle sam\" 3 ==> [\"Uncle\"] <EOL> import Data.Char (toLower) <EOL> select_words :: String -> Int -> [String] <EOL> select_words s n = filter", "gt": "(\\word -> countConsonants word == n) $ words s", "prediction": " (not . null) $ select s n"}
{"input": "<s> -- Given a string s and a natural number n, you have been tasked to implement  <EOL> -- a function that returns a list of all words from string s that contain exactly  <EOL> -- n consonants, in order these words appear in the string s. <EOL> -- If the string s is empty then the function should return an empty list. <EOL> -- Note: you may assume the input string contains only letters and spaces. <EOL> -- Examples: <EOL> -- select_words \"Mary had a little lamb\" 4 ==> [\"little\"] <EOL> -- select_words \"Mary had a little lamb\" 3 ==> [\"Mary\", \"lamb\"] <EOL> -- select_words \"simple white space\" 2 ==> [] <EOL> -- select_words \"Hello world\" 4 ==> [\"world\"] <EOL> -- select_words \"Uncle sam\" 3 ==> [\"Uncle\"] <EOL> import Data.Char (toLower) <EOL> select_words :: String -> Int -> [String] <EOL> select_words s n = filter (\\word -> countConsonants word == n) $ words s <EOL>   where <EOL>     countConsonants word = length $ filter", "gt": "(\\c -> isConsonant c && isLetter c) word", "prediction": " (c -> countConsonants c == n) word"}
{"input": "<s> -- Given a string s and a natural number n, you have been tasked to implement  <EOL> -- a function that returns a list of all words from string s that contain exactly  <EOL> -- n consonants, in order these words appear in the string s. <EOL> -- If the string s is empty then the function should return an empty list. <EOL> -- Note: you may assume the input string contains only letters and spaces. <EOL> -- Examples: <EOL> -- select_words \"Mary had a little lamb\" 4 ==> [\"little\"] <EOL> -- select_words \"Mary had a little lamb\" 3 ==> [\"Mary\", \"lamb\"] <EOL> -- select_words \"simple white space\" 2 ==> [] <EOL> -- select_words \"Hello world\" 4 ==> [\"world\"] <EOL> -- select_words \"Uncle sam\" 3 ==> [\"Uncle\"] <EOL> import Data.Char (toLower) <EOL> select_words :: String -> Int -> [String] <EOL> select_words s n = filter (\\word -> countConsonants word == n) $ words s <EOL>   where <EOL>     countConsonants word = length $ filter (\\c -> isConsonant c && isLetter c) word <EOL>     isConsonant c =", "gt": "toLower c `notElem` \"aeiou\"", "prediction": " countConsonants c == n"}
{"input": "<s> -- Given a string s and a natural number n, you have been tasked to implement  <EOL> -- a function that returns a list of all words from string s that contain exactly  <EOL> -- n consonants, in order these words appear in the string s. <EOL> -- If the string s is empty then the function should return an empty list. <EOL> -- Note: you may assume the input string contains only letters and spaces. <EOL> -- Examples: <EOL> -- select_words \"Mary had a little lamb\" 4 ==> [\"little\"] <EOL> -- select_words \"Mary had a little lamb\" 3 ==> [\"Mary\", \"lamb\"] <EOL> -- select_words \"simple white space\" 2 ==> [] <EOL> -- select_words \"Hello world\" 4 ==> [\"world\"] <EOL> -- select_words \"Uncle sam\" 3 ==> [\"Uncle\"] <EOL> import Data.Char (toLower) <EOL> select_words :: String -> Int -> [String] <EOL> select_words s n = filter (\\word -> countConsonants word == n) $ words s <EOL>   where <EOL>     countConsonants word = length $ filter (\\c -> isConsonant c && isLetter c) word <EOL>     isConsonant c = toLower c `notElem` \"aeiou\" <EOL>     isLetter c =", "gt": "c `elem` ['a'..'z'] ++ ['A'..'Z']", "prediction": " c `elem` ['a'..'z']"}
{"input": "<s> -- Given a list of numbers, return the sum of squares of the numbers <EOL> -- in the list that are odd. Ignore numbers that are negative or not integers. <EOL> -- <EOL> -- >>> double_the_difference [1, 3, 2, 0] <EOL> -- 10 (1 + 9 + 0 + 0) <EOL> -- >>> double_the_difference [-1, -2, 0] <EOL> -- 0 <EOL> -- >>> double_the_difference [9, -2] <EOL> -- 81 <EOL> -- >>> double_the_difference [0] <EOL> -- 0 <EOL> -- <EOL> -- If the input list is empty, return 0. <EOL> double_the_difference :: [Int] -> Int <EOL> double_the_difference lst =", "gt": "sum [i ^ 2 | i <- lst, i > 0, odd i]", "prediction": " fold"}
{"input": "<s> -- Given a list of numbers, return the sum of squares of the numbers <EOL> -- in the list that are odd. Ignore numbers that are negative or not integers. <EOL> -- <EOL> -- >>> double_the_difference [1, 3, 2, 0] <EOL> -- 10 (1 + 9 + 0 + 0) <EOL> -- >>> double_the_difference [-1, -2, 0] <EOL> -- 0 <EOL> -- >>> double_the_difference [9, -2] <EOL> -- 81 <EOL> -- >>> double_the_difference [0] <EOL> -- 0 <EOL> -- <EOL> -- If the input list is empty, return 0. <EOL> double_the_difference :: [Int] -> Int <EOL> double_the_difference lst = sum [i ^ 2 |", "gt": "i <- lst, i > 0, odd i]", "prediction": " i <- lst]"}
{"input": "<s> -- The Brazilian factorial is defined as: <EOL> -- brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! <EOL> -- where n > 0 <EOL> -- <EOL> -- For example: <EOL> -- >>> special_factorial 4 <EOL> -- 288 <EOL> -- <EOL> -- The function will receive an integer as input and should return the special <EOL> -- factorial of this integer. <EOL> special_factorial :: Int -> Int <EOL> special_factorial n = product [product [1 .. i] | i <-", "gt": "[1 .. n]]", "prediction": " [1..n]]"}
{"input": "<s> -- The Brazilian factorial is defined as: <EOL> -- brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! <EOL> -- where n > 0 <EOL> -- <EOL> -- For example: <EOL> -- >>> special_factorial 4 <EOL> -- 288 <EOL> -- <EOL> -- The function will receive an integer as input and should return the special <EOL> -- factorial of this integer. <EOL> special_factorial :: Int -> Int <EOL> special_factorial n =", "gt": "product [product [1 .. i] | i <- [1 .. n]]", "prediction": " product [1..n]"}
{"input": "<s> import Data.List (sort) <EOL> -- Return median of elements in the list l. <EOL> -- >>> median [3,1,2,4,5] <EOL> -- 3.0 <EOL> -- >>> median [-10,4,6,1000,10,20] <EOL> -- 8.0 <EOL> median :: [Int] -> Double <EOL> median xs = if odd len then fromIntegral (sorted !! (len `div` 2)) else (fromIntegral (sorted !! (len `div` 2 - 1)) + fromIntegral (sorted !! (len `div` 2))) / 2 <EOL>   where <EOL>     sorted :: [Int] <EOL>     sorted =", "gt": "sort xs", "prediction": " sort xs"}
{"input": "<s> import Data.List (sort) <EOL> -- Return median of elements in the list l. <EOL> -- >>> median [3,1,2,4,5] <EOL> -- 3.0 <EOL> -- >>> median [-10,4,6,1000,10,20] <EOL> -- 8.0 <EOL> median :: [Int] -> Double <EOL> median xs =", "gt": "if odd len then fromIntegral (sorted !! (len `div` 2)) else (fromIntegral (sorted !! (len `div` 2 - 1)) + fromIntegral (sorted !! (len `div` 2))) / 2", "prediction": " mean xs / fromIntegral (length xs)"}
{"input": "<s> import Data.List (sort) <EOL> -- Return median of elements in the list l. <EOL> -- >>> median [3,1,2,4,5] <EOL> -- 3.0 <EOL> -- >>> median [-10,4,6,1000,10,20] <EOL> -- 8.0 <EOL> median :: [Int] -> Double <EOL> median xs = if odd len then fromIntegral (sorted !! (len `div` 2)) else (fromIntegral (sorted !! (len `div` 2 - 1)) + fromIntegral (sorted !! (len `div` 2))) / 2 <EOL>   where <EOL>     sorted :: [Int] <EOL>     sorted = sort xs <EOL>     len =", "gt": "length sorted", "prediction": " from sorted"}
{"input": "<s> import Data.List (sort) <EOL> -- Return median of elements in the list l. <EOL> -- >>> median [3,1,2,4,5] <EOL> -- 3.0 <EOL> -- >>> median [-10,4,6,1000,10,20] <EOL> -- 8.0 <EOL> median :: [Int] -> Double <EOL> median xs = if odd len then fromIntegral (sorted !! (len `div` 2)) else", "gt": "(fromIntegral (sorted !! (len `div` 2 - 1)) + fromIntegral (sorted !! (len `div` 2))) / 2", "prediction": " 0.0"}
{"input": "<s> import Numeric (showIntAtBase) <EOL> import Data.Char (intToDigit) <EOL> -- You will be given a number in decimal form and your task is to convert it to <EOL> -- binary format. The function should return a string, with each character representing a binary <EOL> -- number. Each character in the string will be '0' or '1'. <EOL> --  <EOL> -- There will be an extra couple of characters 'db' at the beginning and at the end of the string. <EOL> -- The extra characters are there to help with the format. <EOL> -- <EOL> -- Examples: <EOL> -- decimal_to_binary 15   # returns \"db1111db\" <EOL> -- decimal_to_binary 32   # returns \"db100000db\" <EOL> decimal_to_binary :: Int -> String <EOL> decimal_to_binary decimal =", "gt": "\"db\" ++ showIntAtBase 2 intToDigit decimal \"db\"", "prediction": " let"}
{"input": "<s> -- Given a non-empty list of integers lst. add the even elements that are at odd indices.. <EOL> -- <EOL> -- Examples: <EOL> --     add [4, 2, 6, 7] ==> 2 <EOL> add :: [Int] -> Int <EOL> add lst = <EOL>   sum <EOL>     [ lst !! i <EOL>       | i <-", "gt": "[1, 3 .. (length lst - 1)],", "prediction": " [0 .. (length lst - 1)]"}
{"input": "<s> -- Given a non-empty list of integers lst. add the even elements that are at odd indices.. <EOL> -- <EOL> -- Examples: <EOL> --     add [4, 2, 6, 7] ==> 2 <EOL> add :: [Int] -> Int <EOL> add lst = <EOL>   sum <EOL>     [ lst !! i <EOL>       | i <- [1, 3 ..", "gt": "(length lst - 1)],", "prediction": " (length lst)]"}
{"input": "<s> -- Given a non-empty list of integers lst. add the even elements that are at odd indices.. <EOL> -- <EOL> -- Examples: <EOL> --     add [4, 2, 6, 7] ==> 2 <EOL> add :: [Int] -> Int <EOL> add lst = <EOL>   sum <EOL>     [ lst !! i <EOL>       | i <- [1, 3 .. (length lst - 1)], <EOL>         even", "gt": "(lst !! i)", "prediction": "List"}
{"input": "<s> sum_squares :: [Double] -> Int <EOL> sum_squares lst = sum_squares' lst 0 <EOL>   where <EOL>     sum_squares' [] acc = acc <EOL>     sum_squares' (x : xs) acc = sum_squares' xs (acc + ceiling x ^ 2) <EOL> -- Since Python has no type declarations and only floats, the Haskell implementation cannot be as general as the Python implementation due to strict typing. <EOL> -- Therefore, the Haskell implementation only accepts lists of Doubles, not mixed with Ints. For completeness, here is the implementation for Ints (no need for ceiling): <EOL> sum_squares_int :: [Int] -> Int <EOL> sum_squares_int lst = sum_squares' lst 0 <EOL>   where <EOL>     sum_squares' [] acc =", "gt": "acc", "prediction": " acc"}
{"input": "<s> sum_squares :: [Double] -> Int <EOL> sum_squares lst = sum_squares' lst 0 <EOL>   where <EOL>     sum_squares' [] acc = acc <EOL>     sum_squares' (x : xs) acc = sum_squares' xs (acc + ceiling x ^ 2) <EOL> -- Since Python has no type declarations and only floats, the Haskell implementation cannot be as general as the Python implementation due to strict typing. <EOL> -- Therefore, the Haskell implementation only accepts lists of Doubles, not mixed with Ints. For completeness, here is the implementation for Ints (no need for ceiling): <EOL> sum_squares_int :: [Int] -> Int <EOL> sum_squares_int lst = sum_squares' lst 0 <EOL>   where <EOL>     sum_squares' [] acc = acc <EOL>     sum_squares' (x : xs) acc =", "gt": "sum_squares' xs (acc + x ^ 2)", "prediction": " sum_s squares' xs (acc + ceiling x)"}
{"input": "<s> sum_squares :: [Double] -> Int <EOL> sum_squares lst =", "gt": "sum_squares' lst 0", "prediction": " sum"}
{"input": "<s> sum_squares :: [Double] -> Int <EOL> sum_squares lst = sum_squares' lst 0 <EOL>   where <EOL>     sum_squares' [] acc = acc <EOL>     sum_squares' (x : xs) acc =", "gt": "sum_squares' xs (acc + ceiling x ^ 2)", "prediction": " ("}
{"input": "<s> sum_squares :: [Double] -> Int <EOL> sum_squares lst = sum_squares' lst 0 <EOL>   where <EOL>     sum_squares' [] acc =", "gt": "acc", "prediction": " acc"}
{"input": "<s> import Data.Char <EOL> import Data.List <EOL> import Data.Maybe <EOL> -- Write a function that takes a message, and encodes in such a <EOL> -- way that it swaps case of all letters, replaces all vowels in <EOL> -- the message with the letter that appears 2 places ahead of that <EOL> -- vowel in the english alphabet. <EOL> -- Assume only letters. <EOL> -- <EOL> -- Examples: <EOL> -- >>> encode \"test\" <EOL> -- \"TGST\" <EOL> -- >>> encode \"This is a message\" <EOL> -- \"tHKS KS C MGSSCGG\" <EOL> encode :: String -> String <EOL> encode message = <EOL>   let vowels = \"aeiouAEIOU\" <EOL>       vowels_replace = <EOL>         zip <EOL>           vowels <EOL>           ( map <EOL>               (\\x -> chr (ord x + 2)) <EOL>               vowels <EOL>           ) <EOL>       message' = <EOL>         map <EOL>           ( \\x -> <EOL>               if isUpper x <EOL>                 then toLower x <EOL>                 else toUpper x <EOL>           ) <EOL>           message <EOL>    in map <EOL>         ( \\x -> <EOL>             if x `elem` vowels <EOL>               then (fromJust (lookup x vowels_replace)) <EOL>               else", "gt": "x", "prediction": " tofromJust (lookup x vowels_replace)))"}
{"input": "<s> import Data.Char <EOL> import Data.List <EOL> import Data.Maybe <EOL> -- Write a function that takes a message, and encodes in such a <EOL> -- way that it swaps case of all letters, replaces all vowels in <EOL> -- the message with the letter that appears 2 places ahead of that <EOL> -- vowel in the english alphabet. <EOL> -- Assume only letters. <EOL> -- <EOL> -- Examples: <EOL> -- >>> encode \"test\" <EOL> -- \"TGST\" <EOL> -- >>> encode \"This is a message\" <EOL> -- \"tHKS KS C MGSSCGG\" <EOL> encode :: String -> String <EOL> encode message = <EOL>   let vowels =", "gt": "\"aeiouAEIOU\"", "prediction": " \"aeiou\""}
{"input": "<s> import Data.Char <EOL> import Data.List <EOL> import Data.Maybe <EOL> -- Write a function that takes a message, and encodes in such a <EOL> -- way that it swaps case of all letters, replaces all vowels in <EOL> -- the message with the letter that appears 2 places ahead of that <EOL> -- vowel in the english alphabet. <EOL> -- Assume only letters. <EOL> -- <EOL> -- Examples: <EOL> -- >>> encode \"test\" <EOL> -- \"TGST\" <EOL> -- >>> encode \"This is a message\" <EOL> -- \"tHKS KS C MGSSCGG\" <EOL> encode :: String -> String <EOL> encode message = <EOL>   let vowels = \"aeiouAEIOU\" <EOL>       vowels_replace = <EOL>         zip <EOL>           vowels <EOL>           ( map <EOL>               (\\x ->", "gt": "chr (ord x + 2))", "prediction": " if x `elem` vowels"}
{"input": "<s> import Data.Char <EOL> import Data.List <EOL> import Data.Maybe <EOL> -- Write a function that takes a message, and encodes in such a <EOL> -- way that it swaps case of all letters, replaces all vowels in <EOL> -- the message with the letter that appears 2 places ahead of that <EOL> -- vowel in the english alphabet. <EOL> -- Assume only letters. <EOL> -- <EOL> -- Examples: <EOL> -- >>> encode \"test\" <EOL> -- \"TGST\" <EOL> -- >>> encode \"This is a message\" <EOL> -- \"tHKS KS C MGSSCGG\" <EOL> encode :: String -> String <EOL> encode message = <EOL>   let vowels = \"aeiouAEIOU\" <EOL>       vowels_replace = <EOL>         zip <EOL>           vowels <EOL>           ( map <EOL>               (\\x -> chr (ord x + 2)) <EOL>               vowels <EOL>           ) <EOL>       message' = <EOL>         map <EOL>           ( \\x -> <EOL>               if isUpper x <EOL>                 then toLower x <EOL>                 else", "gt": "toUpper x", "prediction": " x"}
{"input": "<s> import Data.Char <EOL> import Data.List <EOL> import Data.Maybe <EOL> -- Write a function that takes a message, and encodes in such a <EOL> -- way that it swaps case of all letters, replaces all vowels in <EOL> -- the message with the letter that appears 2 places ahead of that <EOL> -- vowel in the english alphabet. <EOL> -- Assume only letters. <EOL> -- <EOL> -- Examples: <EOL> -- >>> encode \"test\" <EOL> -- \"TGST\" <EOL> -- >>> encode \"This is a message\" <EOL> -- \"tHKS KS C MGSSCGG\" <EOL> encode :: String -> String <EOL> encode message = <EOL>   let vowels = \"aeiouAEIOU\" <EOL>       vowels_replace = <EOL>         zip <EOL>           vowels <EOL>           ( map <EOL>               (\\x -> chr (ord x + 2)) <EOL>               vowels <EOL>           ) <EOL>       message' = <EOL>         map <EOL>           ( \\x -> <EOL>               if isUpper x <EOL>                 then toLower x <EOL>                 else toUpper x <EOL>           ) <EOL>           message <EOL>    in map <EOL>         ( \\x -> <EOL>             if x `elem` vowels <EOL>               then", "gt": "(fromJust (lookup x vowels_replace))", "prediction": " toUpper x"}
{"input": "<s> import Data.Char <EOL> import Data.List <EOL> import Numeric <EOL> -- In this Kata, you have to sort an array of non-negative integers according to <EOL> -- number of ones in their binary representation in ascending order. <EOL> -- For similar number of ones, sort based on decimal value. <EOL> -- <EOL> -- It must be implemented like this: <EOL> -- >>> sort_array [1, 5, 2, 3, 4] == [1, 2, 3, 4, 5] <EOL> -- >>> sort_array [-2, -3, -4, -5, -6] == [-6, -5, -4, -3, -2] <EOL> -- >>> sort_array [1, 0, 2, 3, 4] [0, 1, 2, 3, 4] <EOL> sort_array :: [Int] -> [Int] <EOL> sort_array arr = sortBy g arr <EOL>   where <EOL>     f x y = compare", "gt": "(countOnes $ abs x) (countOnes $ abs y)", "prediction": " (f x) (f y)"}
{"input": "<s> import Data.Char <EOL> import Data.List <EOL> import Numeric <EOL> -- In this Kata, you have to sort an array of non-negative integers according to <EOL> -- number of ones in their binary representation in ascending order. <EOL> -- For similar number of ones, sort based on decimal value. <EOL> -- <EOL> -- It must be implemented like this: <EOL> -- >>> sort_array [1, 5, 2, 3, 4] == [1, 2, 3, 4, 5] <EOL> -- >>> sort_array [-2, -3, -4, -5, -6] == [-6, -5, -4, -3, -2] <EOL> -- >>> sort_array [1, 0, 2, 3, 4] [0, 1, 2, 3, 4] <EOL> sort_array :: [Int] -> [Int] <EOL> sort_array arr = sortBy g arr <EOL>   where <EOL>     f x y = compare (countOnes $ abs x) (countOnes $ abs y) <EOL>     g x y = <EOL>       if (f x y) /= EQ <EOL>         then (f x y) <EOL>         else (compare x y) <EOL>     countOnes x = <EOL>       length $ <EOL>         filter", "gt": "(== '1') $", "prediction": "_x, y)"}
{"input": "<s> import Data.Char <EOL> import Data.List <EOL> import Numeric <EOL> -- In this Kata, you have to sort an array of non-negative integers according to <EOL> -- number of ones in their binary representation in ascending order. <EOL> -- For similar number of ones, sort based on decimal value. <EOL> -- <EOL> -- It must be implemented like this: <EOL> -- >>> sort_array [1, 5, 2, 3, 4] == [1, 2, 3, 4, 5] <EOL> -- >>> sort_array [-2, -3, -4, -5, -6] == [-6, -5, -4, -3, -2] <EOL> -- >>> sort_array [1, 0, 2, 3, 4] [0, 1, 2, 3, 4] <EOL> sort_array :: [Int] -> [Int] <EOL> sort_array arr = sortBy g arr <EOL>   where <EOL>     f x y = compare (countOnes $ abs x) (countOnes $ abs y) <EOL>     g x y = <EOL>       if (f x y) /= EQ <EOL>         then (f x y) <EOL>         else", "gt": "(compare x y)", "prediction": " ( x y"}
{"input": "<s> import Data.Char <EOL> import Data.List <EOL> import Numeric <EOL> -- In this Kata, you have to sort an array of non-negative integers according to <EOL> -- number of ones in their binary representation in ascending order. <EOL> -- For similar number of ones, sort based on decimal value. <EOL> -- <EOL> -- It must be implemented like this: <EOL> -- >>> sort_array [1, 5, 2, 3, 4] == [1, 2, 3, 4, 5] <EOL> -- >>> sort_array [-2, -3, -4, -5, -6] == [-6, -5, -4, -3, -2] <EOL> -- >>> sort_array [1, 0, 2, 3, 4] [0, 1, 2, 3, 4] <EOL> sort_array :: [Int] -> [Int] <EOL> sort_array arr = sortBy g arr <EOL>   where <EOL>     f x y = compare (countOnes $ abs x)", "gt": "(countOnes $ abs y)", "prediction": " (abs y)"}
{"input": "<s> import Data.Char <EOL> import Data.List <EOL> import Numeric <EOL> -- In this Kata, you have to sort an array of non-negative integers according to <EOL> -- number of ones in their binary representation in ascending order. <EOL> -- For similar number of ones, sort based on decimal value. <EOL> -- <EOL> -- It must be implemented like this: <EOL> -- >>> sort_array [1, 5, 2, 3, 4] == [1, 2, 3, 4, 5] <EOL> -- >>> sort_array [-2, -3, -4, -5, -6] == [-6, -5, -4, -3, -2] <EOL> -- >>> sort_array [1, 0, 2, 3, 4] [0, 1, 2, 3, 4] <EOL> sort_array :: [Int] -> [Int] <EOL> sort_array arr = sortBy g arr <EOL>   where <EOL>     f x y = compare (countOnes $ abs x) (countOnes $ abs y) <EOL>     g x y = <EOL>       if (f x y) /= EQ <EOL>         then", "gt": "(f x y)", "prediction": " if"}
{"input": "<s> -- Write a function that returns True if the object q will fly, and False otherwise. <EOL> -- The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w. <EOL> -- <EOL> -- Example: <EOL> -- will_it_fly [1, 2] 5 == False <EOL> -- 1+2 is less than the maximum possible weight, but it's unbalanced. <EOL> -- <EOL> -- will_it_fly [3, 2, 3] 1 == False <EOL> -- it's balanced, but 3+2+3 is more than the maximum possible weight. <EOL> -- <EOL> -- will_it_fly [3, 2, 3] 9 == True <EOL> -- 3+2+3 is less than the maximum possible weight, and it's balanced. <EOL> -- <EOL> -- will_it_fly [3] 5 == True <EOL> -- 3 is less than the maximum possible weight, and it's balanced. <EOL> will_it_fly :: [Int] -> Int -> Bool <EOL> will_it_fly q w = sum q <= w && q ==", "gt": "reverse q", "prediction": " qw]"}
{"input": "<s> -- Write a function that returns True if the object q will fly, and False otherwise. <EOL> -- The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w. <EOL> -- <EOL> -- Example: <EOL> -- will_it_fly [1, 2] 5 == False <EOL> -- 1+2 is less than the maximum possible weight, but it's unbalanced. <EOL> -- <EOL> -- will_it_fly [3, 2, 3] 1 == False <EOL> -- it's balanced, but 3+2+3 is more than the maximum possible weight. <EOL> -- <EOL> -- will_it_fly [3, 2, 3] 9 == True <EOL> -- 3+2+3 is less than the maximum possible weight, and it's balanced. <EOL> -- <EOL> -- will_it_fly [3] 5 == True <EOL> -- 3 is less than the maximum possible weight, and it's balanced. <EOL> will_it_fly :: [Int] -> Int -> Bool <EOL> will_it_fly q w =", "gt": "sum q <= w && q == reverse q", "prediction": " sum"}
{"input": "<s> -- Create a function that returns a tuple (a, b), where 'a' is <EOL> -- the largest of negative integers, and 'b' is the smallest <EOL> -- of positive integers in a list. <EOL> -- If there is no negative or positive integers, return them as None. <EOL> -- <EOL> -- Examples: <EOL> -- >>> largest_smallest_integers [2, 4, 1, 3, 5, 7] <EOL> -- (Nothing,Just 1) <EOL> -- >>> largest_smallest_integers [] <EOL> -- (Nothing,Nothing) <EOL> -- >>> largest_smallest_integers [0] <EOL> -- (Nothing,Nothing) <EOL> import Data.Maybe <EOL> largest_smallest_integers :: [Int] -> (Maybe Int, Maybe Int) <EOL> largest_smallest_integers [] = (Nothing, Nothing) <EOL> largest_smallest_integers arr = largest_smallest_integers' arr Nothing Nothing <EOL>   where <EOL>     largest_smallest_integers' :: [Int] -> Maybe Int -> Maybe Int -> (Maybe Int, Maybe Int) <EOL>     largest_smallest_integers' [] largest smallest = (largest, smallest) <EOL>     largest_smallest_integers' (x : xs) largest smallest <EOL>       | x < 0 && isNothing largest = largest_smallest_integers' xs (Just x) smallest <EOL>       | x < 0 = largest_smallest_integers' xs (Just (max (fromJust largest) x)) smallest <EOL>       | x > 0 && isNothing smallest = largest_smallest_integers' xs largest (Just x) <EOL>       | x > 0 = largest_smallest_integers' xs largest (Just (min (fromJust smallest) x)) <EOL>       | otherwise = largest_smallest_integers' xs largest smallest <EOL> -- Alternative using fold: <EOL> largest_smallest_integers_fold :: [Int] -> (Maybe Int, Maybe Int) <EOL> largest_smallest_integers_fold [] = (Nothing, Nothing) <EOL> largest_smallest_integers_fold arr =", "gt": "foldl largest_smallest_integers_fold' (Nothing, Nothing) arr", "prediction": " largest_smasi"}
{"input": "<s> -- Create a function that returns a tuple (a, b), where 'a' is <EOL> -- the largest of negative integers, and 'b' is the smallest <EOL> -- of positive integers in a list. <EOL> -- If there is no negative or positive integers, return them as None. <EOL> -- <EOL> -- Examples: <EOL> -- >>> largest_smallest_integers [2, 4, 1, 3, 5, 7] <EOL> -- (Nothing,Just 1) <EOL> -- >>> largest_smallest_integers [] <EOL> -- (Nothing,Nothing) <EOL> -- >>> largest_smallest_integers [0] <EOL> -- (Nothing,Nothing) <EOL> import Data.Maybe <EOL> largest_smallest_integers :: [Int] -> (Maybe Int, Maybe Int) <EOL> largest_smallest_integers [] = (Nothing, Nothing) <EOL> largest_smallest_integers arr = largest_smallest_integers' arr Nothing Nothing <EOL>   where <EOL>     largest_smallest_integers' :: [Int] -> Maybe Int -> Maybe Int -> (Maybe Int, Maybe Int) <EOL>     largest_smallest_integers' [] largest smallest = (largest, smallest) <EOL>     largest_smallest_integers' (x : xs) largest smallest <EOL>       | x < 0 && isNothing largest = largest_smallest_integers' xs (Just x) smallest <EOL>       | x < 0 =", "gt": "largest_smallest_integers' xs (Just (max (fromJust largest) x)) smallest", "prediction": " smallest"}
{"input": "<s> -- Create a function that returns a tuple (a, b), where 'a' is <EOL> -- the largest of negative integers, and 'b' is the smallest <EOL> -- of positive integers in a list. <EOL> -- If there is no negative or positive integers, return them as None. <EOL> -- <EOL> -- Examples: <EOL> -- >>> largest_smallest_integers [2, 4, 1, 3, 5, 7] <EOL> -- (Nothing,Just 1) <EOL> -- >>> largest_smallest_integers [] <EOL> -- (Nothing,Nothing) <EOL> -- >>> largest_smallest_integers [0] <EOL> -- (Nothing,Nothing) <EOL> import Data.Maybe <EOL> largest_smallest_integers :: [Int] -> (Maybe Int, Maybe Int) <EOL> largest_smallest_integers [] = (Nothing, Nothing) <EOL> largest_smallest_integers arr = largest_smallest_integers' arr Nothing Nothing <EOL>   where <EOL>     largest_smallest_integers' :: [Int] -> Maybe Int -> Maybe Int -> (Maybe Int, Maybe Int) <EOL>     largest_smallest_integers' [] largest smallest = (largest, smallest) <EOL>     largest_smallest_integers' (x : xs) largest smallest <EOL>       | x < 0 && isNothing largest = largest_smallest_integers' xs (Just x) smallest <EOL>       | x < 0 = largest_smallest_integers' xs (Just (max (fromJust largest) x)) smallest <EOL>       | x > 0 && isNothing smallest = largest_smallest_integers' xs largest (Just x) <EOL>       | x > 0 = largest_smallest_integers' xs largest (Just (min (fromJust smallest) x)) <EOL>       | otherwise = largest_smallest_integers' xs largest smallest <EOL> -- Alternative using fold: <EOL> largest_smallest_integers_fold :: [Int] -> (Maybe Int, Maybe Int) <EOL> largest_smallest_integers_fold [] = (Nothing, Nothing) <EOL> largest_smallest_integers_fold arr = foldl largest_smallest_integers_fold' (Nothing, Nothing) arr <EOL>   where <EOL>     largest_smallest_integers_fold' :: (Maybe Int, Maybe Int) -> Int -> (Maybe Int, Maybe Int) <EOL>     largest_smallest_integers_fold' (largest, smallest) x <EOL>       | x < 0 && isNothing largest = (Just x, smallest) <EOL>       | x < 0 = (Just (max (fromJust largest) x), smallest) <EOL>       | x > 0 && isNothing smallest = (largest, Just x) <EOL>       | x > 0 = (largest, Just (min (fromJust smallest) x)) <EOL>       | otherwise =", "gt": "(largest, smallest)", "prediction": " smallest"}
{"input": "<s> -- Create a function that returns a tuple (a, b), where 'a' is <EOL> -- the largest of negative integers, and 'b' is the smallest <EOL> -- of positive integers in a list. <EOL> -- If there is no negative or positive integers, return them as None. <EOL> -- <EOL> -- Examples: <EOL> -- >>> largest_smallest_integers [2, 4, 1, 3, 5, 7] <EOL> -- (Nothing,Just 1) <EOL> -- >>> largest_smallest_integers [] <EOL> -- (Nothing,Nothing) <EOL> -- >>> largest_smallest_integers [0] <EOL> -- (Nothing,Nothing) <EOL> import Data.Maybe <EOL> largest_smallest_integers :: [Int] -> (Maybe Int, Maybe Int) <EOL> largest_smallest_integers [] = (Nothing, Nothing) <EOL> largest_smallest_integers arr = largest_smallest_integers' arr Nothing Nothing <EOL>   where <EOL>     largest_smallest_integers' :: [Int] -> Maybe Int -> Maybe Int -> (Maybe Int, Maybe Int) <EOL>     largest_smallest_integers' [] largest smallest = (largest, smallest) <EOL>     largest_smallest_integers' (x : xs) largest smallest <EOL>       | x < 0 && isNothing largest = largest_smallest_integers' xs (Just x) smallest <EOL>       | x < 0 = largest_smallest_integers' xs (Just (max (fromJust largest) x)) smallest <EOL>       | x > 0 && isNothing smallest = largest_smallest_integers' xs largest (Just x) <EOL>       | x > 0 = largest_smallest_integers' xs largest (Just (min (fromJust smallest) x)) <EOL>       | otherwise = largest_smallest_integers' xs largest smallest <EOL> -- Alternative using fold: <EOL> largest_smallest_integers_fold :: [Int] -> (Maybe Int, Maybe Int) <EOL> largest_smallest_integers_fold [] = (Nothing, Nothing) <EOL> largest_smallest_integers_fold arr = foldl largest_smallest_integers_fold' (Nothing, Nothing) arr <EOL>   where <EOL>     largest_smallest_integers_fold' :: (Maybe Int, Maybe Int) -> Int -> (Maybe Int, Maybe Int) <EOL>     largest_smallest_integers_fold' (largest, smallest) x <EOL>       | x < 0 && isNothing largest = (Just x, smallest) <EOL>       | x < 0 = (Just (max (fromJust largest) x), smallest) <EOL>       | x > 0 && isNothing smallest =", "gt": "(largest, Just x)", "prediction": " (Just (min (fromJust smallest) x), smallest)"}
{"input": "<s> -- Create a function that returns a tuple (a, b), where 'a' is <EOL> -- the largest of negative integers, and 'b' is the smallest <EOL> -- of positive integers in a list. <EOL> -- If there is no negative or positive integers, return them as None. <EOL> -- <EOL> -- Examples: <EOL> -- >>> largest_smallest_integers [2, 4, 1, 3, 5, 7] <EOL> -- (Nothing,Just 1) <EOL> -- >>> largest_smallest_integers [] <EOL> -- (Nothing,Nothing) <EOL> -- >>> largest_smallest_integers [0] <EOL> -- (Nothing,Nothing) <EOL> import Data.Maybe <EOL> largest_smallest_integers :: [Int] -> (Maybe Int, Maybe Int) <EOL> largest_smallest_integers [] = (Nothing, Nothing) <EOL> largest_smallest_integers arr = largest_smallest_integers' arr Nothing Nothing <EOL>   where <EOL>     largest_smallest_integers' :: [Int] -> Maybe Int -> Maybe Int -> (Maybe Int, Maybe Int) <EOL>     largest_smallest_integers' [] largest smallest = (largest, smallest) <EOL>     largest_smallest_integers' (x : xs) largest smallest <EOL>       | x < 0 && isNothing largest = largest_smallest_integers' xs (Just x) smallest <EOL>       | x < 0 = largest_smallest_integers' xs (Just", "gt": "(max (fromJust largest) x)) smallest", "prediction": " smallest) largest"}
{"input": "<s> -- Return list of prime factors of given integer in the order from smallest to largest. <EOL> -- Each of the factors should be listed number of times corresponding to how many times it appeares in factorization. <EOL> -- Input number should be equal to the product of all factors <EOL> -- >>> factorize 8 <EOL> -- [2,2,2] <EOL> -- >>> factorize 25 <EOL> -- [5,5] <EOL> -- >>> factorize 70 <EOL> -- [2,5,7] <EOL> factorize :: Int -> [Int] <EOL> factorize n = factorize' n 2 <EOL>     where <EOL>         factorize' :: Int -> Int -> [Int] <EOL>         factorize' n i <EOL>             | i * i > n = [n] <EOL>             | n `mod` i == 0 = i : factorize' (n `div` i) i <EOL>             | otherwise = factorize' n", "gt": "(i + 1)", "prediction": " (i + 1) (i - 1)"}
{"input": "<s> -- Return list of prime factors of given integer in the order from smallest to largest. <EOL> -- Each of the factors should be listed number of times corresponding to how many times it appeares in factorization. <EOL> -- Input number should be equal to the product of all factors <EOL> -- >>> factorize 8 <EOL> -- [2,2,2] <EOL> -- >>> factorize 25 <EOL> -- [5,5] <EOL> -- >>> factorize 70 <EOL> -- [2,5,7] <EOL> factorize :: Int -> [Int] <EOL> factorize n = factorize' n 2 <EOL>     where <EOL>         factorize' :: Int -> Int -> [Int] <EOL>         factorize' n i <EOL>             | i * i > n = [n] <EOL>             | n `mod` i == 0 = i : factorize' (n `div` i) i <EOL>             | otherwise =", "gt": "factorize' n (i + 1)", "prediction": " []"}
{"input": "<s> -- Return list of prime factors of given integer in the order from smallest to largest. <EOL> -- Each of the factors should be listed number of times corresponding to how many times it appeares in factorization. <EOL> -- Input number should be equal to the product of all factors <EOL> -- >>> factorize 8 <EOL> -- [2,2,2] <EOL> -- >>> factorize 25 <EOL> -- [5,5] <EOL> -- >>> factorize 70 <EOL> -- [2,5,7] <EOL> factorize :: Int -> [Int] <EOL> factorize n = factorize' n 2 <EOL>     where <EOL>         factorize' :: Int -> Int -> [Int] <EOL>         factorize' n i <EOL>             | i * i > n = [n] <EOL>             | n `mod` i == 0 =", "gt": "i : factorize' (n `div` i) i", "prediction": " ["}
{"input": "<s> -- Return list of prime factors of given integer in the order from smallest to largest. <EOL> -- Each of the factors should be listed number of times corresponding to how many times it appeares in factorization. <EOL> -- Input number should be equal to the product of all factors <EOL> -- >>> factorize 8 <EOL> -- [2,2,2] <EOL> -- >>> factorize 25 <EOL> -- [5,5] <EOL> -- >>> factorize 70 <EOL> -- [2,5,7] <EOL> factorize :: Int -> [Int] <EOL> factorize n = factorize' n 2 <EOL>     where <EOL>         factorize' :: Int -> Int -> [Int] <EOL>         factorize' n i <EOL>             | i * i > n =", "gt": "[n]", "prediction": " []"}
{"input": "<s> -- Return list of prime factors of given integer in the order from smallest to largest. <EOL> -- Each of the factors should be listed number of times corresponding to how many times it appeares in factorization. <EOL> -- Input number should be equal to the product of all factors <EOL> -- >>> factorize 8 <EOL> -- [2,2,2] <EOL> -- >>> factorize 25 <EOL> -- [5,5] <EOL> -- >>> factorize 70 <EOL> -- [2,5,7] <EOL> factorize :: Int -> [Int] <EOL> factorize n = factorize' n 2 <EOL>     where <EOL>         factorize' :: Int -> Int -> [Int] <EOL>         factorize' n i <EOL>             | i * i > n = [n] <EOL>             | n `mod` i == 0 = i :", "gt": "factorize' (n `div` i) i", "prediction": " (ize' (n `div` i) (i + 1)"}
{"input": "<s> -- You are given a positive integer n. You have to create an integer array a of length n. <EOL> --     For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1. <EOL> --     Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, <EOL> -- and a[i] + a[j] + a[k] is a multiple of 3. <EOL> -- <EOL> -- Example : <EOL> -- >>> get_max_triples 5 <EOL> -- 1 <EOL> -- Explanation: <EOL> -- a = [1, 3, 7, 13, 21] <EOL> -- The only valid triple is (1, 7, 13). <EOL> get_max_triples :: Int -> Int <EOL> get_max_triples n = length $ filter (\\(x, y, z) -> (x + y + z) `mod` 3 == 0) [(a !! i, a !! j, a !! k) | i <- [0 .. n - 1], j <- [i + 1 .. n - 1], k <- [j + 1 .. n - 1]] <EOL>   where <EOL>     a :: [Int] <EOL>     a = [i * i - i + 1 |", "gt": "i <- [1 .. n]]", "prediction": " i <- [0 .. n - 1], j <- [i + 1 .. n - 1], k <- [j + 1 .. n - 1]]"}
{"input": "<s> -- You are given a positive integer n. You have to create an integer array a of length n. <EOL> --     For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1. <EOL> --     Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, <EOL> -- and a[i] + a[j] + a[k] is a multiple of 3. <EOL> -- <EOL> -- Example : <EOL> -- >>> get_max_triples 5 <EOL> -- 1 <EOL> -- Explanation: <EOL> -- a = [1, 3, 7, 13, 21] <EOL> -- The only valid triple is (1, 7, 13). <EOL> get_max_triples :: Int -> Int <EOL> get_max_triples n = length $ filter (\\(x, y, z) -> (x + y + z) `mod` 3 == 0) [(a !! i, a !! j, a !! k) | i <- [0 .. n - 1], j <- [i + 1 .. n - 1], k <-", "gt": "[j + 1 .. n - 1]]", "prediction": " [i + 1 .. n - 1]]"}
{"input": "<s> -- You are given a positive integer n. You have to create an integer array a of length n. <EOL> --     For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1. <EOL> --     Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, <EOL> -- and a[i] + a[j] + a[k] is a multiple of 3. <EOL> -- <EOL> -- Example : <EOL> -- >>> get_max_triples 5 <EOL> -- 1 <EOL> -- Explanation: <EOL> -- a = [1, 3, 7, 13, 21] <EOL> -- The only valid triple is (1, 7, 13). <EOL> get_max_triples :: Int -> Int <EOL> get_max_triples n = length $ filter (\\(x, y, z) -> (x + y + z) `mod` 3 == 0) [(a !! i, a !! j, a !! k) | i <- [0 .. n - 1], j <-", "gt": "[i + 1 .. n - 1], k <- [j + 1 .. n - 1]]", "prediction": " [0 .. n - 1], k <- [0 .. n - 1]]"}
{"input": "<s> -- You are given a positive integer n. You have to create an integer array a of length n. <EOL> --     For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1. <EOL> --     Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, <EOL> -- and a[i] + a[j] + a[k] is a multiple of 3. <EOL> -- <EOL> -- Example : <EOL> -- >>> get_max_triples 5 <EOL> -- 1 <EOL> -- Explanation: <EOL> -- a = [1, 3, 7, 13, 21] <EOL> -- The only valid triple is (1, 7, 13). <EOL> get_max_triples :: Int -> Int <EOL> get_max_triples n =", "gt": "length $ filter (\\(x, y, z) -> (x + y + z) `mod` 3 == 0) [(a !! i, a !! j, a !! k) | i <- [0 .. n - 1], j <- [i + 1 .. n - 1], k <- [j + 1 .. n - 1]]", "prediction": " ("}
{"input": "<s> -- You are given a positive integer n. You have to create an integer array a of length n. <EOL> --     For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1. <EOL> --     Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, <EOL> -- and a[i] + a[j] + a[k] is a multiple of 3. <EOL> -- <EOL> -- Example : <EOL> -- >>> get_max_triples 5 <EOL> -- 1 <EOL> -- Explanation: <EOL> -- a = [1, 3, 7, 13, 21] <EOL> -- The only valid triple is (1, 7, 13). <EOL> get_max_triples :: Int -> Int <EOL> get_max_triples n = length $ filter (\\(x, y, z) -> (x + y + z) `mod` 3 == 0) [(a !! i, a !! j, a !! k) | i <- [0 .. n - 1], j <- [i + 1 .. n - 1], k <- [j + 1 .. n - 1]] <EOL>   where <EOL>     a :: [Int] <EOL>     a =", "gt": "[i * i - i + 1 | i <- [1 .. n]]", "prediction": " [a !! i, a !! j, a !! k]"}
{"input": "<s> -- We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The <EOL> -- numbers in the array will be randomly ordered. Your task is to determine if <EOL> -- it is possible to get an array sorted in non-decreasing order by performing <EOL> -- the following operation on the given array: <EOL> --     You are allowed to perform right shift operation any number of times. <EOL> -- <EOL> -- One right shift operation means shifting all elements of the array by one <EOL> -- position in the right direction. The last element of the array will be moved to <EOL> -- the starting position in the array i.e. 0th index. <EOL> -- <EOL> -- If it is possible to obtain the sorted array by performing the above operation <EOL> -- then return True else return False. <EOL> -- If the given array is empty then return True. <EOL> -- <EOL> -- Note: The given list is guaranteed to have unique elements. <EOL> -- <EOL> -- For Example: <EOL> -- <EOL> -- move_one_ball [3, 4, 5, 1, 2] ==>True <EOL> -- Explanation: By performin 2 right shift operations, non-decreasing order can <EOL> --              be achieved for the given array. <EOL> -- move_one_ball [3, 5, 4, 1, 2] ==>False <EOL> -- Explanation:It is not possible to get non-decreasing order for the given <EOL> --             array by performing any number of right shift operations. <EOL> import Data.List (sort) <EOL> move_one_ball :: (Ord a) => [a] -> Bool <EOL> move_one_ball [] = True <EOL> move_one_ball arr = any (\\i -> rotate i arr == sort arr) [0 ..", "gt": "length arr - 1]", "prediction": " length arr - 1]"}
{"input": "<s> -- We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The <EOL> -- numbers in the array will be randomly ordered. Your task is to determine if <EOL> -- it is possible to get an array sorted in non-decreasing order by performing <EOL> -- the following operation on the given array: <EOL> --     You are allowed to perform right shift operation any number of times. <EOL> -- <EOL> -- One right shift operation means shifting all elements of the array by one <EOL> -- position in the right direction. The last element of the array will be moved to <EOL> -- the starting position in the array i.e. 0th index. <EOL> -- <EOL> -- If it is possible to obtain the sorted array by performing the above operation <EOL> -- then return True else return False. <EOL> -- If the given array is empty then return True. <EOL> -- <EOL> -- Note: The given list is guaranteed to have unique elements. <EOL> -- <EOL> -- For Example: <EOL> -- <EOL> -- move_one_ball [3, 4, 5, 1, 2] ==>True <EOL> -- Explanation: By performin 2 right shift operations, non-decreasing order can <EOL> --              be achieved for the given array. <EOL> -- move_one_ball [3, 5, 4, 1, 2] ==>False <EOL> -- Explanation:It is not possible to get non-decreasing order for the given <EOL> --             array by performing any number of right shift operations. <EOL> import Data.List (sort) <EOL> move_one_ball :: (Ord a) => [a] -> Bool <EOL> move_one_ball [] = True <EOL> move_one_ball arr = any (\\i -> rotate i arr ==", "gt": "sort arr) [0 .. length arr - 1]", "prediction": " i) [1..length arr]"}
{"input": "<s> -- We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The <EOL> -- numbers in the array will be randomly ordered. Your task is to determine if <EOL> -- it is possible to get an array sorted in non-decreasing order by performing <EOL> -- the following operation on the given array: <EOL> --     You are allowed to perform right shift operation any number of times. <EOL> -- <EOL> -- One right shift operation means shifting all elements of the array by one <EOL> -- position in the right direction. The last element of the array will be moved to <EOL> -- the starting position in the array i.e. 0th index. <EOL> -- <EOL> -- If it is possible to obtain the sorted array by performing the above operation <EOL> -- then return True else return False. <EOL> -- If the given array is empty then return True. <EOL> -- <EOL> -- Note: The given list is guaranteed to have unique elements. <EOL> -- <EOL> -- For Example: <EOL> -- <EOL> -- move_one_ball [3, 4, 5, 1, 2] ==>True <EOL> -- Explanation: By performin 2 right shift operations, non-decreasing order can <EOL> --              be achieved for the given array. <EOL> -- move_one_ball [3, 5, 4, 1, 2] ==>False <EOL> -- Explanation:It is not possible to get non-decreasing order for the given <EOL> --             array by performing any number of right shift operations. <EOL> import Data.List (sort) <EOL> move_one_ball :: (Ord a) => [a] -> Bool <EOL> move_one_ball [] = True <EOL> move_one_ball arr = any (\\i -> rotate i arr == sort arr) [0 .. length arr - 1] <EOL>   where <EOL>     rotate n xs = drop n xs ++", "gt": "take n xs", "prediction": " take n xs"}
{"input": "<s> -- We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The <EOL> -- numbers in the array will be randomly ordered. Your task is to determine if <EOL> -- it is possible to get an array sorted in non-decreasing order by performing <EOL> -- the following operation on the given array: <EOL> --     You are allowed to perform right shift operation any number of times. <EOL> -- <EOL> -- One right shift operation means shifting all elements of the array by one <EOL> -- position in the right direction. The last element of the array will be moved to <EOL> -- the starting position in the array i.e. 0th index. <EOL> -- <EOL> -- If it is possible to obtain the sorted array by performing the above operation <EOL> -- then return True else return False. <EOL> -- If the given array is empty then return True. <EOL> -- <EOL> -- Note: The given list is guaranteed to have unique elements. <EOL> -- <EOL> -- For Example: <EOL> -- <EOL> -- move_one_ball [3, 4, 5, 1, 2] ==>True <EOL> -- Explanation: By performin 2 right shift operations, non-decreasing order can <EOL> --              be achieved for the given array. <EOL> -- move_one_ball [3, 5, 4, 1, 2] ==>False <EOL> -- Explanation:It is not possible to get non-decreasing order for the given <EOL> --             array by performing any number of right shift operations. <EOL> import Data.List (sort) <EOL> move_one_ball :: (Ord a) => [a] -> Bool <EOL> move_one_ball [] = True <EOL> move_one_ball arr = any (\\i -> rotate i arr == sort arr) [0 .. length arr - 1] <EOL>   where <EOL>     rotate n xs =", "gt": "drop n xs ++ take n xs", "prediction": " if"}
{"input": "<s> -- We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The <EOL> -- numbers in the array will be randomly ordered. Your task is to determine if <EOL> -- it is possible to get an array sorted in non-decreasing order by performing <EOL> -- the following operation on the given array: <EOL> --     You are allowed to perform right shift operation any number of times. <EOL> -- <EOL> -- One right shift operation means shifting all elements of the array by one <EOL> -- position in the right direction. The last element of the array will be moved to <EOL> -- the starting position in the array i.e. 0th index. <EOL> -- <EOL> -- If it is possible to obtain the sorted array by performing the above operation <EOL> -- then return True else return False. <EOL> -- If the given array is empty then return True. <EOL> -- <EOL> -- Note: The given list is guaranteed to have unique elements. <EOL> -- <EOL> -- For Example: <EOL> -- <EOL> -- move_one_ball [3, 4, 5, 1, 2] ==>True <EOL> -- Explanation: By performin 2 right shift operations, non-decreasing order can <EOL> --              be achieved for the given array. <EOL> -- move_one_ball [3, 5, 4, 1, 2] ==>False <EOL> -- Explanation:It is not possible to get non-decreasing order for the given <EOL> --             array by performing any number of right shift operations. <EOL> import Data.List (sort) <EOL> move_one_ball :: (Ord a) => [a] -> Bool <EOL> move_one_ball [] = True <EOL> move_one_ball arr = any (\\i ->", "gt": "rotate i arr == sort arr) [0 .. length arr - 1]", "prediction": " ("}
{"input": "<s> -- Checks if given string is a palindrome <EOL> -- >>> is_palindrome \"\" <EOL> -- True <EOL> -- >>> is_palindrome \"aba\" <EOL> -- True <EOL> -- >>> is_palindrome \"aaaaa\" <EOL> -- True <EOL> -- >>> is_palindrome \"zbcd\" <EOL> -- False <EOL> is_palindrome :: String -> Bool <EOL> is_palindrome =", "gt": "(==) <*> reverse", "prediction": " not isAlpha"}
{"input": "<s> -- Input are two strings a and b consisting only of 1s and 0s. <EOL> -- Perform binary XOR on these inputs and return result also as a string. <EOL> -- >>> string_xor \"010\" \"110\" <EOL> -- \"100\" <EOL> string_xor :: String -> String -> String <EOL> string_xor a b = [if x == y then '0' else '1' | (x, y) <-", "gt": "zip a b]", "prediction": " zip a b]"}
{"input": "<s> -- Input are two strings a and b consisting only of 1s and 0s. <EOL> -- Perform binary XOR on these inputs and return result also as a string. <EOL> -- >>> string_xor \"010\" \"110\" <EOL> -- \"100\" <EOL> string_xor :: String -> String -> String <EOL> string_xor a b = [if x == y then '0' else '1' |", "gt": "(x, y) <- zip a b]", "prediction": " x <- a, y <- b]"}
{"input": "<s> -- Input are two strings a and b consisting only of 1s and 0s. <EOL> -- Perform binary XOR on these inputs and return result also as a string. <EOL> -- >>> string_xor \"010\" \"110\" <EOL> -- \"100\" <EOL> string_xor :: String -> String -> String <EOL> string_xor a b =", "gt": "[if x == y then '0' else '1' | (x, y) <- zip a b]", "prediction": " concat"}
{"input": "<s> -- Input are two strings a and b consisting only of 1s and 0s. <EOL> -- Perform binary XOR on these inputs and return result also as a string. <EOL> -- >>> string_xor \"010\" \"110\" <EOL> -- \"100\" <EOL> string_xor :: String -> String -> String <EOL> string_xor a b = [if x == y", "gt": "then '0' else '1' | (x, y) <- zip a b]", "prediction": " then x else y | x <- a, y <- b]"}
{"input": "<s> import Data.List <EOL> -- Find how many times a given substring can be found in the original string. Count overlaping cases. <EOL> -- >>> how_many_times \"\" \"a\" <EOL> -- 0 <EOL> -- >>> how_many_times \"aaa\" \"a\" <EOL> -- 3 <EOL> -- >>> how_many_times \"aaaa\" \"aa\" <EOL> -- 3 <EOL> how_many_times :: String -> String -> Int <EOL> how_many_times string substring =", "gt": "length $ filter (substring `isPrefixOf`) $ map (take (length substring)) $ tails string", "prediction": " undefined"}
{"input": "<s> import Data.List <EOL> -- Find how many times a given substring can be found in the original string. Count overlaping cases. <EOL> -- >>> how_many_times \"\" \"a\" <EOL> -- 0 <EOL> -- >>> how_many_times \"aaa\" \"a\" <EOL> -- 3 <EOL> -- >>> how_many_times \"aaaa\" \"aa\" <EOL> -- 3 <EOL> how_many_times :: String -> String -> Int <EOL> how_many_times string substring = length $ filter", "gt": "(substring `isPrefixOf`) $ map (take (length substring)) $ tails string", "prediction": " (== substring) string"}
{"input": "<s> import Data.List <EOL> -- Find how many times a given substring can be found in the original string. Count overlaping cases. <EOL> -- >>> how_many_times \"\" \"a\" <EOL> -- 0 <EOL> -- >>> how_many_times \"aaa\" \"a\" <EOL> -- 3 <EOL> -- >>> how_many_times \"aaaa\" \"aa\" <EOL> -- 3 <EOL> how_many_times :: String -> String -> Int <EOL> how_many_times string substring = length $ filter (substring `isPrefixOf`) $ map", "gt": "(take (length substring)) $ tails string", "prediction": " (drop 1) string"}
{"input": "<s> import Data.List <EOL> -- Find how many times a given substring can be found in the original string. Count overlaping cases. <EOL> -- >>> how_many_times \"\" \"a\" <EOL> -- 0 <EOL> -- >>> how_many_times \"aaa\" \"a\" <EOL> -- 3 <EOL> -- >>> how_many_times \"aaaa\" \"aa\" <EOL> -- 3 <EOL> how_many_times :: String -> String -> Int <EOL> how_many_times string substring = length $ filter (substring `isPrefixOf`) $ map (take (length substring)) $", "gt": "tails string", "prediction": " lines string"}
{"input": "<s> import Data.List <EOL> -- Find how many times a given substring can be found in the original string. Count overlaping cases. <EOL> -- >>> how_many_times \"\" \"a\" <EOL> -- 0 <EOL> -- >>> how_many_times \"aaa\" \"a\" <EOL> -- 3 <EOL> -- >>> how_many_times \"aaaa\" \"aa\" <EOL> -- 3 <EOL> how_many_times :: String -> String -> Int <EOL> how_many_times string substring = length $ filter (substring `isPrefixOf`) $ map (take", "gt": "(length substring)) $ tails string", "prediction": "While isUpper) string"}
{"input": "<s> -- sum_to_n is a function that sums numbers from 1 to n. <EOL> -- >>> sum_to_n 30 <EOL> -- 465 <EOL> -- >>> sum_to_n 100 <EOL> -- 5050 <EOL> -- >>> sum_to_n 5 <EOL> -- 15 <EOL> -- >>> sum_to_n 10 <EOL> -- 55 <EOL> -- >>> sum_to_n 1 <EOL> -- 1 <EOL> sum_to_n :: Int -> Int <EOL> sum_to_n n =", "gt": "sum [1..n]", "prediction": " sum (take n [1..])"}
{"input": "<s> -- It is the last week of the semester and the teacher has to give the grades <EOL> -- to students. The teacher has been making her own algorithm for grading. <EOL> -- The only problem is, she has lost the code she used for grading. <EOL> -- She has given you a list of GPAs for some students and you have to write <EOL> -- a function that can output a list of letter grades using the following table: <EOL> --          GPA       |    Letter grade <EOL> --           4.0                A+ <EOL> --         > 3.7                A <EOL> --         > 3.3                A- <EOL> --         > 3.0                B+ <EOL> --         > 2.7                B <EOL> --         > 2.3                B- <EOL> --         > 2.0                C+ <EOL> --         > 1.7                C <EOL> --         > 1.3                C- <EOL> --         > 1.0                D+ <EOL> --         > 0.7                D <EOL> --         > 0.0                D- <EOL> --           0.0                E <EOL> -- <EOL> -- <EOL> -- Example: <EOL> -- numerical_letter_grade [4.0, 3, 1.7, 2, 3.5] == [\"A+\", \"B\", \"C-\", \"C\", \"A-\"] <EOL> numerical_letter_grade :: [Double] -> [String] <EOL> numerical_letter_grade grades = map grade grades <EOL>     where <EOL>         grade :: Double -> String <EOL>         grade gpa <EOL>             | gpa == 4.0 = \"A+\" <EOL>             | gpa > 3.7 = \"A\" <EOL>             | gpa > 3.3 = \"A-\" <EOL>             | gpa > 3.0 = \"B+\" <EOL>             | gpa > 2.7 = \"B\" <EOL>             | gpa > 2.3 =", "gt": "\"B-\"", "prediction": " \"C\""}
{"input": "<s> -- It is the last week of the semester and the teacher has to give the grades <EOL> -- to students. The teacher has been making her own algorithm for grading. <EOL> -- The only problem is, she has lost the code she used for grading. <EOL> -- She has given you a list of GPAs for some students and you have to write <EOL> -- a function that can output a list of letter grades using the following table: <EOL> --          GPA       |    Letter grade <EOL> --           4.0                A+ <EOL> --         > 3.7                A <EOL> --         > 3.3                A- <EOL> --         > 3.0                B+ <EOL> --         > 2.7                B <EOL> --         > 2.3                B- <EOL> --         > 2.0                C+ <EOL> --         > 1.7                C <EOL> --         > 1.3                C- <EOL> --         > 1.0                D+ <EOL> --         > 0.7                D <EOL> --         > 0.0                D- <EOL> --           0.0                E <EOL> -- <EOL> -- <EOL> -- Example: <EOL> -- numerical_letter_grade [4.0, 3, 1.7, 2, 3.5] == [\"A+\", \"B\", \"C-\", \"C\", \"A-\"] <EOL> numerical_letter_grade :: [Double] -> [String] <EOL> numerical_letter_grade grades = map grade grades <EOL>     where <EOL>         grade :: Double -> String <EOL>         grade gpa <EOL>             | gpa == 4.0 = \"A+\" <EOL>             | gpa > 3.7 =", "gt": "\"A\"", "prediction": " \"B\""}
{"input": "<s> -- It is the last week of the semester and the teacher has to give the grades <EOL> -- to students. The teacher has been making her own algorithm for grading. <EOL> -- The only problem is, she has lost the code she used for grading. <EOL> -- She has given you a list of GPAs for some students and you have to write <EOL> -- a function that can output a list of letter grades using the following table: <EOL> --          GPA       |    Letter grade <EOL> --           4.0                A+ <EOL> --         > 3.7                A <EOL> --         > 3.3                A- <EOL> --         > 3.0                B+ <EOL> --         > 2.7                B <EOL> --         > 2.3                B- <EOL> --         > 2.0                C+ <EOL> --         > 1.7                C <EOL> --         > 1.3                C- <EOL> --         > 1.0                D+ <EOL> --         > 0.7                D <EOL> --         > 0.0                D- <EOL> --           0.0                E <EOL> -- <EOL> -- <EOL> -- Example: <EOL> -- numerical_letter_grade [4.0, 3, 1.7, 2, 3.5] == [\"A+\", \"B\", \"C-\", \"C\", \"A-\"] <EOL> numerical_letter_grade :: [Double] -> [String] <EOL> numerical_letter_grade grades =", "gt": "map grade grades", "prediction": " undefined"}
{"input": "<s> -- It is the last week of the semester and the teacher has to give the grades <EOL> -- to students. The teacher has been making her own algorithm for grading. <EOL> -- The only problem is, she has lost the code she used for grading. <EOL> -- She has given you a list of GPAs for some students and you have to write <EOL> -- a function that can output a list of letter grades using the following table: <EOL> --          GPA       |    Letter grade <EOL> --           4.0                A+ <EOL> --         > 3.7                A <EOL> --         > 3.3                A- <EOL> --         > 3.0                B+ <EOL> --         > 2.7                B <EOL> --         > 2.3                B- <EOL> --         > 2.0                C+ <EOL> --         > 1.7                C <EOL> --         > 1.3                C- <EOL> --         > 1.0                D+ <EOL> --         > 0.7                D <EOL> --         > 0.0                D- <EOL> --           0.0                E <EOL> -- <EOL> -- <EOL> -- Example: <EOL> -- numerical_letter_grade [4.0, 3, 1.7, 2, 3.5] == [\"A+\", \"B\", \"C-\", \"C\", \"A-\"] <EOL> numerical_letter_grade :: [Double] -> [String] <EOL> numerical_letter_grade grades = map grade grades <EOL>     where <EOL>         grade :: Double -> String <EOL>         grade gpa <EOL>             | gpa == 4.0 = \"A+\" <EOL>             | gpa > 3.7 = \"A\" <EOL>             | gpa > 3.3 = \"A-\" <EOL>             | gpa > 3.0 =", "gt": "\"B+\"", "prediction": " \"B\""}
{"input": "<s> -- It is the last week of the semester and the teacher has to give the grades <EOL> -- to students. The teacher has been making her own algorithm for grading. <EOL> -- The only problem is, she has lost the code she used for grading. <EOL> -- She has given you a list of GPAs for some students and you have to write <EOL> -- a function that can output a list of letter grades using the following table: <EOL> --          GPA       |    Letter grade <EOL> --           4.0                A+ <EOL> --         > 3.7                A <EOL> --         > 3.3                A- <EOL> --         > 3.0                B+ <EOL> --         > 2.7                B <EOL> --         > 2.3                B- <EOL> --         > 2.0                C+ <EOL> --         > 1.7                C <EOL> --         > 1.3                C- <EOL> --         > 1.0                D+ <EOL> --         > 0.7                D <EOL> --         > 0.0                D- <EOL> --           0.0                E <EOL> -- <EOL> -- <EOL> -- Example: <EOL> -- numerical_letter_grade [4.0, 3, 1.7, 2, 3.5] == [\"A+\", \"B\", \"C-\", \"C\", \"A-\"] <EOL> numerical_letter_grade :: [Double] -> [String] <EOL> numerical_letter_grade grades = map grade grades <EOL>     where <EOL>         grade :: Double -> String <EOL>         grade gpa <EOL>             | gpa == 4.0 = \"A+\" <EOL>             | gpa > 3.7 = \"A\" <EOL>             | gpa > 3.3 = \"A-\" <EOL>             | gpa > 3.0 = \"B+\" <EOL>             | gpa > 2.7 =", "gt": "\"B\"", "prediction": " \"C\""}
{"input": "<s> -- brackets is a string of \"<\" and \">\". <EOL> -- return True if every opening bracket has a corresponding closing bracket. <EOL> -- >>> correct_bracketing \"<\" <EOL> -- False <EOL> -- >>> correct_bracketing \"<>\" <EOL> -- True <EOL> -- >>> correct_bracketing \"<<><>>\" <EOL> -- True <EOL> -- >>> correct_bracketing \"><<>\" <EOL> -- False <EOL> correct_bracketing :: String -> Bool <EOL> correct_bracketing brackets = <EOL>     let <EOL>         process (depth, flag) b <EOL>             | depth < 0 =", "gt": "(-1, False)", "prediction": " False"}
{"input": "<s> -- brackets is a string of \"<\" and \">\". <EOL> -- return True if every opening bracket has a corresponding closing bracket. <EOL> -- >>> correct_bracketing \"<\" <EOL> -- False <EOL> -- >>> correct_bracketing \"<>\" <EOL> -- True <EOL> -- >>> correct_bracketing \"<<><>>\" <EOL> -- True <EOL> -- >>> correct_bracketing \"><<>\" <EOL> -- False <EOL> correct_bracketing :: String -> Bool <EOL> correct_bracketing brackets = <EOL>     let <EOL>         process (depth, flag) b <EOL>             | depth < 0 = (-1, False) <EOL>             | b == '<'  = (depth + 1, True) <EOL>             | otherwise =", "gt": "(depth - 1, True)", "prediction": " (depth - 1, False)"}
{"input": "<s> -- brackets is a string of \"<\" and \">\". <EOL> -- return True if every opening bracket has a corresponding closing bracket. <EOL> -- >>> correct_bracketing \"<\" <EOL> -- False <EOL> -- >>> correct_bracketing \"<>\" <EOL> -- True <EOL> -- >>> correct_bracketing \"<<><>>\" <EOL> -- True <EOL> -- >>> correct_bracketing \"><<>\" <EOL> -- False <EOL> correct_bracketing :: String -> Bool <EOL> correct_bracketing brackets = <EOL>     let <EOL>         process (depth, flag) b <EOL>             | depth < 0 = (-1, False) <EOL>             | b == '<'  =", "gt": "(depth + 1, True)", "prediction": " (depth, True)"}
{"input": "<s> -- brackets is a string of \"<\" and \">\". <EOL> -- return True if every opening bracket has a corresponding closing bracket. <EOL> -- >>> correct_bracketing \"<\" <EOL> -- False <EOL> -- >>> correct_bracketing \"<>\" <EOL> -- True <EOL> -- >>> correct_bracketing \"<<><>>\" <EOL> -- True <EOL> -- >>> correct_bracketing \"><<>\" <EOL> -- False <EOL> correct_bracketing :: String -> Bool <EOL> correct_bracketing brackets = <EOL>     let <EOL>         process (depth, flag) b <EOL>             | depth < 0 = (-1, False) <EOL>             | b == '<'  = (depth + 1, True) <EOL>             | otherwise = (depth - 1, True) <EOL>     in <EOL>         case foldl process (0, True) brackets of {} <EOL>             (0, True) ->", "gt": "True", "prediction": " True"}
{"input": "<s> -- brackets is a string of \"<\" and \">\". <EOL> -- return True if every opening bracket has a corresponding closing bracket. <EOL> -- >>> correct_bracketing \"<\" <EOL> -- False <EOL> -- >>> correct_bracketing \"<>\" <EOL> -- True <EOL> -- >>> correct_bracketing \"<<><>>\" <EOL> -- True <EOL> -- >>> correct_bracketing \"><<>\" <EOL> -- False <EOL> correct_bracketing :: String -> Bool <EOL> correct_bracketing brackets = <EOL>     let <EOL>         process (depth, flag) b <EOL>             | depth < 0 = (-1, False) <EOL>             | b == '<'  = (depth + 1, True) <EOL>             | otherwise = (depth - 1, True) <EOL>     in <EOL>         case foldl process (0, True) brackets of {} <EOL>             (0, True) -> True <EOL>             _         ->", "gt": "False", "prediction": " False"}
{"input": "<s> -- prime_fib returns n-th number that is a Fibonacci number and it's also prime. <EOL> -- >>> prime_fib 1 <EOL> -- 2 <EOL> -- >>> prime_fib 2 <EOL> -- 3 <EOL> -- >>> prime_fib 3 <EOL> -- 5 <EOL> -- >>> prime_fib 4 <EOL> -- 13 <EOL> -- >>> prime_fib 5 <EOL> -- 89 <EOL> prime_fib :: Int -> Int <EOL> prime_fib n = head $ drop (n - 1) $ filter isPrime $ map fib [1..] <EOL>   where <EOL>     fib :: Int -> Int <EOL>     fib 1 = 2 <EOL>     fib 2 =", "gt": "3", "prediction": " 3"}
{"input": "<s> -- prime_fib returns n-th number that is a Fibonacci number and it's also prime. <EOL> -- >>> prime_fib 1 <EOL> -- 2 <EOL> -- >>> prime_fib 2 <EOL> -- 3 <EOL> -- >>> prime_fib 3 <EOL> -- 5 <EOL> -- >>> prime_fib 4 <EOL> -- 13 <EOL> -- >>> prime_fib 5 <EOL> -- 89 <EOL> prime_fib :: Int -> Int <EOL> prime_fib n = head $ drop (n - 1) $ filter isPrime $ map fib [1..] <EOL>   where <EOL>     fib :: Int -> Int <EOL>     fib 1 = 2 <EOL>     fib 2 = 3 <EOL>     fib n =", "gt": "fib (n - 1) + fib (n - 2)", "prediction": " n `div` 2"}
{"input": "<s> -- prime_fib returns n-th number that is a Fibonacci number and it's also prime. <EOL> -- >>> prime_fib 1 <EOL> -- 2 <EOL> -- >>> prime_fib 2 <EOL> -- 3 <EOL> -- >>> prime_fib 3 <EOL> -- 5 <EOL> -- >>> prime_fib 4 <EOL> -- 13 <EOL> -- >>> prime_fib 5 <EOL> -- 89 <EOL> prime_fib :: Int -> Int <EOL> prime_fib n = head $ drop (n - 1) $ filter isPrime $ map fib [1..] <EOL>   where <EOL>     fib :: Int -> Int <EOL>     fib 1 = 2 <EOL>     fib 2 = 3 <EOL>     fib n = fib (n - 1) + fib (n - 2) <EOL>     isPrime :: Int -> Bool <EOL>     isPrime p =", "gt": "p > 1 && all (\\k -> p `mod` k /= 0) [2..(p - 1)]", "prediction": " p `mod` 2 == 0"}
{"input": "<s> -- prime_fib returns n-th number that is a Fibonacci number and it's also prime. <EOL> -- >>> prime_fib 1 <EOL> -- 2 <EOL> -- >>> prime_fib 2 <EOL> -- 3 <EOL> -- >>> prime_fib 3 <EOL> -- 5 <EOL> -- >>> prime_fib 4 <EOL> -- 13 <EOL> -- >>> prime_fib 5 <EOL> -- 89 <EOL> prime_fib :: Int -> Int <EOL> prime_fib n = head $ drop (n - 1) $ filter isPrime $ map fib [1..] <EOL>   where <EOL>     fib :: Int -> Int <EOL>     fib 1 = 2 <EOL>     fib 2 = 3 <EOL>     fib n = fib (n - 1) +", "gt": "fib (n - 2)", "prediction": " fib (n - 2)"}
{"input": "<s> -- prime_fib returns n-th number that is a Fibonacci number and it's also prime. <EOL> -- >>> prime_fib 1 <EOL> -- 2 <EOL> -- >>> prime_fib 2 <EOL> -- 3 <EOL> -- >>> prime_fib 3 <EOL> -- 5 <EOL> -- >>> prime_fib 4 <EOL> -- 13 <EOL> -- >>> prime_fib 5 <EOL> -- 89 <EOL> prime_fib :: Int -> Int <EOL> prime_fib n = head $ drop (n - 1) $ filter isPrime $ map fib [1..] <EOL>   where <EOL>     fib :: Int -> Int <EOL>     fib 1 = 2 <EOL>     fib 2 = 3 <EOL>     fib n = fib (n - 1) + fib (n - 2) <EOL>     isPrime :: Int -> Bool <EOL>     isPrime p = p > 1 && all (\\k -> p `mod` k /= 0)", "gt": "[2..(p - 1)]", "prediction": " [1..]"}
{"input": "<s> -- For a given number n, find the largest number that divides n evenly, smaller than n <EOL> -- >>> largest_divisor 15 <EOL> -- 5 <EOL> largest_divisor :: Int -> Int <EOL> largest_divisor n = maximum", "gt": "[x | x <- [1..n-1], n `mod` x == 0]", "prediction": " [x | x <- [1..n], mod n x == 0]"}
{"input": "<s> -- For a given number n, find the largest number that divides n evenly, smaller than n <EOL> -- >>> largest_divisor 15 <EOL> -- 5 <EOL> largest_divisor :: Int -> Int <EOL> largest_divisor n = maximum [x | x <- [1..n-1], n `mod` x ==", "gt": "0]", "prediction": " 0]"}
{"input": "<s> -- For a given number n, find the largest number that divides n evenly, smaller than n <EOL> -- >>> largest_divisor 15 <EOL> -- 5 <EOL> largest_divisor :: Int -> Int <EOL> largest_divisor n =", "gt": "maximum [x | x <- [1..n-1], n `mod` x == 0]", "prediction": " if"}
{"input": "<s> -- For a given number n, find the largest number that divides n evenly, smaller than n <EOL> -- >>> largest_divisor 15 <EOL> -- 5 <EOL> largest_divisor :: Int -> Int <EOL> largest_divisor n = maximum [x | x <- [1..n-1],", "gt": "n `mod` x == 0]", "prediction": " mod n x == 0]"}
{"input": "<s> -- For a given number n, find the largest number that divides n evenly, smaller than n <EOL> -- >>> largest_divisor 15 <EOL> -- 5 <EOL> largest_divisor :: Int -> Int <EOL> largest_divisor n = maximum [x | x <-", "gt": "[1..n-1], n `mod` x == 0]", "prediction": " [1..n], mod n x == 0]"}
{"input": "<s> -- Return 2^n modulo p (be aware of numerics). <EOL> -- >>> modp 3 5 <EOL> -- 3 <EOL> -- >>> modp 1101 101 <EOL> -- 2 <EOL> -- >>> modp 0 101 <EOL> -- 1 <EOL> -- >>> modp 3 11 <EOL> -- 8 <EOL> -- >>> modp 100 101 <EOL> -- 1 <EOL> modp :: Int -> Int -> Int <EOL> modp n p = modp' n p 1 <EOL>   where <EOL>     modp' :: Int -> Int -> Int -> Int <EOL>     modp' 0 p ret =", "gt": "ret", "prediction": " ret"}
{"input": "<s> -- Return 2^n modulo p (be aware of numerics). <EOL> -- >>> modp 3 5 <EOL> -- 3 <EOL> -- >>> modp 1101 101 <EOL> -- 2 <EOL> -- >>> modp 0 101 <EOL> -- 1 <EOL> -- >>> modp 3 11 <EOL> -- 8 <EOL> -- >>> modp 100 101 <EOL> -- 1 <EOL> modp :: Int -> Int -> Int <EOL> modp n p = modp' n p 1 <EOL>   where <EOL>     modp' :: Int -> Int -> Int -> Int <EOL>     modp' 0 p ret = ret <EOL>     modp' n p ret =", "gt": "modp' (n - 1) p (mod (2 * ret) p)", "prediction": " modp' (n - 1) p ret"}
{"input": "<s> -- Return 2^n modulo p (be aware of numerics). <EOL> -- >>> modp 3 5 <EOL> -- 3 <EOL> -- >>> modp 1101 101 <EOL> -- 2 <EOL> -- >>> modp 0 101 <EOL> -- 1 <EOL> -- >>> modp 3 11 <EOL> -- 8 <EOL> -- >>> modp 100 101 <EOL> -- 1 <EOL> modp :: Int -> Int -> Int <EOL> modp n p = modp' n p 1 <EOL>   where <EOL>     modp' :: Int -> Int -> Int -> Int <EOL>     modp' 0 p ret = ret <EOL>     modp' n p ret = modp' (n - 1) p", "gt": "(mod (2 * ret) p)", "prediction": " ("}
{"input": "<s> -- Return 2^n modulo p (be aware of numerics). <EOL> -- >>> modp 3 5 <EOL> -- 3 <EOL> -- >>> modp 1101 101 <EOL> -- 2 <EOL> -- >>> modp 0 101 <EOL> -- 1 <EOL> -- >>> modp 3 11 <EOL> -- 8 <EOL> -- >>> modp 100 101 <EOL> -- 1 <EOL> modp :: Int -> Int -> Int <EOL> modp n p =", "gt": "modp' n p 1", "prediction": " if (fromIntegral n) p"}
{"input": "<s> -- Given an array of integers nums, find the minimum sum of any non-empty sub-array <EOL> -- of nums. <EOL> -- Example <EOL> -- minSubArraySum [2, 3, 4, 1, 2, 4] == 1 <EOL> -- minSubArraySum [-1, -2, -3] == -6 <EOL> minSubArraySum :: [Int] -> Int <EOL> minSubArraySum [x] = x <EOL> minSubArraySum (x:xs) = minimum [n, n + x, x] <EOL>   where n = minSubArraySum", "gt": "xs", "prediction": " xs"}
{"input": "<s> -- Given an array of integers nums, find the minimum sum of any non-empty sub-array <EOL> -- of nums. <EOL> -- Example <EOL> -- minSubArraySum [2, 3, 4, 1, 2, 4] == 1 <EOL> -- minSubArraySum [-1, -2, -3] == -6 <EOL> minSubArraySum :: [Int] -> Int <EOL> minSubArraySum [x] = x <EOL> minSubArraySum (x:xs) =", "gt": "minimum [n, n + x, x]", "prediction": " if"}
{"input": "<s> -- Given an array of integers nums, find the minimum sum of any non-empty sub-array <EOL> -- of nums. <EOL> -- Example <EOL> -- minSubArraySum [2, 3, 4, 1, 2, 4] == 1 <EOL> -- minSubArraySum [-1, -2, -3] == -6 <EOL> minSubArraySum :: [Int] -> Int <EOL> minSubArraySum [x] = x <EOL> minSubArraySum (x:xs) = minimum", "gt": "[n, n + x, x]", "prediction": " $x"}
{"input": "<s> -- Given an array of integers nums, find the minimum sum of any non-empty sub-array <EOL> -- of nums. <EOL> -- Example <EOL> -- minSubArraySum [2, 3, 4, 1, 2, 4] == 1 <EOL> -- minSubArraySum [-1, -2, -3] == -6 <EOL> minSubArraySum :: [Int] -> Int <EOL> minSubArraySum [x] =", "gt": "x", "prediction": " x"}
{"input": "<s> -- Given an array of integers nums, find the minimum sum of any non-empty sub-array <EOL> -- of nums. <EOL> -- Example <EOL> -- minSubArraySum [2, 3, 4, 1, 2, 4] == 1 <EOL> -- minSubArraySum [-1, -2, -3] == -6 <EOL> minSubArraySum :: [Int] -> Int <EOL> minSubArraySum [x] = x <EOL> minSubArraySum (x:xs) = minimum [n, n +", "gt": "x, x]", "prediction": " 1 | n <- [0 .. (length xs - 1)]]"}
{"input": "<s> -- You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word <EOL> -- >>> cycpattern_check \"abcd\" \"abd\" <EOL> -- False <EOL> -- >>> cycpattern_check \"hello\" \"ell\" <EOL> -- True <EOL> -- >>> cycpattern_check \"whassup\" \"psus\" <EOL> -- False <EOL> -- >>> cycpattern_check \"abab\" \"baa\" <EOL> -- True <EOL> -- >>> cycpattern_check \"efef\" \"eeff\" <EOL> -- False <EOL> -- >>> cycpattern_check \"himenss\" \"simen\" <EOL> -- True <EOL> import Data.List <EOL> cycpattern_check :: String -> String -> Bool <EOL> cycpattern_check a b = any (`isInfixOf` a) (createRotations b) <EOL>   where <EOL>     createRotations :: String -> [String] <EOL>     createRotations str =", "gt": "[drop i str ++ take i str | i <- [0 .. length str - 1]]", "prediction": " map"}
{"input": "<s> -- You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word <EOL> -- >>> cycpattern_check \"abcd\" \"abd\" <EOL> -- False <EOL> -- >>> cycpattern_check \"hello\" \"ell\" <EOL> -- True <EOL> -- >>> cycpattern_check \"whassup\" \"psus\" <EOL> -- False <EOL> -- >>> cycpattern_check \"abab\" \"baa\" <EOL> -- True <EOL> -- >>> cycpattern_check \"efef\" \"eeff\" <EOL> -- False <EOL> -- >>> cycpattern_check \"himenss\" \"simen\" <EOL> -- True <EOL> import Data.List <EOL> cycpattern_check :: String -> String -> Bool <EOL> cycpattern_check a b =", "gt": "any (`isInfixOf` a) (createRotations b)", "prediction": " not"}
{"input": "<s> -- You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word <EOL> -- >>> cycpattern_check \"abcd\" \"abd\" <EOL> -- False <EOL> -- >>> cycpattern_check \"hello\" \"ell\" <EOL> -- True <EOL> -- >>> cycpattern_check \"whassup\" \"psus\" <EOL> -- False <EOL> -- >>> cycpattern_check \"abab\" \"baa\" <EOL> -- True <EOL> -- >>> cycpattern_check \"efef\" \"eeff\" <EOL> -- False <EOL> -- >>> cycpattern_check \"himenss\" \"simen\" <EOL> -- True <EOL> import Data.List <EOL> cycpattern_check :: String -> String -> Bool <EOL> cycpattern_check a b = any (`isInfixOf` a) (createRotations b) <EOL>   where <EOL>     createRotations :: String -> [String] <EOL>     createRotations str = [drop i str ++ take i str |", "gt": "i <- [0 .. length str - 1]]", "prediction": " i <- [0..length str - 1]]"}
{"input": "<s> import Data.Char (chr, ord) <EOL> -- returns encoded string by shifting every character by 5 in the alphabet. <EOL> encode_shift :: String -> String <EOL> encode_shift = map (\\c ->", "gt": "chr (((ord c + 5 - ord 'a') `mod` 26) + ord 'a'))", "prediction": " chr (ord c + 5))"}
{"input": "<s> import Data.Char (chr, ord) <EOL> -- returns encoded string by shifting every character by 5 in the alphabet. <EOL> encode_shift :: String -> String <EOL> encode_shift = map (\\c -> chr (((ord c + 5 - ord 'a') `mod` 26) + ord 'a')) <EOL> -- takes as input string encoded with encode_shift function. Returns decoded string. <EOL> decode_shift :: String -> String <EOL> decode_shift = map (\\c -> chr (((ord c - 5 - ord 'a') `mod` 26) +", "gt": "ord 'a'))", "prediction": " ord 'a') `mod` 26)"}
{"input": "<s> import Data.Char (chr, ord) <EOL> -- returns encoded string by shifting every character by 5 in the alphabet. <EOL> encode_shift :: String -> String <EOL> encode_shift = map (\\c -> chr (((ord c + 5 - ord 'a') `mod` 26) + ord 'a')) <EOL> -- takes as input string encoded with encode_shift function. Returns decoded string. <EOL> decode_shift :: String -> String <EOL> decode_shift =", "gt": "map (\\c -> chr (((ord c - 5 - ord 'a') `mod` 26) + ord 'a'))", "prediction": " map (\\c -> chr ((ord c + 5 - ord 'a') `mod` 26) + ord 'a')"}
{"input": "<s> import Data.Char (chr, ord) <EOL> -- returns encoded string by shifting every character by 5 in the alphabet. <EOL> encode_shift :: String -> String <EOL> encode_shift = map (\\c -> chr (((ord c + 5 - ord 'a') `mod` 26) + ord 'a')) <EOL> -- takes as input string encoded with encode_shift function. Returns decoded string. <EOL> decode_shift :: String -> String <EOL> decode_shift = map (\\c ->", "gt": "chr (((ord c - 5 - ord 'a') `mod` 26) + ord 'a'))", "prediction": " chr ((ord c + 5 - ord 'a') `mod` 26) + ord 'a')"}
{"input": "<s> import Data.Char (chr, ord) <EOL> -- returns encoded string by shifting every character by 5 in the alphabet. <EOL> encode_shift :: String -> String <EOL> encode_shift = map (\\c -> chr (((ord c + 5 - ord 'a') `mod` 26) +", "gt": "ord 'a'))", "prediction": " ord 'a'))"}
{"input": "<s> -- Return list with elements incremented by 1. <EOL> -- >>> incr_list [1,2,3] <EOL> -- [2,3,4] <EOL> -- >>> incr_list [5,3,5,2,3,3,9,0,123] <EOL> -- [6,4,6,3,4,4,10,1,124] <EOL> incr_list :: [Int] -> [Int] <EOL> incr_list =", "gt": "map (+1)", "prediction": " zip (+1)"}
{"input": "<s> -- Given list of numbers (of at least two elements), apply a linear transform to that list, <EOL> -- such that the smallest number will become 0 and the largest will become 1 <EOL> -- >>> rescale_to_unit [1.0, 2.0, 3.0, 4.0, 5.0] <EOL> -- [0.0,0.25,0.5,0.75,1.0] <EOL> rescale_to_unit :: [Float] -> [Float] <EOL> rescale_to_unit numbers = map (\\x ->", "gt": "(x - min_number) / (max_number - min_number)) numbers", "prediction": " x * (x + 1)) numbers"}
{"input": "<s> -- Given list of numbers (of at least two elements), apply a linear transform to that list, <EOL> -- such that the smallest number will become 0 and the largest will become 1 <EOL> -- >>> rescale_to_unit [1.0, 2.0, 3.0, 4.0, 5.0] <EOL> -- [0.0,0.25,0.5,0.75,1.0] <EOL> rescale_to_unit :: [Float] -> [Float] <EOL> rescale_to_unit numbers = map", "gt": "(\\x -> (x - min_number) / (max_number - min_number)) numbers", "prediction": " (* 2) numbers"}
{"input": "<s> -- Given list of numbers (of at least two elements), apply a linear transform to that list, <EOL> -- such that the smallest number will become 0 and the largest will become 1 <EOL> -- >>> rescale_to_unit [1.0, 2.0, 3.0, 4.0, 5.0] <EOL> -- [0.0,0.25,0.5,0.75,1.0] <EOL> rescale_to_unit :: [Float] -> [Float] <EOL> rescale_to_unit numbers = map (\\x -> (x - min_number) / (max_number - min_number)) numbers <EOL>     where min_number = minimum numbers <EOL>           max_number =", "gt": "maximum numbers", "prediction": " maximum numbers"}
{"input": "<s> -- Given list of numbers (of at least two elements), apply a linear transform to that list, <EOL> -- such that the smallest number will become 0 and the largest will become 1 <EOL> -- >>> rescale_to_unit [1.0, 2.0, 3.0, 4.0, 5.0] <EOL> -- [0.0,0.25,0.5,0.75,1.0] <EOL> rescale_to_unit :: [Float] -> [Float] <EOL> rescale_to_unit numbers = map (\\x -> (x - min_number) / (max_number - min_number))", "gt": "numbers", "prediction": " numbers"}
{"input": "<s> -- Given list of numbers (of at least two elements), apply a linear transform to that list, <EOL> -- such that the smallest number will become 0 and the largest will become 1 <EOL> -- >>> rescale_to_unit [1.0, 2.0, 3.0, 4.0, 5.0] <EOL> -- [0.0,0.25,0.5,0.75,1.0] <EOL> rescale_to_unit :: [Float] -> [Float] <EOL> rescale_to_unit numbers = map (\\x -> (x - min_number) /", "gt": "(max_number - min_number)) numbers", "prediction": " 2) numbers"}
{"input": "<s> -- Create a function which takes a string representing a file's name, and returns <EOL> -- 'Yes' if the the file's name is valid, and returns 'No' otherwise. <EOL> -- A file's name is considered to be valid if and only if all the following conditions are met: <EOL> -- - There should not be more than three digits ('0'-'9') in the file's name. <EOL> -- - The file's name contains exactly one dot '.' <EOL> -- - The substring before the dot should not be empty, and it starts with a letter from the latin alphapet ('a'-'z' and 'A'-'Z'). <EOL> -- - The substring after the dot should be one of these: ['txt', 'exe', 'dll'] <EOL> -- Examples: <EOL> -- >>> file_name_check \"example.txt\" <EOL> -- \"Yes\" <EOL> -- >>> file_name_check \"1example.dll\" <EOL> -- \"No\" (the name should start with a latin alphapet letter <EOL> file_name_check :: String -> String <EOL> file_name_check filename <EOL>   | (length filename) < 5 = \"No\" <EOL>   | otherwise = if containsOneDot filename && containsNoMoreThanThreeDigits filename && endsOnTxtExeOrDll filename && doesNotStartWithDot filename && startWithLetterFromLatinAlphabet filename then \"Yes\" else \"No\" <EOL>   where <EOL>     containsOneDot :: String -> Bool <EOL>     containsOneDot filename = length (filter (== '.') filename) == 1 <EOL>     containsNoMoreThanThreeDigits filename = length (filter (\\x -> x `elem` ['0' .. '9']) filename) <= 3 <EOL>     endsOnTxtExeOrDll filename =", "gt": "(drop (length filename - 4) filename) `elem` [\".txt\", \".exe\", \".dll\"]", "prediction": " length"}
{"input": "<s> -- Create a function which takes a string representing a file's name, and returns <EOL> -- 'Yes' if the the file's name is valid, and returns 'No' otherwise. <EOL> -- A file's name is considered to be valid if and only if all the following conditions are met: <EOL> -- - There should not be more than three digits ('0'-'9') in the file's name. <EOL> -- - The file's name contains exactly one dot '.' <EOL> -- - The substring before the dot should not be empty, and it starts with a letter from the latin alphapet ('a'-'z' and 'A'-'Z'). <EOL> -- - The substring after the dot should be one of these: ['txt', 'exe', 'dll'] <EOL> -- Examples: <EOL> -- >>> file_name_check \"example.txt\" <EOL> -- \"Yes\" <EOL> -- >>> file_name_check \"1example.dll\" <EOL> -- \"No\" (the name should start with a latin alphapet letter <EOL> file_name_check :: String -> String <EOL> file_name_check filename <EOL>   | (length filename) < 5 = \"No\" <EOL>   | otherwise = if containsOneDot filename && containsNoMoreThanThreeDigits filename && endsOnTxtExeOrDll filename && doesNotStartWithDot filename && startWithLetterFromLatinAlphabet filename then \"Yes\" else \"No\" <EOL>   where <EOL>     containsOneDot :: String -> Bool <EOL>     containsOneDot filename = length (filter (== '.') filename) == 1 <EOL>     containsNoMoreThanThreeDigits filename = length (filter (\\x -> x `elem` ['0' .. '9']) filename) <= 3 <EOL>     endsOnTxtExeOrDll filename = (drop (length filename - 4) filename) `elem` [\".txt\", \".exe\", \".dll\"] <EOL>     doesNotStartWithDot filename = head filename /= '.' <EOL>     startWithLetterFromLatinAlphabet filename =", "gt": "head filename `elem` ['a' .. 'z'] || head filename `elem` ['A' .. 'Z']", "prediction": " start"}
{"input": "<s> -- Create a function which takes a string representing a file's name, and returns <EOL> -- 'Yes' if the the file's name is valid, and returns 'No' otherwise. <EOL> -- A file's name is considered to be valid if and only if all the following conditions are met: <EOL> -- - There should not be more than three digits ('0'-'9') in the file's name. <EOL> -- - The file's name contains exactly one dot '.' <EOL> -- - The substring before the dot should not be empty, and it starts with a letter from the latin alphapet ('a'-'z' and 'A'-'Z'). <EOL> -- - The substring after the dot should be one of these: ['txt', 'exe', 'dll'] <EOL> -- Examples: <EOL> -- >>> file_name_check \"example.txt\" <EOL> -- \"Yes\" <EOL> -- >>> file_name_check \"1example.dll\" <EOL> -- \"No\" (the name should start with a latin alphapet letter <EOL> file_name_check :: String -> String <EOL> file_name_check filename <EOL>   | (length filename) < 5 = \"No\" <EOL>   | otherwise =", "gt": "if containsOneDot filename && containsNoMoreThanThreeDigits filename && endsOnTxtExeOrDll filename && doesNotStartWithDot filename && startWithLetterFromLatinAlphabet filename then \"Yes\" else \"No\"", "prediction": " \""}
{"input": "<s> -- Create a function which takes a string representing a file's name, and returns <EOL> -- 'Yes' if the the file's name is valid, and returns 'No' otherwise. <EOL> -- A file's name is considered to be valid if and only if all the following conditions are met: <EOL> -- - There should not be more than three digits ('0'-'9') in the file's name. <EOL> -- - The file's name contains exactly one dot '.' <EOL> -- - The substring before the dot should not be empty, and it starts with a letter from the latin alphapet ('a'-'z' and 'A'-'Z'). <EOL> -- - The substring after the dot should be one of these: ['txt', 'exe', 'dll'] <EOL> -- Examples: <EOL> -- >>> file_name_check \"example.txt\" <EOL> -- \"Yes\" <EOL> -- >>> file_name_check \"1example.dll\" <EOL> -- \"No\" (the name should start with a latin alphapet letter <EOL> file_name_check :: String -> String <EOL> file_name_check filename <EOL>   | (length filename) < 5 = \"No\" <EOL>   | otherwise = if containsOneDot filename && containsNoMoreThanThreeDigits filename && endsOnTxtExeOrDll filename && doesNotStartWithDot filename && startWithLetterFromLatinAlphabet filename then \"Yes\" else \"No\" <EOL>   where <EOL>     containsOneDot :: String -> Bool <EOL>     containsOneDot filename =", "gt": "length (filter (== '.') filename) == 1", "prediction": " ("}
{"input": "<s> -- Create a function which takes a string representing a file's name, and returns <EOL> -- 'Yes' if the the file's name is valid, and returns 'No' otherwise. <EOL> -- A file's name is considered to be valid if and only if all the following conditions are met: <EOL> -- - There should not be more than three digits ('0'-'9') in the file's name. <EOL> -- - The file's name contains exactly one dot '.' <EOL> -- - The substring before the dot should not be empty, and it starts with a letter from the latin alphapet ('a'-'z' and 'A'-'Z'). <EOL> -- - The substring after the dot should be one of these: ['txt', 'exe', 'dll'] <EOL> -- Examples: <EOL> -- >>> file_name_check \"example.txt\" <EOL> -- \"Yes\" <EOL> -- >>> file_name_check \"1example.dll\" <EOL> -- \"No\" (the name should start with a latin alphapet letter <EOL> file_name_check :: String -> String <EOL> file_name_check filename <EOL>   | (length filename) < 5 = \"No\" <EOL>   | otherwise = if containsOneDot filename && containsNoMoreThanThreeDigits filename && endsOnTxtExeOrDll filename && doesNotStartWithDot filename && startWithLetterFromLatinAlphabet filename then \"Yes\" else \"No\" <EOL>   where <EOL>     containsOneDot :: String -> Bool <EOL>     containsOneDot filename = length (filter (== '.') filename) == 1 <EOL>     containsNoMoreThanThreeDigits filename = length (filter (\\x -> x `elem` ['0' .. '9']) filename) <= 3 <EOL>     endsOnTxtExeOrDll filename = (drop (length filename - 4) filename) `elem` [\".txt\", \".exe\", \".dll\"] <EOL>     doesNotStartWithDot filename = head filename /= '.' <EOL>     startWithLetterFromLatinAlphabet filename = head filename `elem` ['a' .. 'z'] ||", "gt": "head filename `elem` ['A' .. 'Z']", "prediction": " ("}
{"input": "<s> -- The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows: <EOL> -- fibfib(0) == 0 <EOL> -- fibfib(1) == 0 <EOL> -- fibfib(2) == 1 <EOL> -- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). <EOL> -- Please write a function to efficiently compute the n-th element of the fibfib number sequence. <EOL> -- >>> fibfib 1 <EOL> -- 0 <EOL> -- >>> fibfib 5 <EOL> -- 4 <EOL> -- >>> fibfib 8 <EOL> -- 24 <EOL> fibfib :: Int -> Int <EOL> fibfib n <EOL>   | n == 0 = 0 <EOL>   | n == 1 = 0 <EOL>   | n == 2 = 1 <EOL>   | otherwise = fibfib (n - 1) + fibfib (n - 2) +", "gt": "fibfib (n - 3)", "prediction": " fibfib (n - 3)"}
{"input": "<s> -- The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows: <EOL> -- fibfib(0) == 0 <EOL> -- fibfib(1) == 0 <EOL> -- fibfib(2) == 1 <EOL> -- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). <EOL> -- Please write a function to efficiently compute the n-th element of the fibfib number sequence. <EOL> -- >>> fibfib 1 <EOL> -- 0 <EOL> -- >>> fibfib 5 <EOL> -- 4 <EOL> -- >>> fibfib 8 <EOL> -- 24 <EOL> fibfib :: Int -> Int <EOL> fibfib n <EOL>   | n == 0 = 0 <EOL>   | n == 1 = 0 <EOL>   | n == 2 = 1 <EOL>   | otherwise =", "gt": "fibfib (n - 1) + fibfib (n - 2) + fibfib (n - 3)", "prediction": " fibfib(n-1) + fibfib(n-2) + fibfib(n-3)"}
{"input": "<s> -- The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows: <EOL> -- fibfib(0) == 0 <EOL> -- fibfib(1) == 0 <EOL> -- fibfib(2) == 1 <EOL> -- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). <EOL> -- Please write a function to efficiently compute the n-th element of the fibfib number sequence. <EOL> -- >>> fibfib 1 <EOL> -- 0 <EOL> -- >>> fibfib 5 <EOL> -- 4 <EOL> -- >>> fibfib 8 <EOL> -- 24 <EOL> fibfib :: Int -> Int <EOL> fibfib n <EOL>   | n == 0 = 0 <EOL>   | n == 1 = 0 <EOL>   | n == 2 =", "gt": "1", "prediction": " 1"}
{"input": "<s> -- The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows: <EOL> -- fibfib(0) == 0 <EOL> -- fibfib(1) == 0 <EOL> -- fibfib(2) == 1 <EOL> -- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). <EOL> -- Please write a function to efficiently compute the n-th element of the fibfib number sequence. <EOL> -- >>> fibfib 1 <EOL> -- 0 <EOL> -- >>> fibfib 5 <EOL> -- 4 <EOL> -- >>> fibfib 8 <EOL> -- 24 <EOL> fibfib :: Int -> Int <EOL> fibfib n <EOL>   | n == 0 = 0 <EOL>   | n == 1 =", "gt": "0", "prediction": " 1"}
{"input": "<s> -- The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows: <EOL> -- fibfib(0) == 0 <EOL> -- fibfib(1) == 0 <EOL> -- fibfib(2) == 1 <EOL> -- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). <EOL> -- Please write a function to efficiently compute the n-th element of the fibfib number sequence. <EOL> -- >>> fibfib 1 <EOL> -- 0 <EOL> -- >>> fibfib 5 <EOL> -- 4 <EOL> -- >>> fibfib 8 <EOL> -- 24 <EOL> fibfib :: Int -> Int <EOL> fibfib n <EOL>   | n == 0 =", "gt": "0", "prediction": " 0"}
{"input": "<s> -- From a list of integers, remove all elements that occur more than once. <EOL> -- Keep order of elements left the same as in the input. <EOL> -- >>> remove_duplicates [1, 2, 3, 2, 4] <EOL> -- [1,3,4] <EOL> remove_duplicates :: [Int] -> [Int] <EOL> remove_duplicates numbers = [n |", "gt": "(n, c) <- counts, c <= 1]", "prediction": " n <- numbers, n > 1]"}
{"input": "<s> -- From a list of integers, remove all elements that occur more than once. <EOL> -- Keep order of elements left the same as in the input. <EOL> -- >>> remove_duplicates [1, 2, 3, 2, 4] <EOL> -- [1,3,4] <EOL> remove_duplicates :: [Int] -> [Int] <EOL> remove_duplicates numbers = [n | (n, c) <- counts, c <= 1] <EOL>     where counts =", "gt": "[(n, count n numbers) | n <- numbers]", "prediction": " mapub numbers"}
{"input": "<s> -- From a list of integers, remove all elements that occur more than once. <EOL> -- Keep order of elements left the same as in the input. <EOL> -- >>> remove_duplicates [1, 2, 3, 2, 4] <EOL> -- [1,3,4] <EOL> remove_duplicates :: [Int] -> [Int] <EOL> remove_duplicates numbers = [n | (n, c) <- counts,", "gt": "c <= 1]", "prediction": " c > 0]"}
{"input": "<s> -- From a list of integers, remove all elements that occur more than once. <EOL> -- Keep order of elements left the same as in the input. <EOL> -- >>> remove_duplicates [1, 2, 3, 2, 4] <EOL> -- [1,3,4] <EOL> remove_duplicates :: [Int] -> [Int] <EOL> remove_duplicates numbers = [n | (n, c) <- counts, c <= 1] <EOL>     where counts = [(n, count n numbers) | n <- numbers] <EOL>           count n xs = length", "gt": "[x | x <- xs, x == n]", "prediction": " (filter (== n) xs)"}
{"input": "<s> -- From a list of integers, remove all elements that occur more than once. <EOL> -- Keep order of elements left the same as in the input. <EOL> -- >>> remove_duplicates [1, 2, 3, 2, 4] <EOL> -- [1,3,4] <EOL> remove_duplicates :: [Int] -> [Int] <EOL> remove_duplicates numbers = [n | (n, c) <- counts, c <= 1] <EOL>     where counts = [(n, count n numbers) | n <-", "gt": "numbers]", "prediction": " numbers]"}
{"input": "<s> -- Check if in given list of numbers, are any two numbers closer to each other than <EOL> -- given threshold. <EOL> -- >>> has_close_elements [1.0, 2.0, 3.0] 0.5 <EOL> -- False <EOL> -- >>> has_close_elements [1.0, 2.8, 3.0, 4.0, 5.0, 2.0] 0.3 <EOL> -- True <EOL> has_close_elements :: [Float] -> Float -> Bool <EOL> has_close_elements numbers threshold =", "gt": "any (\\(x, y) -> abs (x - y) < threshold) [(x,y) | x <- numbers, y <- numbers, x /= y]", "prediction": " any"}
{"input": "<s> -- Check if in given list of numbers, are any two numbers closer to each other than <EOL> -- given threshold. <EOL> -- >>> has_close_elements [1.0, 2.0, 3.0] 0.5 <EOL> -- False <EOL> -- >>> has_close_elements [1.0, 2.8, 3.0, 4.0, 5.0, 2.0] 0.3 <EOL> -- True <EOL> has_close_elements :: [Float] -> Float -> Bool <EOL> has_close_elements numbers threshold = any (\\(x, y) -> abs (x - y) < threshold) [(x,y) | x <- numbers, y <- numbers,", "gt": "x /= y]", "prediction": " abs (x - y) < threshold]"}
{"input": "<s> -- Check if in given list of numbers, are any two numbers closer to each other than <EOL> -- given threshold. <EOL> -- >>> has_close_elements [1.0, 2.0, 3.0] 0.5 <EOL> -- False <EOL> -- >>> has_close_elements [1.0, 2.8, 3.0, 4.0, 5.0, 2.0] 0.3 <EOL> -- True <EOL> has_close_elements :: [Float] -> Float -> Bool <EOL> has_close_elements numbers threshold = any (\\(x, y) ->", "gt": "abs (x - y) < threshold) [(x,y) | x <- numbers, y <- numbers, x /= y]", "prediction": " x > threshold && y > threshold) numbers"}
{"input": "<s> -- Check if in given list of numbers, are any two numbers closer to each other than <EOL> -- given threshold. <EOL> -- >>> has_close_elements [1.0, 2.0, 3.0] 0.5 <EOL> -- False <EOL> -- >>> has_close_elements [1.0, 2.8, 3.0, 4.0, 5.0, 2.0] 0.3 <EOL> -- True <EOL> has_close_elements :: [Float] -> Float -> Bool <EOL> has_close_elements numbers threshold = any (\\(x, y) -> abs (x - y) < threshold)", "gt": "[(x,y) | x <- numbers, y <- numbers, x /= y]", "prediction": " numbers"}
{"input": "<s> import Data.Map <EOL> import Data.List <EOL> -- Input is a space-delimited string of numberals from 'zero' to 'nine'. <EOL> -- Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'. <EOL> -- Return the string with numbers sorted from smallest to largest <EOL> -- >>> sort_numbers \"three one five\" <EOL> -- \"one three five\" <EOL> sort_numbers :: String -> String <EOL> sort_numbers numbers = unwords $ sortOn (value_map !) $", "gt": "words numbers", "prediction": " map numbers [0..]"}
{"input": "<s> import Data.Map <EOL> import Data.List <EOL> -- Input is a space-delimited string of numberals from 'zero' to 'nine'. <EOL> -- Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'. <EOL> -- Return the string with numbers sorted from smallest to largest <EOL> -- >>> sort_numbers \"three one five\" <EOL> -- \"one three five\" <EOL> sort_numbers :: String -> String <EOL> sort_numbers numbers = unwords $ sortOn (value_map !) $ words numbers <EOL>     where value_map = fromList", "gt": "[(\"zero\", 0), (\"one\", 1), (\"two\", 2), (\"three\", 3), (\"four\", 4), (\"five\", 5), (\"six\", 6), (\"seven\", 7), (\"eight\", 8), (\"nine\", 9)]", "prediction": " $0, '0'), (1, '1')]"}
{"input": "<s> import Data.Map <EOL> import Data.List <EOL> -- Input is a space-delimited string of numberals from 'zero' to 'nine'. <EOL> -- Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'. <EOL> -- Return the string with numbers sorted from smallest to largest <EOL> -- >>> sort_numbers \"three one five\" <EOL> -- \"one three five\" <EOL> sort_numbers :: String -> String <EOL> sort_numbers numbers = unwords $ sortOn (value_map !) $ words numbers <EOL>     where value_map = fromList [(\"zero\", 0), (\"one\", 1), (\"two\", 2), (\"three\", 3), (\"four\", 4), (\"five\", 5),", "gt": "(\"six\", 6), (\"seven\", 7), (\"eight\", 8), (\"nine\", 9)]", "prediction": " (\"seven\", 6), (\"nine\", 7)]"}
{"input": "<s> import Data.Map <EOL> import Data.List <EOL> -- Input is a space-delimited string of numberals from 'zero' to 'nine'. <EOL> -- Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'. <EOL> -- Return the string with numbers sorted from smallest to largest <EOL> -- >>> sort_numbers \"three one five\" <EOL> -- \"one three five\" <EOL> sort_numbers :: String -> String <EOL> sort_numbers numbers =", "gt": "unwords $ sortOn (value_map !) $ words numbers", "prediction": " undefined"}
{"input": "<s> import Data.Map <EOL> import Data.List <EOL> -- Input is a space-delimited string of numberals from 'zero' to 'nine'. <EOL> -- Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'. <EOL> -- Return the string with numbers sorted from smallest to largest <EOL> -- >>> sort_numbers \"three one five\" <EOL> -- \"one three five\" <EOL> sort_numbers :: String -> String <EOL> sort_numbers numbers = unwords $ sortOn", "gt": "(value_map !) $ words numbers", "prediction": " (flip compare) numbers"}
{"input": "<s> import Data.List (sort) <EOL> -- This function takes a list l and returns a list l' such that <EOL> -- l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal <EOL> -- to the values of the corresponding indicies of l, but sorted. <EOL> -- >>> sort_third [1,2,3] <EOL> -- [1,2,3] <EOL> -- >>> sort_third [5,6,3,4,8,9,2] <EOL> -- [2,6,3,4,8,9,5] <EOL> sort_third :: [Int] -> [Int] <EOL> sort_third xs = replaceEveryThird xs (sort $ everyThird xs) <EOL>   where <EOL>     everyThird :: [Int] -> [Int] <EOL>     everyThird [] = [] <EOL>     everyThird (x:xs) = x : everyThird (drop 2 xs) <EOL>     replaceEveryThird :: [Int] -> [Int] -> [Int] <EOL>     replaceEveryThird [] _ = [] <EOL>     replaceEveryThird xs [] =", "gt": "xs", "prediction": " xs"}
{"input": "<s> import Data.List (sort) <EOL> -- This function takes a list l and returns a list l' such that <EOL> -- l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal <EOL> -- to the values of the corresponding indicies of l, but sorted. <EOL> -- >>> sort_third [1,2,3] <EOL> -- [1,2,3] <EOL> -- >>> sort_third [5,6,3,4,8,9,2] <EOL> -- [2,6,3,4,8,9,5] <EOL> sort_third :: [Int] -> [Int] <EOL> sort_third xs = replaceEveryThird xs (sort $ everyThird xs) <EOL>   where <EOL>     everyThird :: [Int] -> [Int] <EOL>     everyThird [] = [] <EOL>     everyThird (x:xs) =", "gt": "x : everyThird (drop 2 xs)", "prediction": " (x:xs)"}
{"input": "<s> import Data.List (sort) <EOL> -- This function takes a list l and returns a list l' such that <EOL> -- l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal <EOL> -- to the values of the corresponding indicies of l, but sorted. <EOL> -- >>> sort_third [1,2,3] <EOL> -- [1,2,3] <EOL> -- >>> sort_third [5,6,3,4,8,9,2] <EOL> -- [2,6,3,4,8,9,5] <EOL> sort_third :: [Int] -> [Int] <EOL> sort_third xs = replaceEveryThird xs (sort $ everyThird xs) <EOL>   where <EOL>     everyThird :: [Int] -> [Int] <EOL>     everyThird [] = [] <EOL>     everyThird (x:xs) = x : everyThird", "gt": "(drop 2 xs)", "prediction": " xs"}
{"input": "<s> import Data.List (sort) <EOL> -- This function takes a list l and returns a list l' such that <EOL> -- l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal <EOL> -- to the values of the corresponding indicies of l, but sorted. <EOL> -- >>> sort_third [1,2,3] <EOL> -- [1,2,3] <EOL> -- >>> sort_third [5,6,3,4,8,9,2] <EOL> -- [2,6,3,4,8,9,5] <EOL> sort_third :: [Int] -> [Int] <EOL> sort_third xs = replaceEveryThird xs (sort $ everyThird xs) <EOL>   where <EOL>     everyThird :: [Int] -> [Int] <EOL>     everyThird [] =", "gt": "[]", "prediction": " []"}
{"input": "<s> import Data.List (sort) <EOL> -- This function takes a list l and returns a list l' such that <EOL> -- l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal <EOL> -- to the values of the corresponding indicies of l, but sorted. <EOL> -- >>> sort_third [1,2,3] <EOL> -- [1,2,3] <EOL> -- >>> sort_third [5,6,3,4,8,9,2] <EOL> -- [2,6,3,4,8,9,5] <EOL> sort_third :: [Int] -> [Int] <EOL> sort_third xs = replaceEveryThird xs (sort $ everyThird xs) <EOL>   where <EOL>     everyThird :: [Int] -> [Int] <EOL>     everyThird [] = [] <EOL>     everyThird (x:xs) = x : everyThird (drop 2 xs) <EOL>     replaceEveryThird :: [Int] -> [Int] -> [Int] <EOL>     replaceEveryThird [] _ = [] <EOL>     replaceEveryThird xs [] = xs <EOL>     replaceEveryThird (x:xs) (y:ys) = y : (take 2 xs ++", "gt": "replaceEveryThird (drop 2 xs) ys)", "prediction": " [y]) : (replaceFirst x y ys)"}
{"input": "<s> -- Implement the function f that takes n as a parameter, <EOL> -- and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even <EOL> -- or the sum of numbers from 1 to i otherwise. <EOL> -- i starts from 1. <EOL> -- the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i). <EOL> -- Example: <EOL> -- f 5 == [1,2,6,24,15] <EOL> f :: Int -> [Int] <EOL> f n = <EOL>   [ if even i <EOL>       then product [1 .. i] <EOL>       else sum [1 .. i] <EOL>     | i <-", "gt": "[1 .. n]", "prediction": " [1 .. n]]"}
{"input": "<s> -- Implement the function f that takes n as a parameter, <EOL> -- and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even <EOL> -- or the sum of numbers from 1 to i otherwise. <EOL> -- i starts from 1. <EOL> -- the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i). <EOL> -- Example: <EOL> -- f 5 == [1,2,6,24,15] <EOL> f :: Int -> [Int] <EOL> f n = <EOL>   [ if", "gt": "even i", "prediction": " even n"}
{"input": "<s> -- Implement the function f that takes n as a parameter, <EOL> -- and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even <EOL> -- or the sum of numbers from 1 to i otherwise. <EOL> -- i starts from 1. <EOL> -- the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i). <EOL> -- Example: <EOL> -- f 5 == [1,2,6,24,15] <EOL> f :: Int -> [Int] <EOL> f n = <EOL>   [ if even i <EOL>       then product [1 .. i] <EOL>       else", "gt": "sum [1 .. i]", "prediction": " 0"}
{"input": "<s> -- Implement the function f that takes n as a parameter, <EOL> -- and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even <EOL> -- or the sum of numbers from 1 to i otherwise. <EOL> -- i starts from 1. <EOL> -- the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i). <EOL> -- Example: <EOL> -- f 5 == [1,2,6,24,15] <EOL> f :: Int -> [Int] <EOL> f n = <EOL>   [ if even i <EOL>       then", "gt": "product [1 .. i]", "prediction": " [ i * 2 * i | i <- [1 .. n] ]"}
{"input": "<s> import Data.List <EOL> -- Given an array of non-negative integers, return a copy of the given array after sorting, <EOL> -- you will sort the given array in ascending order if the sum( first index value, last index value) is odd, <EOL> -- or sort it in descending order if the sum( first index value, last index value) is even. <EOL> -- <EOL> -- Note: <EOL> -- * don't change the given array. <EOL> -- <EOL> -- Examples: <EOL> -- >>> sort_array [] <EOL> -- [] <EOL> -- >>> sort_array [5] <EOL> -- [5] <EOL> -- >>> sort_array [2, 4, 3, 0, 1, 5] <EOL> -- [0,1,2,3,4,5] <EOL> -- >>> sort_array [2, 4, 3, 0, 1, 5, 6] <EOL> -- [6,5,4,3,2,1,0] <EOL> sort_array :: [Int] -> [Int] <EOL> sort_array array = <EOL>   if length array == 0 <EOL>     then [] <EOL>     else <EOL>       sortBy <EOL>         ( \\x y -> <EOL>             if (array !! 0 + array !! (length array - 1)) `mod` 2 == 0 <EOL>               then", "gt": "compare y x", "prediction": " ( (x,y) ]"}
{"input": "<s> import Data.List <EOL> -- Given an array of non-negative integers, return a copy of the given array after sorting, <EOL> -- you will sort the given array in ascending order if the sum( first index value, last index value) is odd, <EOL> -- or sort it in descending order if the sum( first index value, last index value) is even. <EOL> -- <EOL> -- Note: <EOL> -- * don't change the given array. <EOL> -- <EOL> -- Examples: <EOL> -- >>> sort_array [] <EOL> -- [] <EOL> -- >>> sort_array [5] <EOL> -- [5] <EOL> -- >>> sort_array [2, 4, 3, 0, 1, 5] <EOL> -- [0,1,2,3,4,5] <EOL> -- >>> sort_array [2, 4, 3, 0, 1, 5, 6] <EOL> -- [6,5,4,3,2,1,0] <EOL> sort_array :: [Int] -> [Int] <EOL> sort_array array = <EOL>   if length array == 0 <EOL>     then", "gt": "[]", "prediction": " []"}
{"input": "<s> import Data.List <EOL> -- Given an array of non-negative integers, return a copy of the given array after sorting, <EOL> -- you will sort the given array in ascending order if the sum( first index value, last index value) is odd, <EOL> -- or sort it in descending order if the sum( first index value, last index value) is even. <EOL> -- <EOL> -- Note: <EOL> -- * don't change the given array. <EOL> -- <EOL> -- Examples: <EOL> -- >>> sort_array [] <EOL> -- [] <EOL> -- >>> sort_array [5] <EOL> -- [5] <EOL> -- >>> sort_array [2, 4, 3, 0, 1, 5] <EOL> -- [0,1,2,3,4,5] <EOL> -- >>> sort_array [2, 4, 3, 0, 1, 5, 6] <EOL> -- [6,5,4,3,2,1,0] <EOL> sort_array :: [Int] -> [Int] <EOL> sort_array array = <EOL>   if length array == 0 <EOL>     then [] <EOL>     else <EOL>       sortBy <EOL>         ( \\x y -> <EOL>             if (array !! 0 + array !! (length array - 1)) `mod` 2 ==", "gt": "0", "prediction": " 0"}
{"input": "<s> import Data.List <EOL> -- Given an array of non-negative integers, return a copy of the given array after sorting, <EOL> -- you will sort the given array in ascending order if the sum( first index value, last index value) is odd, <EOL> -- or sort it in descending order if the sum( first index value, last index value) is even. <EOL> -- <EOL> -- Note: <EOL> -- * don't change the given array. <EOL> -- <EOL> -- Examples: <EOL> -- >>> sort_array [] <EOL> -- [] <EOL> -- >>> sort_array [5] <EOL> -- [5] <EOL> -- >>> sort_array [2, 4, 3, 0, 1, 5] <EOL> -- [0,1,2,3,4,5] <EOL> -- >>> sort_array [2, 4, 3, 0, 1, 5, 6] <EOL> -- [6,5,4,3,2,1,0] <EOL> sort_array :: [Int] -> [Int] <EOL> sort_array array = <EOL>   if length array == 0 <EOL>     then [] <EOL>     else <EOL>       sortBy <EOL>         ( \\x y -> <EOL>             if (array !! 0 + array !!", "gt": "(length array - 1)) `mod` 2 == 0", "prediction": " 1) `mod` 2 == 0"}
{"input": "<s> import Data.List <EOL> -- Given an array of non-negative integers, return a copy of the given array after sorting, <EOL> -- you will sort the given array in ascending order if the sum( first index value, last index value) is odd, <EOL> -- or sort it in descending order if the sum( first index value, last index value) is even. <EOL> -- <EOL> -- Note: <EOL> -- * don't change the given array. <EOL> -- <EOL> -- Examples: <EOL> -- >>> sort_array [] <EOL> -- [] <EOL> -- >>> sort_array [5] <EOL> -- [5] <EOL> -- >>> sort_array [2, 4, 3, 0, 1, 5] <EOL> -- [0,1,2,3,4,5] <EOL> -- >>> sort_array [2, 4, 3, 0, 1, 5, 6] <EOL> -- [6,5,4,3,2,1,0] <EOL> sort_array :: [Int] -> [Int] <EOL> sort_array array = <EOL>   if length array == 0 <EOL>     then [] <EOL>     else <EOL>       sortBy <EOL>         ( \\x y -> <EOL>             if (array !! 0 + array !! (length array - 1)) `mod` 2 == 0 <EOL>               then compare y x <EOL>               else", "gt": "compare x y", "prediction": " do"}
{"input": "<s> import Data.List (sort, nub) <EOL> -- Return sorted unique elements in a list <EOL> -- >>> unique [5,3,5,2,3,3,9,0,123] <EOL> -- [0,2,3,5,9,123] <EOL> unique :: [Int] -> [Int] <EOL> unique =", "gt": "sort . nub", "prediction": " sort"}
{"input": "<s> import Data.List (sort, nub) <EOL> -- Return sorted unique elements in a list <EOL> -- >>> unique [5,3,5,2,3,3,9,0,123] <EOL> -- [0,2,3,5,9,123] <EOL> unique :: [Int] -> [Int] <EOL> unique = sort .", "gt": "nub", "prediction": " nub"}
{"input": "<s> -- You are given two positive integers n and m, and your task is to compute the <EOL> -- average of the integers from n through m (including n and m). <EOL> -- Round the answer to the nearest integer and convert that to binary. <EOL> -- If n is greater than m, return -1. <EOL> -- Example: <EOL> -- rounded_avg 1 5 => \"0b11\" <EOL> -- rounded_avg 7 5 => -1 <EOL> -- rounded_avg 10 20 => \"0b1111\" <EOL> -- rounded_avg 20 33 => \"0b11010\" <EOL> import Data.Char (intToDigit) <EOL> import Numeric (showIntAtBase) <EOL> rounded_avg :: Int -> Int -> Either Int String <EOL> rounded_avg n m <EOL>   | m < n = Left (-1) <EOL>   | otherwise = <EOL>       let avg = round $ fromIntegral (n + m) / 2 <EOL>        in Right $ \"0b\" ++ Numeric.showIntAtBase 2 Data.Char.intToDigit", "gt": "avg \"\"", "prediction": " avg"}
{"input": "<s> -- You are given two positive integers n and m, and your task is to compute the <EOL> -- average of the integers from n through m (including n and m). <EOL> -- Round the answer to the nearest integer and convert that to binary. <EOL> -- If n is greater than m, return -1. <EOL> -- Example: <EOL> -- rounded_avg 1 5 => \"0b11\" <EOL> -- rounded_avg 7 5 => -1 <EOL> -- rounded_avg 10 20 => \"0b1111\" <EOL> -- rounded_avg 20 33 => \"0b11010\" <EOL> import Data.Char (intToDigit) <EOL> import Numeric (showIntAtBase) <EOL> rounded_avg :: Int -> Int -> Either Int String <EOL> rounded_avg n m <EOL>   | m < n = Left (-1) <EOL>   | otherwise = <EOL>       let avg = round $ fromIntegral", "gt": "(n + m) / 2", "prediction": " n / fromIntegral m"}
{"input": "<s> -- You are given two positive integers n and m, and your task is to compute the <EOL> -- average of the integers from n through m (including n and m). <EOL> -- Round the answer to the nearest integer and convert that to binary. <EOL> -- If n is greater than m, return -1. <EOL> -- Example: <EOL> -- rounded_avg 1 5 => \"0b11\" <EOL> -- rounded_avg 7 5 => -1 <EOL> -- rounded_avg 10 20 => \"0b1111\" <EOL> -- rounded_avg 20 33 => \"0b11010\" <EOL> import Data.Char (intToDigit) <EOL> import Numeric (showIntAtBase) <EOL> rounded_avg :: Int -> Int -> Either Int String <EOL> rounded_avg n m <EOL>   | m < n = Left (-1) <EOL>   | otherwise = <EOL>       let avg = round $ fromIntegral (n + m) / 2 <EOL>        in Right $ \"0b\" ++", "gt": "Numeric.showIntAtBase 2 Data.Char.intToDigit avg \"\"", "prediction": " show avg"}
{"input": "<s> -- You are given two positive integers n and m, and your task is to compute the <EOL> -- average of the integers from n through m (including n and m). <EOL> -- Round the answer to the nearest integer and convert that to binary. <EOL> -- If n is greater than m, return -1. <EOL> -- Example: <EOL> -- rounded_avg 1 5 => \"0b11\" <EOL> -- rounded_avg 7 5 => -1 <EOL> -- rounded_avg 10 20 => \"0b1111\" <EOL> -- rounded_avg 20 33 => \"0b11010\" <EOL> import Data.Char (intToDigit) <EOL> import Numeric (showIntAtBase) <EOL> rounded_avg :: Int -> Int -> Either Int String <EOL> rounded_avg n m <EOL>   | m < n =", "gt": "Left (-1)", "prediction": " Right $ showIntAtBase n (m - n)"}
{"input": "<s> -- You are given two positive integers n and m, and your task is to compute the <EOL> -- average of the integers from n through m (including n and m). <EOL> -- Round the answer to the nearest integer and convert that to binary. <EOL> -- If n is greater than m, return -1. <EOL> -- Example: <EOL> -- rounded_avg 1 5 => \"0b11\" <EOL> -- rounded_avg 7 5 => -1 <EOL> -- rounded_avg 10 20 => \"0b1111\" <EOL> -- rounded_avg 20 33 => \"0b11010\" <EOL> import Data.Char (intToDigit) <EOL> import Numeric (showIntAtBase) <EOL> rounded_avg :: Int -> Int -> Either Int String <EOL> rounded_avg n m <EOL>   | m <", "gt": "n = Left (-1)", "prediction": " 0 = Left (-n)"}
{"input": "<s> -- Given a list of strings, where each string consists of only digits, return a list. <EOL> -- Each element i of the output should be \"the number of odd elements in the <EOL> -- string i of the input.\" where all the i's should be replaced by the number <EOL> -- of odd digits in the i'th string of the input. <EOL> -- <EOL> -- >>> odd_count [\"1234567\"] <EOL> -- [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"] <EOL> -- >>> odd_count [\"3\",\"11111111\"] <EOL> -- [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", <EOL> --  \"the number of odd elements 8n the str8ng 8 of the 8nput.\"] <EOL> odd_count :: [String] -> [String] <EOL> odd_count lst = map countOdd lst <EOL>   where <EOL>     countOdd s = \"the number of odd elements \" ++ show n ++ \"n the str\" ++ show n ++ \"ng \" ++ show n ++ \" of the \" ++ show n ++ \"nput.\" <EOL>       where <EOL>         n = <EOL>           length $ <EOL>             filter odd $ <EOL>               map", "gt": "read $", "prediction": " n map (filter odd)"}
{"input": "<s> -- Given a list of strings, where each string consists of only digits, return a list. <EOL> -- Each element i of the output should be \"the number of odd elements in the <EOL> -- string i of the input.\" where all the i's should be replaced by the number <EOL> -- of odd digits in the i'th string of the input. <EOL> -- <EOL> -- >>> odd_count [\"1234567\"] <EOL> -- [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"] <EOL> -- >>> odd_count [\"3\",\"11111111\"] <EOL> -- [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", <EOL> --  \"the number of odd elements 8n the str8ng 8 of the 8nput.\"] <EOL> odd_count :: [String] -> [String] <EOL> odd_count lst = map countOdd lst <EOL>   where <EOL>     countOdd s = \"the number of odd elements \" ++ show n ++ \"n the str\" ++ show n ++ \"ng \" ++ show n ++ \" of the \" ++ show n ++ \"nput.\" <EOL>       where <EOL>         n = <EOL>           length $ <EOL>             filter", "gt": "odd $", "prediction": "_"}
{"input": "<s> -- Given a list of strings, where each string consists of only digits, return a list. <EOL> -- Each element i of the output should be \"the number of odd elements in the <EOL> -- string i of the input.\" where all the i's should be replaced by the number <EOL> -- of odd digits in the i'th string of the input. <EOL> -- <EOL> -- >>> odd_count [\"1234567\"] <EOL> -- [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"] <EOL> -- >>> odd_count [\"3\",\"11111111\"] <EOL> -- [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", <EOL> --  \"the number of odd elements 8n the str8ng 8 of the 8nput.\"] <EOL> odd_count :: [String] -> [String] <EOL> odd_count lst = map countOdd lst <EOL>   where <EOL>     countOdd s = \"the number of odd elements \" ++ show n ++ \"n the str\" ++ show n ++ \"ng \" ++ show n ++ \" of the \" ++ show n ++ \"nput.\" <EOL>       where <EOL>         n = <EOL>           length $ <EOL>             filter odd $ <EOL>               map read $ <EOL>                 map", "gt": "(: []) s", "prediction": " read $"}
{"input": "<s> -- Given a list of strings, where each string consists of only digits, return a list. <EOL> -- Each element i of the output should be \"the number of odd elements in the <EOL> -- string i of the input.\" where all the i's should be replaced by the number <EOL> -- of odd digits in the i'th string of the input. <EOL> -- <EOL> -- >>> odd_count [\"1234567\"] <EOL> -- [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"] <EOL> -- >>> odd_count [\"3\",\"11111111\"] <EOL> -- [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", <EOL> --  \"the number of odd elements 8n the str8ng 8 of the 8nput.\"] <EOL> odd_count :: [String] -> [String] <EOL> odd_count lst = map countOdd lst <EOL>   where <EOL>     countOdd s = \"the number of odd elements \" ++ show n ++ \"n the str\" ++", "gt": "show n ++ \"ng \" ++ show n ++ \" of the \" ++ show n ++ \"nput.\"", "prediction": " s"}
{"input": "<s> -- Given a list of strings, where each string consists of only digits, return a list. <EOL> -- Each element i of the output should be \"the number of odd elements in the <EOL> -- string i of the input.\" where all the i's should be replaced by the number <EOL> -- of odd digits in the i'th string of the input. <EOL> -- <EOL> -- >>> odd_count [\"1234567\"] <EOL> -- [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"] <EOL> -- >>> odd_count [\"3\",\"11111111\"] <EOL> -- [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", <EOL> --  \"the number of odd elements 8n the str8ng 8 of the 8nput.\"] <EOL> odd_count :: [String] -> [String] <EOL> odd_count lst = map countOdd lst <EOL>   where <EOL>     countOdd s = \"the number of odd elements \" ++ show n ++ \"n the str\" ++ show n ++ \"ng \" ++ show n ++ \" of the \" ++", "gt": "show n ++ \"nput.\"", "prediction": " show n"}
{"input": "<s> -- Input to this function is a string representing musical notes in a special ASCII format. <EOL> -- Your task is to parse this string and return list of integers corresponding to how many beats does each <EOL> -- not last. <EOL> -- <EOL> -- Here is a legend: <EOL> -- 'o' - whole note, lasts four beats <EOL> -- 'o|' - half note, lasts two beats <EOL> -- '.|' - quater note, lasts one beat <EOL> -- <EOL> -- >>> parse_music \"o o| .| o| o| .| .| .| .| o o\" <EOL> -- [4,2,1,2,2,1,1,1,1,4,4] <EOL> parse_music :: String -> [Int] <EOL> parse_music music_string = [note_map x | x <- words music_string] <EOL>     where  <EOL>         note_map \"o\" = 4 <EOL>         note_map \"o|\" =", "gt": "2", "prediction": " 2"}
{"input": "<s> -- Input to this function is a string representing musical notes in a special ASCII format. <EOL> -- Your task is to parse this string and return list of integers corresponding to how many beats does each <EOL> -- not last. <EOL> -- <EOL> -- Here is a legend: <EOL> -- 'o' - whole note, lasts four beats <EOL> -- 'o|' - half note, lasts two beats <EOL> -- '.|' - quater note, lasts one beat <EOL> -- <EOL> -- >>> parse_music \"o o| .| o| o| .| .| .| .| o o\" <EOL> -- [4,2,1,2,2,1,1,1,1,4,4] <EOL> parse_music :: String -> [Int] <EOL> parse_music music_string = [note_map x | x <- words music_string] <EOL>     where  <EOL>         note_map \"o\" = 4 <EOL>         note_map \"o|\" = 2 <EOL>         note_map \".|\" =", "gt": "1", "prediction": " 2"}
{"input": "<s> -- Input to this function is a string representing musical notes in a special ASCII format. <EOL> -- Your task is to parse this string and return list of integers corresponding to how many beats does each <EOL> -- not last. <EOL> -- <EOL> -- Here is a legend: <EOL> -- 'o' - whole note, lasts four beats <EOL> -- 'o|' - half note, lasts two beats <EOL> -- '.|' - quater note, lasts one beat <EOL> -- <EOL> -- >>> parse_music \"o o| .| o| o| .| .| .| .| o o\" <EOL> -- [4,2,1,2,2,1,1,1,1,4,4] <EOL> parse_music :: String -> [Int] <EOL> parse_music music_string = [note_map x | x <- words music_string] <EOL>     where  <EOL>         note_map \"o\" =", "gt": "4", "prediction": " [4,2,1]"}
{"input": "<s> -- Input to this function is a string representing musical notes in a special ASCII format. <EOL> -- Your task is to parse this string and return list of integers corresponding to how many beats does each <EOL> -- not last. <EOL> -- <EOL> -- Here is a legend: <EOL> -- 'o' - whole note, lasts four beats <EOL> -- 'o|' - half note, lasts two beats <EOL> -- '.|' - quater note, lasts one beat <EOL> -- <EOL> -- >>> parse_music \"o o| .| o| o| .| .| .| .| o o\" <EOL> -- [4,2,1,2,2,1,1,1,1,4,4] <EOL> parse_music :: String -> [Int] <EOL> parse_music music_string =", "gt": "[note_map x | x <- words music_string]", "prediction": " undefined"}
{"input": "<s> -- Input to this function is a string representing musical notes in a special ASCII format. <EOL> -- Your task is to parse this string and return list of integers corresponding to how many beats does each <EOL> -- not last. <EOL> -- <EOL> -- Here is a legend: <EOL> -- 'o' - whole note, lasts four beats <EOL> -- 'o|' - half note, lasts two beats <EOL> -- '.|' - quater note, lasts one beat <EOL> -- <EOL> -- >>> parse_music \"o o| .| o| o| .| .| .| .| o o\" <EOL> -- [4,2,1,2,2,1,1,1,1,4,4] <EOL> parse_music :: String -> [Int] <EOL> parse_music music_string = [note_map x | x <-", "gt": "words music_string]", "prediction": " map read $ words music_string]"}
{"input": "<s> -- Given a string text, replace all spaces in it with underscores, <EOL> -- and if a string has more than 2 consecutive spaces, <EOL> -- then replace all consecutive spaces with - <EOL> -- <EOL> -- >>> fix_spaces \"Example\" <EOL> -- \"Example\" <EOL> -- >>> fix_spaces \" Example 2\" <EOL> -- \"_Example_2\" <EOL> -- >>> fix_spaces \" Example 2\" <EOL> -- \"_Example_2\" <EOL> -- >>> fix_spaces \" Example   3\" <EOL> -- \"_Example-3\" <EOL> fix_spaces :: String -> String <EOL> fix_spaces [] = [] <EOL> fix_spaces string = fix_spaces' string 0 \"\" <EOL>   where <EOL>     fix_spaces' :: String -> Int -> String -> String <EOL>     fix_spaces' (x : xs) count res <EOL>       | xs == [] && count == 0 && x == ' ' = res ++ \"_\" <EOL>       | xs == [] && count > 0 && x == ' ' = res ++ \"-\" <EOL>       | xs == [] && count == 0 && x /= ' ' = res ++ [x] <EOL>       | xs == [] && count == 1 && x /= ' ' = res ++ \"_\" ++ [x] <EOL>       | xs == [] && count > 1 && x /= ' ' = res ++ \"-\" ++ [x] <EOL>       | x == ' ' =", "gt": "fix_spaces' xs (count + 1) res", "prediction": " res"}
{"input": "<s> -- Given a string text, replace all spaces in it with underscores, <EOL> -- and if a string has more than 2 consecutive spaces, <EOL> -- then replace all consecutive spaces with - <EOL> -- <EOL> -- >>> fix_spaces \"Example\" <EOL> -- \"Example\" <EOL> -- >>> fix_spaces \" Example 2\" <EOL> -- \"_Example_2\" <EOL> -- >>> fix_spaces \" Example 2\" <EOL> -- \"_Example_2\" <EOL> -- >>> fix_spaces \" Example   3\" <EOL> -- \"_Example-3\" <EOL> fix_spaces :: String -> String <EOL> fix_spaces [] = [] <EOL> fix_spaces string = fix_spaces' string 0 \"\" <EOL>   where <EOL>     fix_spaces' :: String -> Int -> String -> String <EOL>     fix_spaces' (x : xs) count res <EOL>       | xs == [] && count == 0 && x == ' ' = res ++ \"_\" <EOL>       | xs == [] && count > 0 && x == ' ' = res ++ \"-\" <EOL>       | xs == [] && count == 0 && x /= ' ' = res ++ [x] <EOL>       | xs == [] && count == 1 && x /= ' ' = res ++ \"_\" ++ [x] <EOL>       | xs == [] && count > 1 && x /= ' ' = res ++ \"-\" ++ [x] <EOL>       | x == ' ' = fix_spaces' xs (count + 1) res <EOL>       | x /= ' ' && count > 1 = fix_spaces' xs 0 (res ++ \"-\" ++ [x]) <EOL>       | x /= ' ' && count == 1 =", "gt": "fix_spaces' xs 0 (res ++ \"_\" ++ [x])", "prediction": " fix_spaces' xs (count - 1) (x:res)"}
{"input": "<s> -- Given a string text, replace all spaces in it with underscores, <EOL> -- and if a string has more than 2 consecutive spaces, <EOL> -- then replace all consecutive spaces with - <EOL> -- <EOL> -- >>> fix_spaces \"Example\" <EOL> -- \"Example\" <EOL> -- >>> fix_spaces \" Example 2\" <EOL> -- \"_Example_2\" <EOL> -- >>> fix_spaces \" Example 2\" <EOL> -- \"_Example_2\" <EOL> -- >>> fix_spaces \" Example   3\" <EOL> -- \"_Example-3\" <EOL> fix_spaces :: String -> String <EOL> fix_spaces [] =", "gt": "[]", "prediction": " []"}
{"input": "<s> -- Given a string text, replace all spaces in it with underscores, <EOL> -- and if a string has more than 2 consecutive spaces, <EOL> -- then replace all consecutive spaces with - <EOL> -- <EOL> -- >>> fix_spaces \"Example\" <EOL> -- \"Example\" <EOL> -- >>> fix_spaces \" Example 2\" <EOL> -- \"_Example_2\" <EOL> -- >>> fix_spaces \" Example 2\" <EOL> -- \"_Example_2\" <EOL> -- >>> fix_spaces \" Example   3\" <EOL> -- \"_Example-3\" <EOL> fix_spaces :: String -> String <EOL> fix_spaces [] = [] <EOL> fix_spaces string = fix_spaces' string 0 \"\" <EOL>   where <EOL>     fix_spaces' :: String -> Int -> String -> String <EOL>     fix_spaces' (x : xs) count res <EOL>       | xs == [] && count == 0 && x == ' ' = res ++ \"_\" <EOL>       | xs == [] && count > 0 && x == ' ' =", "gt": "res ++ \"-\"", "prediction": " res"}
{"input": "<s> -- Given a string text, replace all spaces in it with underscores, <EOL> -- and if a string has more than 2 consecutive spaces, <EOL> -- then replace all consecutive spaces with - <EOL> -- <EOL> -- >>> fix_spaces \"Example\" <EOL> -- \"Example\" <EOL> -- >>> fix_spaces \" Example 2\" <EOL> -- \"_Example_2\" <EOL> -- >>> fix_spaces \" Example 2\" <EOL> -- \"_Example_2\" <EOL> -- >>> fix_spaces \" Example   3\" <EOL> -- \"_Example-3\" <EOL> fix_spaces :: String -> String <EOL> fix_spaces [] = [] <EOL> fix_spaces string = fix_spaces' string 0 \"\" <EOL>   where <EOL>     fix_spaces' :: String -> Int -> String -> String <EOL>     fix_spaces' (x : xs) count res <EOL>       | xs == [] && count == 0 && x == ' ' = res ++ \"_\" <EOL>       | xs == [] && count > 0 && x == ' ' = res ++ \"-\" <EOL>       | xs == [] && count == 0 && x /= ' ' = res ++ [x] <EOL>       | xs == [] && count == 1 && x /= ' ' = res ++ \"_\" ++ [x] <EOL>       | xs == [] && count > 1 && x /= ' ' = res ++ \"-\" ++ [x] <EOL>       | x == ' ' = fix_spaces' xs (count + 1) res <EOL>       | x /= ' ' && count > 1 = fix_spaces' xs 0 (res ++ \"-\" ++ [x]) <EOL>       | x /= ' ' && count == 1 = fix_spaces' xs 0 (res ++ \"_\" ++ [x]) <EOL>       | otherwise =", "gt": "fix_spaces' xs 0 (res ++ [x])", "prediction": " fix_spaces' xs (count - 1) (res ++ \"_\" ++ [x])"}
{"input": "<s> -- You're given a list of deposit and withdrawal operations on a bank account that starts with <EOL> -- zero balance. Your task is to detect if at any point the balance of account fallls below zero, and <EOL> -- at that point function should return True. Otherwise it should return False. <EOL> -- >>> below_zero [1, 2, 3] <EOL> -- False <EOL> -- >>> below_zero [1, 2, -4, 5] <EOL> -- True <EOL> below_zero :: [Int] -> Bool <EOL> below_zero operations =", "gt": "any (< 0) $ scanl (+) 0 operations", "prediction": " fold"}
{"input": "<s> -- You're given a list of deposit and withdrawal operations on a bank account that starts with <EOL> -- zero balance. Your task is to detect if at any point the balance of account fallls below zero, and <EOL> -- at that point function should return True. Otherwise it should return False. <EOL> -- >>> below_zero [1, 2, 3] <EOL> -- False <EOL> -- >>> below_zero [1, 2, -4, 5] <EOL> -- True <EOL> below_zero :: [Int] -> Bool <EOL> below_zero operations = any (< 0) $", "gt": "scanl (+) 0 operations", "prediction": " zip [1..] operations"}
{"input": "<s> -- brackets is a string of \"(\" and \")\". <EOL> -- return True if every opening bracket has a corresponding closing bracket. <EOL> -- >>> correct_bracketing \"(\" <EOL> -- False <EOL> -- >>> correct_bracketing \"()\" <EOL> -- True <EOL> -- >>> correct_bracketing \"(()())\" <EOL> -- True <EOL> -- >>> correct_bracketing \")(()\" <EOL> -- False <EOL> correct_bracketing :: String -> Bool <EOL> correct_bracketing brackets = <EOL>     let <EOL>         process (depth, flag) b <EOL>             | depth < 0 = (-1, False) <EOL>             | b == '('  = (depth + 1, True) <EOL>             | otherwise = (depth - 1, True) <EOL>     in <EOL>         case foldl process (0, True) brackets of {} <EOL>             (0, True) ->", "gt": "True", "prediction": " True"}
{"input": "<s> -- brackets is a string of \"(\" and \")\". <EOL> -- return True if every opening bracket has a corresponding closing bracket. <EOL> -- >>> correct_bracketing \"(\" <EOL> -- False <EOL> -- >>> correct_bracketing \"()\" <EOL> -- True <EOL> -- >>> correct_bracketing \"(()())\" <EOL> -- True <EOL> -- >>> correct_bracketing \")(()\" <EOL> -- False <EOL> correct_bracketing :: String -> Bool <EOL> correct_bracketing brackets = <EOL>     let <EOL>         process (depth, flag) b <EOL>             | depth < 0 = (-1, False) <EOL>             | b == '('  = (depth + 1, True) <EOL>             | otherwise = (depth - 1, True) <EOL>     in <EOL>         case foldl process (0, True) brackets of {} <EOL>             (0, True) -> True <EOL>             _         ->", "gt": "False", "prediction": " False"}
{"input": "<s> -- brackets is a string of \"(\" and \")\". <EOL> -- return True if every opening bracket has a corresponding closing bracket. <EOL> -- >>> correct_bracketing \"(\" <EOL> -- False <EOL> -- >>> correct_bracketing \"()\" <EOL> -- True <EOL> -- >>> correct_bracketing \"(()())\" <EOL> -- True <EOL> -- >>> correct_bracketing \")(()\" <EOL> -- False <EOL> correct_bracketing :: String -> Bool <EOL> correct_bracketing brackets = <EOL>     let <EOL>         process (depth, flag) b <EOL>             | depth < 0 = (-1, False) <EOL>             | b == '('  = (depth + 1, True) <EOL>             | otherwise =", "gt": "(depth - 1, True)", "prediction": " (depth - 1, False)"}
{"input": "<s> -- brackets is a string of \"(\" and \")\". <EOL> -- return True if every opening bracket has a corresponding closing bracket. <EOL> -- >>> correct_bracketing \"(\" <EOL> -- False <EOL> -- >>> correct_bracketing \"()\" <EOL> -- True <EOL> -- >>> correct_bracketing \"(()())\" <EOL> -- True <EOL> -- >>> correct_bracketing \")(()\" <EOL> -- False <EOL> correct_bracketing :: String -> Bool <EOL> correct_bracketing brackets = <EOL>     let <EOL>         process (depth, flag) b <EOL>             | depth < 0 = (-1, False) <EOL>             | b == '('  =", "gt": "(depth + 1, True)", "prediction": " (depth - 1, True)"}
{"input": "<s> -- brackets is a string of \"(\" and \")\". <EOL> -- return True if every opening bracket has a corresponding closing bracket. <EOL> -- >>> correct_bracketing \"(\" <EOL> -- False <EOL> -- >>> correct_bracketing \"()\" <EOL> -- True <EOL> -- >>> correct_bracketing \"(()())\" <EOL> -- True <EOL> -- >>> correct_bracketing \")(()\" <EOL> -- False <EOL> correct_bracketing :: String -> Bool <EOL> correct_bracketing brackets = <EOL>     let <EOL>         process (depth, flag) b <EOL>             | depth < 0 = (-1, False) <EOL>             | b == '('  = (depth + 1, True) <EOL>             | otherwise = (depth - 1, True) <EOL>     in <EOL>         case foldl process", "gt": "(0, True) brackets of {}", "prediction": " (0, False) brackets of"}
{"input": "<s> -- You are given a non-empty list of positive integers. Return the greatest integer that is greater than <EOL> -- zero, and has a frequency greater than or equal to the value of the integer itself. <EOL> -- The frequency of an integer is the number of times it appears in the list. <EOL> -- If no such a value exist, return -1. <EOL> -- Examples: <EOL> --     search [4, 1, 2, 2, 3, 1] == 2 <EOL> --     search [1, 2, 2, 3, 3, 3, 4, 4, 4] == 3 <EOL> --     search [5, 5, 4, 4, 4] == -1 <EOL> search :: [Int] -> Int <EOL> search lst = let frq = map (\\x -> length (filter (== x) lst)) [0..(maximum lst)] <EOL>              in if null [i | i <- [1..(length frq - 1)], frq !! i >= i] then -1 else maximum [i | i <- [1..(length frq - 1)],", "gt": "frq !! i >= i]", "prediction": " frq !! i < i]"}
{"input": "<s> -- You are given a non-empty list of positive integers. Return the greatest integer that is greater than <EOL> -- zero, and has a frequency greater than or equal to the value of the integer itself. <EOL> -- The frequency of an integer is the number of times it appears in the list. <EOL> -- If no such a value exist, return -1. <EOL> -- Examples: <EOL> --     search [4, 1, 2, 2, 3, 1] == 2 <EOL> --     search [1, 2, 2, 3, 3, 3, 4, 4, 4] == 3 <EOL> --     search [5, 5, 4, 4, 4] == -1 <EOL> search :: [Int] -> Int <EOL> search lst = let frq = map (\\x -> length (filter (== x) lst)) [0..(maximum lst)] <EOL>              in if null [i | i <- [1..(length frq - 1)], frq !! i >= i]", "gt": "then -1 else maximum [i | i <- [1..(length frq - 1)], frq !! i >= i]", "prediction": " then"}
{"input": "<s> -- You are given a non-empty list of positive integers. Return the greatest integer that is greater than <EOL> -- zero, and has a frequency greater than or equal to the value of the integer itself. <EOL> -- The frequency of an integer is the number of times it appears in the list. <EOL> -- If no such a value exist, return -1. <EOL> -- Examples: <EOL> --     search [4, 1, 2, 2, 3, 1] == 2 <EOL> --     search [1, 2, 2, 3, 3, 3, 4, 4, 4] == 3 <EOL> --     search [5, 5, 4, 4, 4] == -1 <EOL> search :: [Int] -> Int <EOL> search lst =", "gt": "let frq = map (\\x -> length (filter (== x) lst)) [0..(maximum lst)]", "prediction": " maximum"}
{"input": "<s> -- You are given a non-empty list of positive integers. Return the greatest integer that is greater than <EOL> -- zero, and has a frequency greater than or equal to the value of the integer itself. <EOL> -- The frequency of an integer is the number of times it appears in the list. <EOL> -- If no such a value exist, return -1. <EOL> -- Examples: <EOL> --     search [4, 1, 2, 2, 3, 1] == 2 <EOL> --     search [1, 2, 2, 3, 3, 3, 4, 4, 4] == 3 <EOL> --     search [5, 5, 4, 4, 4] == -1 <EOL> search :: [Int] -> Int <EOL> search lst = let frq = map (\\x ->", "gt": "length (filter (== x) lst)) [0..(maximum lst)]", "prediction": " ifhead x, length x)) lst"}
{"input": "<s> -- Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers <EOL> -- Example <EOL> -- >>> is_equal_to_sum_even 4 <EOL> -- False <EOL> -- >>> is_equal_to_sum_even 6 <EOL> -- False <EOL> -- >>> is_equal_to_sum_even 8 <EOL> -- True <EOL> is_equal_to_sum_even :: Int -> Bool <EOL> is_equal_to_sum_even n =", "gt": "n `mod` 2 == 0 && n >= 8", "prediction": " sum"}
{"input": "<s> -- Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers <EOL> -- Example <EOL> -- >>> is_equal_to_sum_even 4 <EOL> -- False <EOL> -- >>> is_equal_to_sum_even 6 <EOL> -- False <EOL> -- >>> is_equal_to_sum_even 8 <EOL> -- True <EOL> is_equal_to_sum_even :: Int -> Bool <EOL> is_equal_to_sum_even n = n `mod` 2 == 0 &&", "gt": "n >= 8", "prediction": " n `mod` 4 == 0"}
{"input": "<s> -- Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13. <EOL> -- >>> fizz_buzz 50 <EOL> -- 0 <EOL> -- >>> fizz_buzz 78 <EOL> -- 2 <EOL> -- >>> fizz_buzz 79 <EOL> -- 3 <EOL> fizz_buzz :: Int -> Int <EOL> fizz_buzz = length . filter (== '7') . concatMap show . filter (\\x ->", "gt": "x `mod` 11 == 0 || x `mod` 13 == 0) . enumFromTo 0 . pred", "prediction": " [7..x])"}
{"input": "<s> -- Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13. <EOL> -- >>> fizz_buzz 50 <EOL> -- 0 <EOL> -- >>> fizz_buzz 78 <EOL> -- 2 <EOL> -- >>> fizz_buzz 79 <EOL> -- 3 <EOL> fizz_buzz :: Int -> Int <EOL> fizz_buzz = length . filter (== '7') . concatMap show . filter (\\x -> x `mod` 11 == 0 || x `mod` 13 == 0) .", "gt": "enumFromTo 0 . pred", "prediction": " show"}
{"input": "<s> -- Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13. <EOL> -- >>> fizz_buzz 50 <EOL> -- 0 <EOL> -- >>> fizz_buzz 78 <EOL> -- 2 <EOL> -- >>> fizz_buzz 79 <EOL> -- 3 <EOL> fizz_buzz :: Int -> Int <EOL> fizz_buzz =", "gt": "length . filter (== '7') . concatMap show . filter (\\x -> x `mod` 11 == 0 || x `mod` 13 == 0) . enumFromTo 0 . pred", "prediction": " undefined"}
{"input": "<s> -- Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13. <EOL> -- >>> fizz_buzz 50 <EOL> -- 0 <EOL> -- >>> fizz_buzz 78 <EOL> -- 2 <EOL> -- >>> fizz_buzz 79 <EOL> -- 3 <EOL> fizz_buzz :: Int -> Int <EOL> fizz_buzz = length . filter (== '7') . concatMap show . filter (\\x -> x `mod` 11 == 0 ||", "gt": "x `mod` 13 == 0) . enumFromTo 0 . pred", "prediction": " x `mod` 13 == 0)"}
{"input": "<s> -- Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13. <EOL> -- >>> fizz_buzz 50 <EOL> -- 0 <EOL> -- >>> fizz_buzz 78 <EOL> -- 2 <EOL> -- >>> fizz_buzz 79 <EOL> -- 3 <EOL> fizz_buzz :: Int -> Int <EOL> fizz_buzz = length . filter", "gt": "(== '7') . concatMap show . filter (\\x -> x `mod` 11 == 0 || x `mod` 13 == 0) . enumFromTo 0 . pred", "prediction": " (\\Divisible"}
{"input": "<s> -- Return a string containing space-delimited numbers starting from 0 upto n inclusive. <EOL> -- >>> string_sequence 0 <EOL> -- \"0\" <EOL> -- >>> string_sequence 5 <EOL> -- \"0 1 2 3 4 5\" <EOL> string_sequence :: Int -> String <EOL> string_sequence n =", "gt": "unwords [show x | x <- [0..n]]", "prediction": " replicate n ' '"}
{"input": "<s> -- Return a string containing space-delimited numbers starting from 0 upto n inclusive. <EOL> -- >>> string_sequence 0 <EOL> -- \"0\" <EOL> -- >>> string_sequence 5 <EOL> -- \"0 1 2 3 4 5\" <EOL> string_sequence :: Int -> String <EOL> string_sequence n = unwords [show x | x <-", "gt": "[0..n]]", "prediction": " [1..n]]"}
{"input": "<s> -- Return a string containing space-delimited numbers starting from 0 upto n inclusive. <EOL> -- >>> string_sequence 0 <EOL> -- \"0\" <EOL> -- >>> string_sequence 5 <EOL> -- \"0 1 2 3 4 5\" <EOL> string_sequence :: Int -> String <EOL> string_sequence n = unwords", "gt": "[show x | x <- [0..n]]", "prediction": " $replicate n ' ')"}
{"input": "<s> import Data.List <EOL> -- You are given a 2 dimensional data, as a nested lists, <EOL> -- which is similar to matrix, however, unlike matrices, <EOL> -- each row may contain a different number of columns. <EOL> -- Given lst, and integer x, find integers x in the list, <EOL> -- and return list of tuples, [(x1, y1), (x2, y2) ...] such that <EOL> -- each tuple is a coordinate - (row, columns), starting with 0. <EOL> -- Sort coordinates initially by rows in ascending order. <EOL> -- Also, sort coordinates of the row by columns in descending order. <EOL> -- <EOL> -- Examples: <EOL> -- >>> get_row [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 <EOL> -- [(0,0),(1,4),(1,0),(2,5),(2,0)] <EOL> -- >>> get_row [] 1 <EOL> -- [] <EOL> -- >>> get_row [[], [1], [1, 2, 3]] 3 <EOL> -- [(2,2)] <EOL> get_row :: [[Int]] -> Int -> [(Int, Int)] <EOL> get_row lst x = <EOL>   let coords = <EOL>         [ (i, j) <EOL>           | i <-", "gt": "[0 .. (length lst - 1)],", "prediction": " lst"}
{"input": "<s> import Data.List <EOL> -- You are given a 2 dimensional data, as a nested lists, <EOL> -- which is similar to matrix, however, unlike matrices, <EOL> -- each row may contain a different number of columns. <EOL> -- Given lst, and integer x, find integers x in the list, <EOL> -- and return list of tuples, [(x1, y1), (x2, y2) ...] such that <EOL> -- each tuple is a coordinate - (row, columns), starting with 0. <EOL> -- Sort coordinates initially by rows in ascending order. <EOL> -- Also, sort coordinates of the row by columns in descending order. <EOL> -- <EOL> -- Examples: <EOL> -- >>> get_row [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 <EOL> -- [(0,0),(1,4),(1,0),(2,5),(2,0)] <EOL> -- >>> get_row [] 1 <EOL> -- [] <EOL> -- >>> get_row [[], [1], [1, 2, 3]] 3 <EOL> -- [(2,2)] <EOL> get_row :: [[Int]] -> Int -> [(Int, Int)] <EOL> get_row lst x = <EOL>   let coords = <EOL>         [ (i, j) <EOL>           | i <- [0 .. (length lst - 1)], <EOL>             j <- [0 .. (length (lst !! i) - 1)], <EOL>             (lst !! i) !! j == x <EOL>         ] <EOL>    in sortBy <EOL>         (\\x y -> compare (fst x) (fst y)) <EOL>         ( sortBy <EOL>             (\\x y ->", "gt": "compare (snd y) (snd x))", "prediction": " compare (snd x) (snd y))"}
{"input": "<s> import Data.List <EOL> -- You are given a 2 dimensional data, as a nested lists, <EOL> -- which is similar to matrix, however, unlike matrices, <EOL> -- each row may contain a different number of columns. <EOL> -- Given lst, and integer x, find integers x in the list, <EOL> -- and return list of tuples, [(x1, y1), (x2, y2) ...] such that <EOL> -- each tuple is a coordinate - (row, columns), starting with 0. <EOL> -- Sort coordinates initially by rows in ascending order. <EOL> -- Also, sort coordinates of the row by columns in descending order. <EOL> -- <EOL> -- Examples: <EOL> -- >>> get_row [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 <EOL> -- [(0,0),(1,4),(1,0),(2,5),(2,0)] <EOL> -- >>> get_row [] 1 <EOL> -- [] <EOL> -- >>> get_row [[], [1], [1, 2, 3]] 3 <EOL> -- [(2,2)] <EOL> get_row :: [[Int]] -> Int -> [(Int, Int)] <EOL> get_row lst x = <EOL>   let coords = <EOL>         [ (i, j) <EOL>           | i <- [0 .. (length lst - 1)], <EOL>             j <- [0 .. (length (lst !! i) - 1)], <EOL>             (lst !! i) !! j == x <EOL>         ] <EOL>    in sortBy <EOL>         (\\x y ->", "gt": "compare (fst x) (fst y))", "prediction": " compare (fst x) (fst y))"}
{"input": "<s> import Data.List <EOL> -- You are given a 2 dimensional data, as a nested lists, <EOL> -- which is similar to matrix, however, unlike matrices, <EOL> -- each row may contain a different number of columns. <EOL> -- Given lst, and integer x, find integers x in the list, <EOL> -- and return list of tuples, [(x1, y1), (x2, y2) ...] such that <EOL> -- each tuple is a coordinate - (row, columns), starting with 0. <EOL> -- Sort coordinates initially by rows in ascending order. <EOL> -- Also, sort coordinates of the row by columns in descending order. <EOL> -- <EOL> -- Examples: <EOL> -- >>> get_row [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 <EOL> -- [(0,0),(1,4),(1,0),(2,5),(2,0)] <EOL> -- >>> get_row [] 1 <EOL> -- [] <EOL> -- >>> get_row [[], [1], [1, 2, 3]] 3 <EOL> -- [(2,2)] <EOL> get_row :: [[Int]] -> Int -> [(Int, Int)] <EOL> get_row lst x = <EOL>   let coords = <EOL>         [ (i, j) <EOL>           | i <- [0 .. (length lst - 1)], <EOL>             j <-", "gt": "[0 .. (length (lst !! i) - 1)],", "prediction": " [0 .. (length lst - 1)]"}
{"input": "<s> import Data.List <EOL> -- You are given a 2 dimensional data, as a nested lists, <EOL> -- which is similar to matrix, however, unlike matrices, <EOL> -- each row may contain a different number of columns. <EOL> -- Given lst, and integer x, find integers x in the list, <EOL> -- and return list of tuples, [(x1, y1), (x2, y2) ...] such that <EOL> -- each tuple is a coordinate - (row, columns), starting with 0. <EOL> -- Sort coordinates initially by rows in ascending order. <EOL> -- Also, sort coordinates of the row by columns in descending order. <EOL> -- <EOL> -- Examples: <EOL> -- >>> get_row [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 <EOL> -- [(0,0),(1,4),(1,0),(2,5),(2,0)] <EOL> -- >>> get_row [] 1 <EOL> -- [] <EOL> -- >>> get_row [[], [1], [1, 2, 3]] 3 <EOL> -- [(2,2)] <EOL> get_row :: [[Int]] -> Int -> [(Int, Int)] <EOL> get_row lst x = <EOL>   let coords = <EOL>         [ (i, j) <EOL>           | i <- [0 .. (length lst - 1)], <EOL>             j <- [0 .. (length (lst !! i) - 1)], <EOL>             (lst !! i) !! j", "gt": "== x", "prediction": " ="}
{"input": "<s> -- Create a function which returns the largest index of an element which <EOL> -- is not greater than or equal to the element immediately preceding it. If <EOL> -- no such element exists then return -1. The given array will not contain <EOL> -- uplicate values. <EOL> -- <EOL> -- >>> can_arrange [1,2,4,3,5] <EOL> -- 3 <EOL> -- >>> can_arrange [1,2,3] <EOL> -- -1 <EOL> can_arrange :: [Int] -> Int <EOL> can_arrange arr = can_arrange' arr 1 (-1) <EOL>   where <EOL>     can_arrange' :: [Int] -> Int -> Int -> Int <EOL>     can_arrange' [] index res = res <EOL>     can_arrange' (a : []) index res = res <EOL>     can_arrange' (a : b : xs) index res <EOL>       | a >= b =", "gt": "can_arrange' (b : xs) (index + 1) index", "prediction": " index"}
{"input": "<s> -- Create a function which returns the largest index of an element which <EOL> -- is not greater than or equal to the element immediately preceding it. If <EOL> -- no such element exists then return -1. The given array will not contain <EOL> -- uplicate values. <EOL> -- <EOL> -- >>> can_arrange [1,2,4,3,5] <EOL> -- 3 <EOL> -- >>> can_arrange [1,2,3] <EOL> -- -1 <EOL> can_arrange :: [Int] -> Int <EOL> can_arrange arr = can_arrange' arr 1 (-1) <EOL>   where <EOL>     can_arrange' :: [Int] -> Int -> Int -> Int <EOL>     can_arrange' [] index res = res <EOL>     can_arrange' (a : []) index res = res <EOL>     can_arrange' (a : b : xs) index res <EOL>       | a >= b = can_arrange' (b : xs) (index + 1) index <EOL>       | otherwise =", "gt": "can_arrange' (b : xs) (index + 1) res", "prediction": " index"}
{"input": "<s> -- Create a function which returns the largest index of an element which <EOL> -- is not greater than or equal to the element immediately preceding it. If <EOL> -- no such element exists then return -1. The given array will not contain <EOL> -- uplicate values. <EOL> -- <EOL> -- >>> can_arrange [1,2,4,3,5] <EOL> -- 3 <EOL> -- >>> can_arrange [1,2,3] <EOL> -- -1 <EOL> can_arrange :: [Int] -> Int <EOL> can_arrange arr = can_arrange' arr 1 (-1) <EOL>   where <EOL>     can_arrange' :: [Int] -> Int -> Int -> Int <EOL>     can_arrange' [] index res = res <EOL>     can_arrange' (a : []) index res =", "gt": "res", "prediction": " index"}
{"input": "<s> -- Create a function which returns the largest index of an element which <EOL> -- is not greater than or equal to the element immediately preceding it. If <EOL> -- no such element exists then return -1. The given array will not contain <EOL> -- uplicate values. <EOL> -- <EOL> -- >>> can_arrange [1,2,4,3,5] <EOL> -- 3 <EOL> -- >>> can_arrange [1,2,3] <EOL> -- -1 <EOL> can_arrange :: [Int] -> Int <EOL> can_arrange arr =", "gt": "can_arrange' arr 1 (-1)", "prediction": " maximum"}
{"input": "<s> -- Create a function which returns the largest index of an element which <EOL> -- is not greater than or equal to the element immediately preceding it. If <EOL> -- no such element exists then return -1. The given array will not contain <EOL> -- uplicate values. <EOL> -- <EOL> -- >>> can_arrange [1,2,4,3,5] <EOL> -- 3 <EOL> -- >>> can_arrange [1,2,3] <EOL> -- -1 <EOL> can_arrange :: [Int] -> Int <EOL> can_arrange arr = can_arrange' arr 1 (-1) <EOL>   where <EOL>     can_arrange' :: [Int] -> Int -> Int -> Int <EOL>     can_arrange' [] index res =", "gt": "res", "prediction": " res"}
{"input": "<s> -- You are given an array arr of integers and you need to return <EOL> -- sum of magnitudes of integers multiplied by product of all signs <EOL> -- of each number in the array, represented by 1, -1 or 0. <EOL> -- Note: return None for empty arr. <EOL> --  <EOL> -- Example: <EOL> -- >>> prod_signs [1, 2, 2, -4] == Just (-9) <EOL> -- >>> prod_signs [0, 1] == Just 0 <EOL> -- >>> prod_signs [] == Nothing <EOL> prod_signs :: [Int] -> Maybe Int <EOL> prod_signs arr <EOL>   | null arr = Nothing <EOL>   | otherwise = Just $ prod * sum (map abs arr) <EOL>   where <EOL>     prod :: Int <EOL>     prod = if 0 `elem` arr then 0 else", "gt": "(-1) ^ length (filter (< 0) arr)", "prediction": " prod"}
{"input": "<s> -- You are given an array arr of integers and you need to return <EOL> -- sum of magnitudes of integers multiplied by product of all signs <EOL> -- of each number in the array, represented by 1, -1 or 0. <EOL> -- Note: return None for empty arr. <EOL> --  <EOL> -- Example: <EOL> -- >>> prod_signs [1, 2, 2, -4] == Just (-9) <EOL> -- >>> prod_signs [0, 1] == Just 0 <EOL> -- >>> prod_signs [] == Nothing <EOL> prod_signs :: [Int] -> Maybe Int <EOL> prod_signs arr <EOL>   | null arr = Nothing <EOL>   | otherwise =", "gt": "Just $ prod * sum (map abs arr)", "prediction": " Just"}
{"input": "<s> -- You are given an array arr of integers and you need to return <EOL> -- sum of magnitudes of integers multiplied by product of all signs <EOL> -- of each number in the array, represented by 1, -1 or 0. <EOL> -- Note: return None for empty arr. <EOL> --  <EOL> -- Example: <EOL> -- >>> prod_signs [1, 2, 2, -4] == Just (-9) <EOL> -- >>> prod_signs [0, 1] == Just 0 <EOL> -- >>> prod_signs [] == Nothing <EOL> prod_signs :: [Int] -> Maybe Int <EOL> prod_signs arr <EOL>   | null arr =", "gt": "Nothing", "prediction": " Nothing"}
{"input": "<s> -- You are given an array arr of integers and you need to return <EOL> -- sum of magnitudes of integers multiplied by product of all signs <EOL> -- of each number in the array, represented by 1, -1 or 0. <EOL> -- Note: return None for empty arr. <EOL> --  <EOL> -- Example: <EOL> -- >>> prod_signs [1, 2, 2, -4] == Just (-9) <EOL> -- >>> prod_signs [0, 1] == Just 0 <EOL> -- >>> prod_signs [] == Nothing <EOL> prod_signs :: [Int] -> Maybe Int <EOL> prod_signs arr <EOL>   | null arr = Nothing <EOL>   | otherwise = Just $ prod * sum (map abs arr) <EOL>   where <EOL>     prod :: Int <EOL>     prod =", "gt": "if 0 `elem` arr then 0 else (-1) ^ length (filter (< 0) arr)", "prediction": " sum"}
{"input": "<s> -- You are given a word. Your task is to find the closest vowel that stands between <EOL> -- two consonants from the right side of the word (case sensitive). <EOL> -- <EOL> -- Vowels in the beginning and ending doesn't count. Return empty string if you didn't <EOL> -- find any vowel met the above condition. <EOL> -- <EOL> -- You may assume that the given string contains English letter only. <EOL> -- <EOL> -- Example: <EOL> -- get_closest_vowel \"yogurt\" ==> \"u\" <EOL> -- get_closest_vowel \"FULL\" ==> \"U\" <EOL> -- get_closest_vowel \"quick\" ==> \"\" <EOL> -- get_closest_vowel \"ab\" ==> \"\" <EOL> get_closest_vowel :: String -> String <EOL> get_closest_vowel word = f (reverse word) <EOL>   where <EOL>     f (x : y : z : xs) = <EOL>       if vowel y && consonant x && consonant z <EOL>         then [y] <EOL>         else f (y : z : xs) <EOL>     f _ = \"\" <EOL>     vowel x =", "gt": "x `elem` \"aeiouAEIOU\"", "prediction": " if"}
{"input": "<s> -- You are given a word. Your task is to find the closest vowel that stands between <EOL> -- two consonants from the right side of the word (case sensitive). <EOL> -- <EOL> -- Vowels in the beginning and ending doesn't count. Return empty string if you didn't <EOL> -- find any vowel met the above condition. <EOL> -- <EOL> -- You may assume that the given string contains English letter only. <EOL> -- <EOL> -- Example: <EOL> -- get_closest_vowel \"yogurt\" ==> \"u\" <EOL> -- get_closest_vowel \"FULL\" ==> \"U\" <EOL> -- get_closest_vowel \"quick\" ==> \"\" <EOL> -- get_closest_vowel \"ab\" ==> \"\" <EOL> get_closest_vowel :: String -> String <EOL> get_closest_vowel word = f (reverse word) <EOL>   where <EOL>     f (x : y : z : xs) = <EOL>       if vowel y && consonant x && consonant z <EOL>         then [y] <EOL>         else f (y : z : xs) <EOL>     f _ = \"\" <EOL>     vowel x = x `elem` \"aeiouAEIOU\" <EOL>     consonant =", "gt": "not . vowel", "prediction": " isConsonant vowel"}
{"input": "<s> -- You are given a word. Your task is to find the closest vowel that stands between <EOL> -- two consonants from the right side of the word (case sensitive). <EOL> -- <EOL> -- Vowels in the beginning and ending doesn't count. Return empty string if you didn't <EOL> -- find any vowel met the above condition. <EOL> -- <EOL> -- You may assume that the given string contains English letter only. <EOL> -- <EOL> -- Example: <EOL> -- get_closest_vowel \"yogurt\" ==> \"u\" <EOL> -- get_closest_vowel \"FULL\" ==> \"U\" <EOL> -- get_closest_vowel \"quick\" ==> \"\" <EOL> -- get_closest_vowel \"ab\" ==> \"\" <EOL> get_closest_vowel :: String -> String <EOL> get_closest_vowel word = f (reverse", "gt": "word)", "prediction": " word)"}
{"input": "<s> -- You are given a word. Your task is to find the closest vowel that stands between <EOL> -- two consonants from the right side of the word (case sensitive). <EOL> -- <EOL> -- Vowels in the beginning and ending doesn't count. Return empty string if you didn't <EOL> -- find any vowel met the above condition. <EOL> -- <EOL> -- You may assume that the given string contains English letter only. <EOL> -- <EOL> -- Example: <EOL> -- get_closest_vowel \"yogurt\" ==> \"u\" <EOL> -- get_closest_vowel \"FULL\" ==> \"U\" <EOL> -- get_closest_vowel \"quick\" ==> \"\" <EOL> -- get_closest_vowel \"ab\" ==> \"\" <EOL> get_closest_vowel :: String -> String <EOL> get_closest_vowel word = f (reverse word) <EOL>   where <EOL>     f (x : y : z : xs) = <EOL>       if vowel y && consonant x && consonant z <EOL>         then [y] <EOL>         else f (y : z : xs) <EOL>     f _ =", "gt": "\"\"", "prediction": " []"}
{"input": "<s> -- You are given a word. Your task is to find the closest vowel that stands between <EOL> -- two consonants from the right side of the word (case sensitive). <EOL> -- <EOL> -- Vowels in the beginning and ending doesn't count. Return empty string if you didn't <EOL> -- find any vowel met the above condition. <EOL> -- <EOL> -- You may assume that the given string contains English letter only. <EOL> -- <EOL> -- Example: <EOL> -- get_closest_vowel \"yogurt\" ==> \"u\" <EOL> -- get_closest_vowel \"FULL\" ==> \"U\" <EOL> -- get_closest_vowel \"quick\" ==> \"\" <EOL> -- get_closest_vowel \"ab\" ==> \"\" <EOL> get_closest_vowel :: String -> String <EOL> get_closest_vowel word = f (reverse word) <EOL>   where <EOL>     f (x : y : z : xs) = <EOL>       if vowel y && consonant x &&", "gt": "consonant z", "prediction": " consonant y && consonant z"}
{"input": "<s> -- Write a function that returns true if the given number is the multiplication of 3 prime numbers <EOL> -- and false otherwise. <EOL> -- Knowing that (a) is less then 100. <EOL> -- Example: <EOL> -- is_multiply_prime 30 == True <EOL> -- 30 = 2 * 3 * 5 <EOL> is_multiply_prime :: Int -> Bool <EOL> is_multiply_prime a =", "gt": "let is_prime n = null [i | i <- [2..(n-1)], n `mod` i == 0]", "prediction": " a"}
{"input": "<s> -- Write a function that returns true if the given number is the multiplication of 3 prime numbers <EOL> -- and false otherwise. <EOL> -- Knowing that (a) is less then 100. <EOL> -- Example: <EOL> -- is_multiply_prime 30 == True <EOL> -- 30 = 2 * 3 * 5 <EOL> is_multiply_prime :: Int -> Bool <EOL> is_multiply_prime a = let is_prime n = null [i | i <- [2..(n-1)], n `mod` i == 0] <EOL>                       in or [is_prime i && is_prime j && is_prime k && i * j * k == a | i <- [2..100], j <-", "gt": "[2..100], k <- [2..100]]", "prediction": " [2..(n-1)], k <- [2..(n-1)]]"}
{"input": "<s> -- Write a function that returns true if the given number is the multiplication of 3 prime numbers <EOL> -- and false otherwise. <EOL> -- Knowing that (a) is less then 100. <EOL> -- Example: <EOL> -- is_multiply_prime 30 == True <EOL> -- 30 = 2 * 3 * 5 <EOL> is_multiply_prime :: Int -> Bool <EOL> is_multiply_prime a = let is_prime n =", "gt": "null [i | i <- [2..(n-1)], n `mod` i == 0]", "prediction": " n `mod` 3 == 0"}
{"input": "<s> -- You are given two intervals, <EOL> -- where each interval is a pair of integers. For example, interval = (start, end) = (1, 2). <EOL> -- The given intervals are closed which means that the interval (start, end) <EOL> -- includes both start and end. <EOL> -- For each given interval, it is assumed that its start is less or equal its end. <EOL> -- Your task is to determine whether the length of intersection of these two  <EOL> -- intervals is a prime number. <EOL> -- Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3) <EOL> -- which its length is 1, which not a prime number. <EOL> -- If the length of the intersection is a prime number, return \"YES\", <EOL> -- otherwise, return \"NO\". <EOL> -- If the two intervals don't intersect, return \"NO\". <EOL> --  <EOL> --  <EOL> -- [input/output] samples: <EOL> -- intersection (1, 2) (2, 3) ==> \"NO\" <EOL> -- intersection (-1, 1) (0, 4) ==> \"NO\" <EOL> -- intersection (-3, -1) (-5, 5) ==> \"YES\" <EOL> intersection :: (Int, Int) -> (Int, Int) -> String <EOL> intersection (a, b) (c, d) <EOL>   | b < c || d < a = \"NO\" <EOL>   | otherwise =", "gt": "if isPrime (abs (min b d - max a c)) then \"YES\" else \"NO\"", "prediction": " show"}
{"input": "<s> -- You are given two intervals, <EOL> -- where each interval is a pair of integers. For example, interval = (start, end) = (1, 2). <EOL> -- The given intervals are closed which means that the interval (start, end) <EOL> -- includes both start and end. <EOL> -- For each given interval, it is assumed that its start is less or equal its end. <EOL> -- Your task is to determine whether the length of intersection of these two  <EOL> -- intervals is a prime number. <EOL> -- Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3) <EOL> -- which its length is 1, which not a prime number. <EOL> -- If the length of the intersection is a prime number, return \"YES\", <EOL> -- otherwise, return \"NO\". <EOL> -- If the two intervals don't intersect, return \"NO\". <EOL> --  <EOL> --  <EOL> -- [input/output] samples: <EOL> -- intersection (1, 2) (2, 3) ==> \"NO\" <EOL> -- intersection (-1, 1) (0, 4) ==> \"NO\" <EOL> -- intersection (-3, -1) (-5, 5) ==> \"YES\" <EOL> intersection :: (Int, Int) -> (Int, Int) -> String <EOL> intersection (a, b) (c, d) <EOL>   | b < c || d < a = \"NO\" <EOL>   | otherwise = if isPrime (abs (min b d - max a c)) then \"YES\" else \"NO\" <EOL>   where <EOL>     isPrime :: Int -> Bool <EOL>     isPrime n =", "gt": "n > 1 && all (\\k -> n `mod` k /= 0) [2..floor (sqrt (fromIntegral n))]", "prediction": " if"}
{"input": "<s> -- You are given two intervals, <EOL> -- where each interval is a pair of integers. For example, interval = (start, end) = (1, 2). <EOL> -- The given intervals are closed which means that the interval (start, end) <EOL> -- includes both start and end. <EOL> -- For each given interval, it is assumed that its start is less or equal its end. <EOL> -- Your task is to determine whether the length of intersection of these two  <EOL> -- intervals is a prime number. <EOL> -- Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3) <EOL> -- which its length is 1, which not a prime number. <EOL> -- If the length of the intersection is a prime number, return \"YES\", <EOL> -- otherwise, return \"NO\". <EOL> -- If the two intervals don't intersect, return \"NO\". <EOL> --  <EOL> --  <EOL> -- [input/output] samples: <EOL> -- intersection (1, 2) (2, 3) ==> \"NO\" <EOL> -- intersection (-1, 1) (0, 4) ==> \"NO\" <EOL> -- intersection (-3, -1) (-5, 5) ==> \"YES\" <EOL> intersection :: (Int, Int) -> (Int, Int) -> String <EOL> intersection (a, b) (c, d) <EOL>   | b < c || d < a = \"NO\" <EOL>   | otherwise = if isPrime (abs (min b d - max a c)) then", "gt": "\"YES\" else \"NO\"", "prediction": " \"NO\""}
{"input": "<s> -- Write a function that takes a string and returns True if the string <EOL> -- length is a prime number or False otherwise <EOL> -- Examples <EOL> -- prime_length \"Hello\" == True <EOL> -- prime_length \"abcdcba\" == True <EOL> -- prime_length \"kittens\" == True <EOL> -- prime_length \"orange\" == False <EOL> prime_length :: String -> Bool <EOL> prime_length string = let l = length string <EOL>                       in l /= 0 && l /= 1 && null [i | i <-", "gt": "[2..(l-1)], l `mod` i == 0]", "prediction": " [1..l]]"}
{"input": "<s> -- Write a function that takes a string and returns True if the string <EOL> -- length is a prime number or False otherwise <EOL> -- Examples <EOL> -- prime_length \"Hello\" == True <EOL> -- prime_length \"abcdcba\" == True <EOL> -- prime_length \"kittens\" == True <EOL> -- prime_length \"orange\" == False <EOL> prime_length :: String -> Bool <EOL> prime_length string = let l =", "gt": "length string", "prediction": " length string in"}
{"input": "<s> -- Given a list of positive integers x. return a sorted list of all <EOL> -- elements that hasn't any even digit. <EOL> -- <EOL> -- Note: Returned list should be sorted in increasing order. <EOL> -- <EOL> -- For example: <EOL> -- >>> unique_digits [15, 33, 1422, 1] <EOL> -- [1,15,33] <EOL> -- >>> unique_digits [152, 323, 1422, 10] <EOL> -- [] <EOL> import Data.Char (digitToInt) <EOL> import Data.List (sort) <EOL> unique_digits :: [Int] -> [Int] <EOL> unique_digits x = sort $ filter <EOL>       (all odd .", "gt": "map digitToInt . show)", "prediction": " map digitToInt $ x)"}
{"input": "<s> -- Given a list of positive integers x. return a sorted list of all <EOL> -- elements that hasn't any even digit. <EOL> -- <EOL> -- Note: Returned list should be sorted in increasing order. <EOL> -- <EOL> -- For example: <EOL> -- >>> unique_digits [15, 33, 1422, 1] <EOL> -- [1,15,33] <EOL> -- >>> unique_digits [152, 323, 1422, 10] <EOL> -- [] <EOL> import Data.Char (digitToInt) <EOL> import Data.List (sort) <EOL> unique_digits :: [Int] -> [Int] <EOL> unique_digits x = sort $ filter <EOL>       (all odd . map digitToInt .", "gt": "show)", "prediction": " filter $ x)"}
{"input": "<s> -- Given a list of positive integers x. return a sorted list of all <EOL> -- elements that hasn't any even digit. <EOL> -- <EOL> -- Note: Returned list should be sorted in increasing order. <EOL> -- <EOL> -- For example: <EOL> -- >>> unique_digits [15, 33, 1422, 1] <EOL> -- [1,15,33] <EOL> -- >>> unique_digits [152, 323, 1422, 10] <EOL> -- [] <EOL> import Data.Char (digitToInt) <EOL> import Data.List (sort) <EOL> unique_digits :: [Int] -> [Int] <EOL> unique_digits x =", "gt": "sort $ filter", "prediction": " ["}
{"input": "<s> -- Write a function that accepts two lists of strings and returns the list that has <EOL> -- total number of chars in the all strings of the list less than the other list. <EOL> -- <EOL> -- if the two lists have the same number of chars, return the first list. <EOL> -- <EOL> -- Examples <EOL> -- total_match [] [] == [] <EOL> -- total_match [\"hi\", \"admin\"] [\"hI\", \"Hi\"] == [\"hI\", \"Hi\"] <EOL> -- total_match [\"hi\", \"admin\"] [\"hi\", \"hi\", \"admin\", \"project\"] == [\"hi\", \"admin\"] <EOL> -- total_match [\"hi\", \"admin\"] [\"hI\", \"hi\", \"hi\"] == [\"hI\", \"hi\", \"hi\"] <EOL> -- total_match [\"4\"] [\"1\", \"2\", \"3\", \"4\", \"5\"] == [\"4\"] <EOL> total_match :: [String] -> [String] -> [String] <EOL> total_match lst1 lst2 = if sum (map length lst1) <= sum (map length lst2) then", "gt": "lst1 else lst2", "prediction": " lst1 ++ lst2 else []"}
{"input": "<s> -- Write a function that accepts two lists of strings and returns the list that has <EOL> -- total number of chars in the all strings of the list less than the other list. <EOL> -- <EOL> -- if the two lists have the same number of chars, return the first list. <EOL> -- <EOL> -- Examples <EOL> -- total_match [] [] == [] <EOL> -- total_match [\"hi\", \"admin\"] [\"hI\", \"Hi\"] == [\"hI\", \"Hi\"] <EOL> -- total_match [\"hi\", \"admin\"] [\"hi\", \"hi\", \"admin\", \"project\"] == [\"hi\", \"admin\"] <EOL> -- total_match [\"hi\", \"admin\"] [\"hI\", \"hi\", \"hi\"] == [\"hI\", \"hi\", \"hi\"] <EOL> -- total_match [\"4\"] [\"1\", \"2\", \"3\", \"4\", \"5\"] == [\"4\"] <EOL> total_match :: [String] -> [String] -> [String] <EOL> total_match lst1 lst2 = if sum (map length lst1) <=", "gt": "sum (map length lst2) then lst1 else lst2", "prediction": " sum (map length lst2)"}
{"input": "<s> -- Write a function that accepts two lists of strings and returns the list that has <EOL> -- total number of chars in the all strings of the list less than the other list. <EOL> -- <EOL> -- if the two lists have the same number of chars, return the first list. <EOL> -- <EOL> -- Examples <EOL> -- total_match [] [] == [] <EOL> -- total_match [\"hi\", \"admin\"] [\"hI\", \"Hi\"] == [\"hI\", \"Hi\"] <EOL> -- total_match [\"hi\", \"admin\"] [\"hi\", \"hi\", \"admin\", \"project\"] == [\"hi\", \"admin\"] <EOL> -- total_match [\"hi\", \"admin\"] [\"hI\", \"hi\", \"hi\"] == [\"hI\", \"hi\", \"hi\"] <EOL> -- total_match [\"4\"] [\"1\", \"2\", \"3\", \"4\", \"5\"] == [\"4\"] <EOL> total_match :: [String] -> [String] -> [String] <EOL> total_match lst1 lst2 =", "gt": "if sum (map length lst1) <= sum (map length lst2) then lst1 else lst2", "prediction": " ["}
{"input": "<s> -- Given the lengths of the three sides of a triangle. Return the area of <EOL> -- the triangle rounded to 2 decimal points if the three sides form a valid triangle. <EOL> -- Otherwise return -1 <EOL> -- Three sides make a valid triangle when the sum of any two sides is greater <EOL> -- than the third side. <EOL> -- Example: <EOL> -- triangle_area 3 4 5 == 6.00 <EOL> -- triangle_area 1 2 10 == -1 <EOL> triangle_area :: Double -> Double -> Double -> Double <EOL> triangle_area a b c = if a + b <= c || a + c <= b || b + c <= a then -1 else", "gt": "round' (sqrt (s * (s - a) * (s - b) * (s - c))) 2", "prediction": " 1"}
{"input": "<s> -- Given the lengths of the three sides of a triangle. Return the area of <EOL> -- the triangle rounded to 2 decimal points if the three sides form a valid triangle. <EOL> -- Otherwise return -1 <EOL> -- Three sides make a valid triangle when the sum of any two sides is greater <EOL> -- than the third side. <EOL> -- Example: <EOL> -- triangle_area 3 4 5 == 6.00 <EOL> -- triangle_area 1 2 10 == -1 <EOL> triangle_area :: Double -> Double -> Double -> Double <EOL> triangle_area a b c = if a + b <= c || a + c <= b || b + c <= a then -1 else round' (sqrt (s * (s - a) * (s - b) * (s - c))) 2 <EOL>                       where  <EOL>                         s :: Double <EOL>                         s =", "gt": "(a + b + c) / 2", "prediction": " sqrt (s * (s - a) * (s - b) * (s - c))"}
{"input": "<s> -- Given the lengths of the three sides of a triangle. Return the area of <EOL> -- the triangle rounded to 2 decimal points if the three sides form a valid triangle. <EOL> -- Otherwise return -1 <EOL> -- Three sides make a valid triangle when the sum of any two sides is greater <EOL> -- than the third side. <EOL> -- Example: <EOL> -- triangle_area 3 4 5 == 6.00 <EOL> -- triangle_area 1 2 10 == -1 <EOL> triangle_area :: Double -> Double -> Double -> Double <EOL> triangle_area a b c = if a + b <= c || a + c <= b || b + c <= a then -1 else round' (sqrt (s * (s - a) * (s - b) * (s - c))) 2 <EOL>                       where  <EOL>                         s :: Double <EOL>                         s = (a + b + c) / 2 <EOL>                         round' x n =", "gt": "(fromInteger $ round $ x * (10^n)) / (10.0^^n)", "prediction": " round (x * x + n * n)"}
{"input": "<s> -- Given the lengths of the three sides of a triangle. Return the area of <EOL> -- the triangle rounded to 2 decimal points if the three sides form a valid triangle. <EOL> -- Otherwise return -1 <EOL> -- Three sides make a valid triangle when the sum of any two sides is greater <EOL> -- than the third side. <EOL> -- Example: <EOL> -- triangle_area 3 4 5 == 6.00 <EOL> -- triangle_area 1 2 10 == -1 <EOL> triangle_area :: Double -> Double -> Double -> Double <EOL> triangle_area a b c =", "gt": "if a + b <= c || a + c <= b || b + c <= a then -1 else round' (sqrt (s * (s - a) * (s - b) * (s - c))) 2", "prediction": " if"}
{"input": "<s> -- Given a positive integer n, return a tuple that has the number of even and odd <EOL> -- integer palindromes that fall within the range(1, n), inclusive. <EOL> --  <EOL> -- Example 1: <EOL> --  <EOL> --     Input: 3 <EOL> --     Output: (1,2) <EOL> --     Explanation: <EOL> --     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd. <EOL> --  <EOL> -- Example 2: <EOL> --  <EOL> --     Input: 12 <EOL> --     Output: (4,6) <EOL> --     Explanation: <EOL> --     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd. <EOL> --  <EOL> -- Note: <EOL> --     1. 1 <= n <= 10^3 <EOL> --     2. returned tuple has the number of even and odd integer palindromes respectively. <EOL> even_odd_palindrome :: Int -> (Int, Int) <EOL> even_odd_palindrome n = (evenCount, oddCount) <EOL>   where <EOL>     isPalindrome x = show x == reverse (show x) <EOL>     evenCount = length [x | x <-", "gt": "[1..n], isPalindrome x, even x]", "prediction": " [1..n]]"}
{"input": "<s> -- Given a positive integer n, return a tuple that has the number of even and odd <EOL> -- integer palindromes that fall within the range(1, n), inclusive. <EOL> --  <EOL> -- Example 1: <EOL> --  <EOL> --     Input: 3 <EOL> --     Output: (1,2) <EOL> --     Explanation: <EOL> --     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd. <EOL> --  <EOL> -- Example 2: <EOL> --  <EOL> --     Input: 12 <EOL> --     Output: (4,6) <EOL> --     Explanation: <EOL> --     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd. <EOL> --  <EOL> -- Note: <EOL> --     1. 1 <= n <= 10^3 <EOL> --     2. returned tuple has the number of even and odd integer palindromes respectively. <EOL> even_odd_palindrome :: Int -> (Int, Int) <EOL> even_odd_palindrome n = (evenCount, oddCount) <EOL>   where <EOL>     isPalindrome x = show x == reverse", "gt": "(show x)", "prediction": " (reverse isPalindrome)"}
{"input": "<s> -- Given a positive integer n, return a tuple that has the number of even and odd <EOL> -- integer palindromes that fall within the range(1, n), inclusive. <EOL> --  <EOL> -- Example 1: <EOL> --  <EOL> --     Input: 3 <EOL> --     Output: (1,2) <EOL> --     Explanation: <EOL> --     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd. <EOL> --  <EOL> -- Example 2: <EOL> --  <EOL> --     Input: 12 <EOL> --     Output: (4,6) <EOL> --     Explanation: <EOL> --     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd. <EOL> --  <EOL> -- Note: <EOL> --     1. 1 <= n <= 10^3 <EOL> --     2. returned tuple has the number of even and odd integer palindromes respectively. <EOL> even_odd_palindrome :: Int -> (Int, Int) <EOL> even_odd_palindrome n = (evenCount, oddCount) <EOL>   where <EOL>     isPalindrome x = show x == reverse (show x) <EOL>     evenCount = length [x | x <- [1..n], isPalindrome x, even x] <EOL>     oddCount = length [x | x <- [1..n], isPalindrome x,", "gt": "odd x]", "prediction": " odd x]"}
{"input": "<s> -- Given a positive integer n, return a tuple that has the number of even and odd <EOL> -- integer palindromes that fall within the range(1, n), inclusive. <EOL> --  <EOL> -- Example 1: <EOL> --  <EOL> --     Input: 3 <EOL> --     Output: (1,2) <EOL> --     Explanation: <EOL> --     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd. <EOL> --  <EOL> -- Example 2: <EOL> --  <EOL> --     Input: 12 <EOL> --     Output: (4,6) <EOL> --     Explanation: <EOL> --     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd. <EOL> --  <EOL> -- Note: <EOL> --     1. 1 <= n <= 10^3 <EOL> --     2. returned tuple has the number of even and odd integer palindromes respectively. <EOL> even_odd_palindrome :: Int -> (Int, Int) <EOL> even_odd_palindrome n = (evenCount, oddCount) <EOL>   where <EOL>     isPalindrome x = show x == reverse (show x) <EOL>     evenCount = length [x | x <- [1..n], isPalindrome x,", "gt": "even x]", "prediction": " even x]"}
{"input": "<s> -- Given a positive integer n, return a tuple that has the number of even and odd <EOL> -- integer palindromes that fall within the range(1, n), inclusive. <EOL> --  <EOL> -- Example 1: <EOL> --  <EOL> --     Input: 3 <EOL> --     Output: (1,2) <EOL> --     Explanation: <EOL> --     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd. <EOL> --  <EOL> -- Example 2: <EOL> --  <EOL> --     Input: 12 <EOL> --     Output: (4,6) <EOL> --     Explanation: <EOL> --     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd. <EOL> --  <EOL> -- Note: <EOL> --     1. 1 <= n <= 10^3 <EOL> --     2. returned tuple has the number of even and odd integer palindromes respectively. <EOL> even_odd_palindrome :: Int -> (Int, Int) <EOL> even_odd_palindrome n = (evenCount, oddCount) <EOL>   where <EOL>     isPalindrome x = show x == reverse (show x) <EOL>     evenCount = length [x | x <- [1..n], isPalindrome x, even x] <EOL>     oddCount = length [x | x <-", "gt": "[1..n], isPalindrome x, odd x]", "prediction": " [1..n], odd x]"}
{"input": "<s> -- Return list of all prefixes from shortest to longest of the input string <EOL> -- >>> all_prefixes \"abc\" <EOL> -- [\"a\",\"ab\",\"abc\"] <EOL> all_prefixes :: String  -> [String] <EOL> all_prefixes string = [take (i+1) string | i <-", "gt": "[0..length string - 1]]", "prediction": " [0..(length string)-1]]"}
{"input": "<s> -- Return list of all prefixes from shortest to longest of the input string <EOL> -- >>> all_prefixes \"abc\" <EOL> -- [\"a\",\"ab\",\"abc\"] <EOL> all_prefixes :: String  -> [String] <EOL> all_prefixes string =", "gt": "[take (i+1) string | i <- [0..length string - 1]]", "prediction": " let"}
{"input": "<s> -- Return list of all prefixes from shortest to longest of the input string <EOL> -- >>> all_prefixes \"abc\" <EOL> -- [\"a\",\"ab\",\"abc\"] <EOL> all_prefixes :: String  -> [String] <EOL> all_prefixes string = [take (i+1) string |", "gt": "i <- [0..length string - 1]]", "prediction": " i <- [0..(length string)-1]]"}
{"input": "<s> -- For a given list of input numbers, calculate Mean Absolute Deviation <EOL> -- around the mean of this dataset. <EOL> -- Mean Absolute Deviation is the average absolute difference between each <EOL> -- element and a centerpoint (mean in this case): <EOL> -- MAD = average | x - x_mean | <EOL> -- >>> mean_absolute_deviation [1.0, 2.0, 3.0, 4.0] <EOL> -- 1.0 <EOL> mean_absolute_deviation :: [Float] -> Float <EOL> mean_absolute_deviation numbers = sum (map abs (map (\\x -> x - mean) numbers)) / fromIntegral (length numbers) <EOL>     where <EOL>         mean =", "gt": "sum numbers / fromIntegral (length numbers)", "prediction": " (mean - mean_mean) / fromIntegral (length numbers)"}
{"input": "<s> -- For a given list of input numbers, calculate Mean Absolute Deviation <EOL> -- around the mean of this dataset. <EOL> -- Mean Absolute Deviation is the average absolute difference between each <EOL> -- element and a centerpoint (mean in this case): <EOL> -- MAD = average | x - x_mean | <EOL> -- >>> mean_absolute_deviation [1.0, 2.0, 3.0, 4.0] <EOL> -- 1.0 <EOL> mean_absolute_deviation :: [Float] -> Float <EOL> mean_absolute_deviation numbers = sum", "gt": "(map abs (map (\\x -> x - mean) numbers)) / fromIntegral (length numbers)", "prediction": " $ map (\\x -> (x - mean x) / fromIntegral (length numbers)) numbers"}
{"input": "<s> -- For a given list of input numbers, calculate Mean Absolute Deviation <EOL> -- around the mean of this dataset. <EOL> -- Mean Absolute Deviation is the average absolute difference between each <EOL> -- element and a centerpoint (mean in this case): <EOL> -- MAD = average | x - x_mean | <EOL> -- >>> mean_absolute_deviation [1.0, 2.0, 3.0, 4.0] <EOL> -- 1.0 <EOL> mean_absolute_deviation :: [Float] -> Float <EOL> mean_absolute_deviation numbers = sum (map abs (map (\\x -> x - mean) numbers)) /", "gt": "fromIntegral (length numbers)", "prediction": " fromIntegral (length numbers)"}
{"input": "<s> -- For a given list of input numbers, calculate Mean Absolute Deviation <EOL> -- around the mean of this dataset. <EOL> -- Mean Absolute Deviation is the average absolute difference between each <EOL> -- element and a centerpoint (mean in this case): <EOL> -- MAD = average | x - x_mean | <EOL> -- >>> mean_absolute_deviation [1.0, 2.0, 3.0, 4.0] <EOL> -- 1.0 <EOL> mean_absolute_deviation :: [Float] -> Float <EOL> mean_absolute_deviation numbers = sum (map abs (map (\\x ->", "gt": "x - mean) numbers)) / fromIntegral (length numbers)", "prediction": " mean x - mean x_mean)) numbers)"}
{"input": "<s> -- For a given list of input numbers, calculate Mean Absolute Deviation <EOL> -- around the mean of this dataset. <EOL> -- Mean Absolute Deviation is the average absolute difference between each <EOL> -- element and a centerpoint (mean in this case): <EOL> -- MAD = average | x - x_mean | <EOL> -- >>> mean_absolute_deviation [1.0, 2.0, 3.0, 4.0] <EOL> -- 1.0 <EOL> mean_absolute_deviation :: [Float] -> Float <EOL> mean_absolute_deviation numbers = sum (map abs (map (\\x -> x - mean) numbers)) / fromIntegral (length numbers) <EOL>     where <EOL>         mean = sum numbers /", "gt": "fromIntegral (length numbers)", "prediction": " fromIntegral (length numbers)"}
{"input": "<s> -- Task <EOL> -- We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c <EOL> -- then check if the result string is palindrome. <EOL> -- A string is called palindrome if it reads the same backward as forward. <EOL> -- You should return a tuple containing the result string and True/False for the check. <EOL> -- Example <EOL> -- For s = \"abcde\", c = \"ae\", the result should be (\"bcd\",False) <EOL> -- For s = \"abcdef\", c = \"b\"  the result should be (\"acdef\",False) <EOL> -- For s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\",True) <EOL> reverse_delete :: String -> String -> (String, Bool) <EOL> reverse_delete s c = (s', s' ==", "gt": "reverse s')", "prediction": " c)"}
{"input": "<s> -- Task <EOL> -- We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c <EOL> -- then check if the result string is palindrome. <EOL> -- A string is called palindrome if it reads the same backward as forward. <EOL> -- You should return a tuple containing the result string and True/False for the check. <EOL> -- Example <EOL> -- For s = \"abcde\", c = \"ae\", the result should be (\"bcd\",False) <EOL> -- For s = \"abcdef\", c = \"b\"  the result should be (\"acdef\",False) <EOL> -- For s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\",True) <EOL> reverse_delete :: String -> String -> (String, Bool) <EOL> reverse_delete s c = (s', s' == reverse s') <EOL>   where <EOL>     s' =v filter (`notElem`", "gt": "c) s", "prediction": " c) s"}
{"input": "<s> -- Task <EOL> -- We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c <EOL> -- then check if the result string is palindrome. <EOL> -- A string is called palindrome if it reads the same backward as forward. <EOL> -- You should return a tuple containing the result string and True/False for the check. <EOL> -- Example <EOL> -- For s = \"abcde\", c = \"ae\", the result should be (\"bcd\",False) <EOL> -- For s = \"abcdef\", c = \"b\"  the result should be (\"acdef\",False) <EOL> -- For s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\",True) <EOL> reverse_delete :: String -> String -> (String, Bool) <EOL> reverse_delete s c =", "gt": "(s', s' == reverse s')", "prediction": " let"}
{"input": "<s> -- Input to this function is a string containing multiple groups of nested parentheses. Your goal is to <EOL> -- separate those group into separate strings and return the list of those. <EOL> -- Separate groups are balanced (each open brace is properly closed) and not nested within each other <EOL> -- Ignore any spaces in the input string. <EOL> -- >>> separate_paren_groups \"( ) (( )) (( )( ))\" <EOL> -- [\"()\",\"(())\",\"(()())\"] <EOL> separate_paren_groups :: String -> [String] <EOL> separate_paren_groups paren_string = get_paren_groups paren_string 0 [] <EOL>   where <EOL>     get_paren_groups :: String -> Int -> [String] -> [String] <EOL>     get_paren_groups \"\" _ groups = groups <EOL>     get_paren_groups ('(' : cs) 0 groups = get_paren_groups cs 1 (groups ++ [\"(\"]) <EOL>     get_paren_groups (c : cs) depth groups <EOL>       | c == '(' || c == ')' = get_paren_groups cs (depth + (get_d c)) ((reverse . tail . reverse $ groups) ++ [(head $ reverse groups) ++ [c]]) <EOL>       | otherwise = get_paren_groups cs depth groups <EOL>       where <EOL>         get_d :: Char -> Int <EOL>         get_d '(' = 1 <EOL>         get_d ')' = -1 <EOL>         get_d _ =", "gt": "0", "prediction": " -1"}
{"input": "<s> -- Input to this function is a string containing multiple groups of nested parentheses. Your goal is to <EOL> -- separate those group into separate strings and return the list of those. <EOL> -- Separate groups are balanced (each open brace is properly closed) and not nested within each other <EOL> -- Ignore any spaces in the input string. <EOL> -- >>> separate_paren_groups \"( ) (( )) (( )( ))\" <EOL> -- [\"()\",\"(())\",\"(()())\"] <EOL> separate_paren_groups :: String -> [String] <EOL> separate_paren_groups paren_string = get_paren_groups paren_string 0 [] <EOL>   where <EOL>     get_paren_groups :: String -> Int -> [String] -> [String] <EOL>     get_paren_groups \"\" _ groups =", "gt": "groups", "prediction": " groups"}
{"input": "<s> -- Input to this function is a string containing multiple groups of nested parentheses. Your goal is to <EOL> -- separate those group into separate strings and return the list of those. <EOL> -- Separate groups are balanced (each open brace is properly closed) and not nested within each other <EOL> -- Ignore any spaces in the input string. <EOL> -- >>> separate_paren_groups \"( ) (( )) (( )( ))\" <EOL> -- [\"()\",\"(())\",\"(()())\"] <EOL> separate_paren_groups :: String -> [String] <EOL> separate_paren_groups paren_string = get_paren_groups paren_string 0 [] <EOL>   where <EOL>     get_paren_groups :: String -> Int -> [String] -> [String] <EOL>     get_paren_groups \"\" _ groups = groups <EOL>     get_paren_groups ('(' : cs) 0 groups = get_paren_groups cs 1 (groups ++ [\"(\"]) <EOL>     get_paren_groups (c : cs) depth groups <EOL>       | c == '(' || c == ')' = get_paren_groups cs (depth + (get_d c)) ((reverse . tail . reverse $ groups) ++ [(head $ reverse groups) ++ [c]]) <EOL>       | otherwise = get_paren_groups cs depth groups <EOL>       where <EOL>         get_d :: Char -> Int <EOL>         get_d '(' = 1 <EOL>         get_d ')' =", "gt": "-1", "prediction": " -1"}
{"input": "<s> -- Input to this function is a string containing multiple groups of nested parentheses. Your goal is to <EOL> -- separate those group into separate strings and return the list of those. <EOL> -- Separate groups are balanced (each open brace is properly closed) and not nested within each other <EOL> -- Ignore any spaces in the input string. <EOL> -- >>> separate_paren_groups \"( ) (( )) (( )( ))\" <EOL> -- [\"()\",\"(())\",\"(()())\"] <EOL> separate_paren_groups :: String -> [String] <EOL> separate_paren_groups paren_string = get_paren_groups paren_string 0 [] <EOL>   where <EOL>     get_paren_groups :: String -> Int -> [String] -> [String] <EOL>     get_paren_groups \"\" _ groups = groups <EOL>     get_paren_groups ('(' : cs) 0 groups = get_paren_groups cs 1 (groups ++ [\"(\"]) <EOL>     get_paren_groups (c : cs) depth groups <EOL>       | c == '(' || c == ')' = get_paren_groups cs (depth + (get_d c)) ((reverse . tail . reverse $ groups) ++ [(head $ reverse groups) ++ [c]]) <EOL>       | otherwise = get_paren_groups cs depth groups <EOL>       where <EOL>         get_d :: Char -> Int <EOL>         get_d '(' =", "gt": "1", "prediction": " 1"}
{"input": "<s> -- Input to this function is a string containing multiple groups of nested parentheses. Your goal is to <EOL> -- separate those group into separate strings and return the list of those. <EOL> -- Separate groups are balanced (each open brace is properly closed) and not nested within each other <EOL> -- Ignore any spaces in the input string. <EOL> -- >>> separate_paren_groups \"( ) (( )) (( )( ))\" <EOL> -- [\"()\",\"(())\",\"(()())\"] <EOL> separate_paren_groups :: String -> [String] <EOL> separate_paren_groups paren_string = get_paren_groups paren_string 0 [] <EOL>   where <EOL>     get_paren_groups :: String -> Int -> [String] -> [String] <EOL>     get_paren_groups \"\" _ groups = groups <EOL>     get_paren_groups ('(' : cs) 0 groups = get_paren_groups cs 1 (groups ++ [\"(\"]) <EOL>     get_paren_groups (c : cs) depth groups <EOL>       | c == '(' || c == ')' = get_paren_groups cs (depth + (get_d c)) ((reverse . tail . reverse $ groups) ++ [(head $ reverse groups) ++ [c]]) <EOL>       | otherwise =", "gt": "get_paren_groups cs depth groups", "prediction": " get_paren_groups (c : cs) (depth - 1) groups"}
{"input": "<s> import Data.Char <EOL> -- Task <EOL> -- Write a function that takes a string as input and returns the sum of the upper characters only' <EOL> -- ASCII codes. <EOL> -- <EOL> -- Examples: <EOL> --     digitSum \"\" => 0 <EOL> --     digitSum \"abAB\" => 131 <EOL> --     digitSum \"abcCd\" => 67 <EOL> --     digitSum \"helloE\" => 69 <EOL> --     digitSum \"woArBld\" => 131 <EOL> --     digitSum \"aAaaaXa\" => 153 <EOL> digitSum :: String -> Int <EOL> digitSum s = sum [ord c | c <- s,", "gt": "isUpper c]", "prediction": " isDigit c]"}
{"input": "<s> import Data.Char <EOL> -- Task <EOL> -- Write a function that takes a string as input and returns the sum of the upper characters only' <EOL> -- ASCII codes. <EOL> -- <EOL> -- Examples: <EOL> --     digitSum \"\" => 0 <EOL> --     digitSum \"abAB\" => 131 <EOL> --     digitSum \"abcCd\" => 67 <EOL> --     digitSum \"helloE\" => 69 <EOL> --     digitSum \"woArBld\" => 131 <EOL> --     digitSum \"aAaaaXa\" => 153 <EOL> digitSum :: String -> Int <EOL> digitSum s =", "gt": "sum [ord c | c <- s, isUpper c]", "prediction": " sum $ map digitToInt s"}
{"input": "<s> -- Insert a number 'delimeter' between every two consecutive elements of input list `numbers' <EOL> -- >>> intersperse [] 4 <EOL> -- [] <EOL> -- >>> intersperse [1, 2, 3] 4 <EOL> -- [1,4,2,4,3,4] <EOL> intersperse :: [Int] -> Int -> [Int] <EOL> intersperse numbers delimeter =", "gt": "concat [[x, delimeter] | x <- numbers]", "prediction": " concat"}
{"input": "<s> -- Insert a number 'delimeter' between every two consecutive elements of input list `numbers' <EOL> -- >>> intersperse [] 4 <EOL> -- [] <EOL> -- >>> intersperse [1, 2, 3] 4 <EOL> -- [1,4,2,4,3,4] <EOL> intersperse :: [Int] -> Int -> [Int] <EOL> intersperse numbers delimeter = concat [[x, delimeter] |", "gt": "x <- numbers]", "prediction": " x <- numbers]"}
{"input": "<s> -- Return n-th Fibonacci number. <EOL> -- >>> fib 10 <EOL> -- 55 <EOL> -- >>> fib 1 <EOL> -- 1 <EOL> -- >>> fib 8 <EOL> -- 21 <EOL> fib :: Int -> Int <EOL> fib n = fib' n 0 1 <EOL>   where <EOL>     fib' :: Int -> Int -> Int -> Int <EOL>     fib' 0 a b = a <EOL>     fib' n a b = fib' (n - 1) b", "gt": "(a + b)", "prediction": " a"}
{"input": "<s> -- Return n-th Fibonacci number. <EOL> -- >>> fib 10 <EOL> -- 55 <EOL> -- >>> fib 1 <EOL> -- 1 <EOL> -- >>> fib 8 <EOL> -- 21 <EOL> fib :: Int -> Int <EOL> fib n = fib' n 0 1 <EOL>   where <EOL>     fib' :: Int -> Int -> Int -> Int <EOL>     fib' 0 a b =", "gt": "a", "prediction": " fib' (a+1) b"}
{"input": "<s> -- Return n-th Fibonacci number. <EOL> -- >>> fib 10 <EOL> -- 55 <EOL> -- >>> fib 1 <EOL> -- 1 <EOL> -- >>> fib 8 <EOL> -- 21 <EOL> fib :: Int -> Int <EOL> fib n = fib' n 0 1 <EOL>   where <EOL>     fib' :: Int -> Int -> Int -> Int <EOL>     fib' 0 a b = a <EOL>     fib' n a b =", "gt": "fib' (n - 1) b (a + b)", "prediction": " fib' (n-1) a b"}
{"input": "<s> -- Return n-th Fibonacci number. <EOL> -- >>> fib 10 <EOL> -- 55 <EOL> -- >>> fib 1 <EOL> -- 1 <EOL> -- >>> fib 8 <EOL> -- 21 <EOL> fib :: Int -> Int <EOL> fib n =", "gt": "fib' n 0 1", "prediction": " ifs !! n"}
{"input": "<s> import Data.List (sort, nub, intersect) <EOL> -- Return sorted unique common elements for two lists. <EOL> -- >>> common [1,4,3,34,653,2,5] [5,7,1,5,9,653,121] <EOL> -- [1,5,653] <EOL> -- >>> common [5,3,2,8] [3,2] <EOL> -- [2,3] <EOL> common :: [Int] -> [Int] -> [Int] <EOL> common l1 l2 =", "gt": "sort $ nub $ l1 `intersect` l2", "prediction": " ["}
{"input": "<s> -- Given a positive floating point number, it can be decomposed into <EOL> -- and integer part (largest integer smaller than given number) and decimals <EOL> -- (leftover part always smaller than 1). <EOL> -- <EOL> -- Return the decimal part of the number. <EOL> -- >>> truncate_number 3.5 <EOL> -- 0.5 <EOL> truncate_number :: Float -> Float <EOL> truncate_number number =", "gt": "number - fromIntegral (floor number)", "prediction": " ("}
{"input": "<s> -- Given a positive floating point number, it can be decomposed into <EOL> -- and integer part (largest integer smaller than given number) and decimals <EOL> -- (leftover part always smaller than 1). <EOL> -- <EOL> -- Return the decimal part of the number. <EOL> -- >>> truncate_number 3.5 <EOL> -- 0.5 <EOL> truncate_number :: Float -> Float <EOL> truncate_number number = number - fromIntegral", "gt": "(floor number)", "prediction": " (floor number :: Int)"}
{"input": "<s> -- Circular shift the digits of the integer x, shift the digits right by shift <EOL> -- and return the result as a string. <EOL> -- If shift > number of digits, return digits reversed. <EOL> -- >>> circular_shift 12 1 <EOL> -- \"21\" <EOL> -- >>> circular_shift 12 2 <EOL> -- \"12\" <EOL> circular_shift :: Int -> Int -> String <EOL> circular_shift x shift <EOL>   | shift > length s = reverse s <EOL>   | otherwise = drop (length s - shift) s ++ take (length s - shift) s <EOL>   where  <EOL>     s :: String <EOL>     s =", "gt": "show x", "prediction": " take $ take (length s - shift) $ drop (length s - shift) $ reverse (show x)"}
{"input": "<s> -- Circular shift the digits of the integer x, shift the digits right by shift <EOL> -- and return the result as a string. <EOL> -- If shift > number of digits, return digits reversed. <EOL> -- >>> circular_shift 12 1 <EOL> -- \"21\" <EOL> -- >>> circular_shift 12 2 <EOL> -- \"12\" <EOL> circular_shift :: Int -> Int -> String <EOL> circular_shift x shift <EOL>   | shift > length s = reverse s <EOL>   | otherwise =", "gt": "drop (length s - shift) s ++ take (length s - shift) s", "prediction": " take"}
{"input": "<s> -- Circular shift the digits of the integer x, shift the digits right by shift <EOL> -- and return the result as a string. <EOL> -- If shift > number of digits, return digits reversed. <EOL> -- >>> circular_shift 12 1 <EOL> -- \"21\" <EOL> -- >>> circular_shift 12 2 <EOL> -- \"12\" <EOL> circular_shift :: Int -> Int -> String <EOL> circular_shift x shift <EOL>   | shift > length s =", "gt": "reverse s", "prediction": " s"}
{"input": "<s> -- Circular shift the digits of the integer x, shift the digits right by shift <EOL> -- and return the result as a string. <EOL> -- If shift > number of digits, return digits reversed. <EOL> -- >>> circular_shift 12 1 <EOL> -- \"21\" <EOL> -- >>> circular_shift 12 2 <EOL> -- \"12\" <EOL> circular_shift :: Int -> Int -> String <EOL> circular_shift x shift <EOL>   | shift > length s = reverse s <EOL>   | otherwise = drop (length s - shift) s ++", "gt": "take (length s - shift) s", "prediction": " [shift]"}
{"input": "<s> -- Write a function vowels_count which takes a string representing <EOL> -- a word as input and returns the number of vowels in the string. <EOL> -- Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a <EOL> -- vowel, but only when it is at the end of the given word. <EOL> -- Example: <EOL> -- >>> vowels_count \"abcde\" <EOL> -- 2 <EOL> -- >>> vowels_count \"ACEDY\" <EOL> -- 3 <EOL> vowels_count :: String -> Int <EOL> vowels_count s = (length $ filter (`elem` \"aeiouAEIOU\") s) + if last s `elem` \"yY\" then", "gt": "1 else 0", "prediction": " 1 else 0"}
{"input": "<s> -- Write a function vowels_count which takes a string representing <EOL> -- a word as input and returns the number of vowels in the string. <EOL> -- Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a <EOL> -- vowel, but only when it is at the end of the given word. <EOL> -- Example: <EOL> -- >>> vowels_count \"abcde\" <EOL> -- 2 <EOL> -- >>> vowels_count \"ACEDY\" <EOL> -- 3 <EOL> vowels_count :: String -> Int <EOL> vowels_count s =", "gt": "(length $ filter (`elem` \"aeiouAEIOU\") s) + if last s `elem` \"yY\" then 1 else 0", "prediction": " length"}
{"input": "<s> -- You are given a string s. <EOL> -- if s[i] is a letter, reverse its case from lower to upper or vise versa, <EOL> -- otherwise keep it as it is. <EOL> -- If the string contains no letters, reverse the string. <EOL> -- The function should return the resulted string. <EOL> -- Examples <EOL> -- >>> solve \"1234\" <EOL> -- \"4321\" <EOL> -- >>> solve \"ab\" <EOL> -- \"AB\" <EOL> -- >>> solve \"#a@C\" <EOL> -- \"#A@c\" <EOL> import Data.Char (toLower, toUpper) <EOL> solve :: String -> String <EOL> solve s = if flg == 0 then reverse s else reverseUpperLower s <EOL>   where <EOL>     flg :: Int <EOL>     flg =", "gt": "length [i | i <- s, i `elem` ['a' .. 'z']] + length [i | i <- s, i `elem` ['A' .. 'Z']]", "prediction": " if flg of"}
{"input": "<s> -- You are given a string s. <EOL> -- if s[i] is a letter, reverse its case from lower to upper or vise versa, <EOL> -- otherwise keep it as it is. <EOL> -- If the string contains no letters, reverse the string. <EOL> -- The function should return the resulted string. <EOL> -- Examples <EOL> -- >>> solve \"1234\" <EOL> -- \"4321\" <EOL> -- >>> solve \"ab\" <EOL> -- \"AB\" <EOL> -- >>> solve \"#a@C\" <EOL> -- \"#A@c\" <EOL> import Data.Char (toLower, toUpper) <EOL> solve :: String -> String <EOL> solve s = if flg == 0 then reverse s else reverseUpperLower s <EOL>   where <EOL>     flg :: Int <EOL>     flg = length [i | i <- s, i `elem` ['a' .. 'z']] + length [i | i <- s, i `elem` ['A' .. 'Z']] <EOL>     reverseUpperLower s = [if i `elem` ['a' .. 'z'] then", "gt": "toUpper i else toLower i | i <- s]", "prediction": " toUpper i else i | i <- s]"}
{"input": "<s> -- You are given a string s. <EOL> -- if s[i] is a letter, reverse its case from lower to upper or vise versa, <EOL> -- otherwise keep it as it is. <EOL> -- If the string contains no letters, reverse the string. <EOL> -- The function should return the resulted string. <EOL> -- Examples <EOL> -- >>> solve \"1234\" <EOL> -- \"4321\" <EOL> -- >>> solve \"ab\" <EOL> -- \"AB\" <EOL> -- >>> solve \"#a@C\" <EOL> -- \"#A@c\" <EOL> import Data.Char (toLower, toUpper) <EOL> solve :: String -> String <EOL> solve s = if flg == 0 then reverse s else reverseUpperLower s <EOL>   where <EOL>     flg :: Int <EOL>     flg = length [i | i <- s, i `elem` ['a' .. 'z']] +", "gt": "length [i | i <- s, i `elem` ['A' .. 'Z']]", "prediction": " 1"}
{"input": "<s> -- You are given a string s. <EOL> -- if s[i] is a letter, reverse its case from lower to upper or vise versa, <EOL> -- otherwise keep it as it is. <EOL> -- If the string contains no letters, reverse the string. <EOL> -- The function should return the resulted string. <EOL> -- Examples <EOL> -- >>> solve \"1234\" <EOL> -- \"4321\" <EOL> -- >>> solve \"ab\" <EOL> -- \"AB\" <EOL> -- >>> solve \"#a@C\" <EOL> -- \"#A@c\" <EOL> import Data.Char (toLower, toUpper) <EOL> solve :: String -> String <EOL> solve s = if flg == 0 then", "gt": "reverse s else reverseUpperLower s", "prediction": " reverse s else flg"}
{"input": "<s> -- You are given a string s. <EOL> -- if s[i] is a letter, reverse its case from lower to upper or vise versa, <EOL> -- otherwise keep it as it is. <EOL> -- If the string contains no letters, reverse the string. <EOL> -- The function should return the resulted string. <EOL> -- Examples <EOL> -- >>> solve \"1234\" <EOL> -- \"4321\" <EOL> -- >>> solve \"ab\" <EOL> -- \"AB\" <EOL> -- >>> solve \"#a@C\" <EOL> -- \"#A@c\" <EOL> import Data.Char (toLower, toUpper) <EOL> solve :: String -> String <EOL> solve s =", "gt": "if flg == 0 then reverse s else reverseUpperLower s", "prediction": " map toLower (reverse s)"}
{"input": "<s> -- Filter an input list of strings only for ones that start with a given prefix. <EOL> -- >>> filter_by_prefix [] \"a\" <EOL> -- [] <EOL> -- >>> filter_by_prefix [\"abc\", \"bcd\", \"cde\", \"array\"] \"a\" <EOL> -- [\"abc\",\"array\"] <EOL> filter_by_prefix :: [String] -> String -> [String] <EOL> filter_by_prefix strings prefix = [x | x <- strings, x `startsWith` prefix] <EOL>     where startsWith :: String -> String -> Bool <EOL>           startsWith string prefix =", "gt": "take (length prefix) string == prefix", "prediction": " string"}
{"input": "<s> -- Filter an input list of strings only for ones that start with a given prefix. <EOL> -- >>> filter_by_prefix [] \"a\" <EOL> -- [] <EOL> -- >>> filter_by_prefix [\"abc\", \"bcd\", \"cde\", \"array\"] \"a\" <EOL> -- [\"abc\",\"array\"] <EOL> filter_by_prefix :: [String] -> String -> [String] <EOL> filter_by_prefix strings prefix = [x | x <-", "gt": "strings, x `startsWith` prefix]", "prediction": " strings, prefix `isPrefixOf` x]"}
{"input": "<s> -- Filter an input list of strings only for ones that start with a given prefix. <EOL> -- >>> filter_by_prefix [] \"a\" <EOL> -- [] <EOL> -- >>> filter_by_prefix [\"abc\", \"bcd\", \"cde\", \"array\"] \"a\" <EOL> -- [\"abc\",\"array\"] <EOL> filter_by_prefix :: [String] -> String -> [String] <EOL> filter_by_prefix strings prefix = [x | x <- strings, x `startsWith` prefix] <EOL>     where startsWith :: String -> String -> Bool <EOL>           startsWith string prefix = take (length prefix)", "gt": "string == prefix", "prediction": " string == prefix"}
{"input": "<s> -- Filter an input list of strings only for ones that start with a given prefix. <EOL> -- >>> filter_by_prefix [] \"a\" <EOL> -- [] <EOL> -- >>> filter_by_prefix [\"abc\", \"bcd\", \"cde\", \"array\"] \"a\" <EOL> -- [\"abc\",\"array\"] <EOL> filter_by_prefix :: [String] -> String -> [String] <EOL> filter_by_prefix strings prefix = [x | x <- strings,", "gt": "x `startsWith` prefix]", "prediction": " prefix `isPrefixOf` x]"}
{"input": "<s> -- Filter an input list of strings only for ones that start with a given prefix. <EOL> -- >>> filter_by_prefix [] \"a\" <EOL> -- [] <EOL> -- >>> filter_by_prefix [\"abc\", \"bcd\", \"cde\", \"array\"] \"a\" <EOL> -- [\"abc\",\"array\"] <EOL> filter_by_prefix :: [String] -> String -> [String] <EOL> filter_by_prefix strings prefix =", "gt": "[x | x <- strings, x `startsWith` prefix]", "prediction": " filter"}
{"input": "<s> -- Write a function that takes an array of numbers as input and returns <EOL> -- the number of elements in the array that are greater than 10 and both <EOL> -- first and last digits of a number are odd (1, 3, 5, 7, 9). <EOL> -- For example: <EOL> -- >>> specialFilter [15, -73, 14, -15] <EOL> -- 1 <EOL> -- >>> specialFilter [33, -2, -3, 45, 21, 109] <EOL> -- 2 <EOL> import Data.List <EOL> specialFilter :: [Int] -> Int <EOL> specialFilter nums =", "gt": "length $ filter greaterThanTenAndOddBorders nums", "prediction": " fold"}
{"input": "<s> -- Write a function that takes an array of numbers as input and returns <EOL> -- the number of elements in the array that are greater than 10 and both <EOL> -- first and last digits of a number are odd (1, 3, 5, 7, 9). <EOL> -- For example: <EOL> -- >>> specialFilter [15, -73, 14, -15] <EOL> -- 1 <EOL> -- >>> specialFilter [33, -2, -3, 45, 21, 109] <EOL> -- 2 <EOL> import Data.List <EOL> specialFilter :: [Int] -> Int <EOL> specialFilter nums = length $ filter greaterThanTenAndOddBorders nums <EOL>   where <EOL>     greaterThanTenAndOddBorders :: Int -> Bool <EOL>     greaterThanTenAndOddBorders n =", "gt": "n > 10 && odd (read [head (show n)] :: Int) && odd (read [show n !! (length (show n) - 1)] :: Int)", "prediction": " n"}
{"input": "<s> -- Write a function that takes an array of numbers as input and returns <EOL> -- the number of elements in the array that are greater than 10 and both <EOL> -- first and last digits of a number are odd (1, 3, 5, 7, 9). <EOL> -- For example: <EOL> -- >>> specialFilter [15, -73, 14, -15] <EOL> -- 1 <EOL> -- >>> specialFilter [33, -2, -3, 45, 21, 109] <EOL> -- 2 <EOL> import Data.List <EOL> specialFilter :: [Int] -> Int <EOL> specialFilter nums = length $ filter greaterThanTenAndOddBorders nums <EOL>   where <EOL>     greaterThanTenAndOddBorders :: Int -> Bool <EOL>     greaterThanTenAndOddBorders n = n > 10 && odd (read [head (show n)] :: Int) &&", "gt": "odd (read [show n !! (length (show n) - 1)] :: Int)", "prediction": " odd"}
{"input": "<s> import Data.Typeable <EOL> -- Create a function that takes 3 numbers. <EOL> -- Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers. <EOL> -- Returns false in any other cases. <EOL> -- <EOL> -- Examples <EOL> -- any_int 5 2 7 => True <EOL> -- <EOL> -- any_int 3 2 2 => False <EOL> -- <EOL> -- any_int 3 (-2) 1 => True <EOL> -- <EOL> -- any_int 3.6 (-2.2) 2 => False <EOL> any_int :: Float -> Float -> Float -> Bool <EOL> any_int x y z = <EOL>   isInt x <EOL>     && isInt y <EOL>     && isInt z <EOL>     && (x + y == z || x + z == y || y + z == x) <EOL>   where <EOL>     isInt a = a ==", "gt": "fromInteger (round a)", "prediction": " x"}
{"input": "<s> import Data.Typeable <EOL> -- Create a function that takes 3 numbers. <EOL> -- Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers. <EOL> -- Returns false in any other cases. <EOL> -- <EOL> -- Examples <EOL> -- any_int 5 2 7 => True <EOL> -- <EOL> -- any_int 3 2 2 => False <EOL> -- <EOL> -- any_int 3 (-2) 1 => True <EOL> -- <EOL> -- any_int 3.6 (-2.2) 2 => False <EOL> any_int :: Float -> Float -> Float -> Bool <EOL> any_int x y z = <EOL>   isInt x <EOL>     && isInt y <EOL>     && isInt z <EOL>     && (x + y == z || x + z == y ||", "gt": "y + z == x)", "prediction": " x + y == z)"}
{"input": "<s> import Data.Typeable <EOL> -- Create a function that takes 3 numbers. <EOL> -- Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers. <EOL> -- Returns false in any other cases. <EOL> -- <EOL> -- Examples <EOL> -- any_int 5 2 7 => True <EOL> -- <EOL> -- any_int 3 2 2 => False <EOL> -- <EOL> -- any_int 3 (-2) 1 => True <EOL> -- <EOL> -- any_int 3.6 (-2.2) 2 => False <EOL> any_int :: Float -> Float -> Float -> Bool <EOL> any_int x y z = <EOL>   isInt x <EOL>     && isInt y <EOL>     && isInt", "gt": "z", "prediction": " z"}
{"input": "<s> import Data.Typeable <EOL> -- Create a function that takes 3 numbers. <EOL> -- Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers. <EOL> -- Returns false in any other cases. <EOL> -- <EOL> -- Examples <EOL> -- any_int 5 2 7 => True <EOL> -- <EOL> -- any_int 3 2 2 => False <EOL> -- <EOL> -- any_int 3 (-2) 1 => True <EOL> -- <EOL> -- any_int 3.6 (-2.2) 2 => False <EOL> any_int :: Float -> Float -> Float -> Bool <EOL> any_int x y z = <EOL>   isInt x <EOL>     && isInt y <EOL>     && isInt z <EOL>     && (x + y == z ||", "gt": "x + z == y || y + z == x)", "prediction": " x == y)"}
{"input": "<s> -- You have been tasked to write a function that receives <EOL> -- a hexadecimal number as a string and counts the number of hexadecimal <EOL> -- digits that are primes (prime number, or a prime, is a natural number <EOL> -- greater than 1 that is not a product of two smaller natural numbers). <EOL> -- Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. <EOL> -- Prime numbers are 2, 3, 5, 7, 11, 13, 17,... <EOL> -- So you have to determine a number of the following digits: 2, 3, 5, 7, <EOL> -- B (=decimal 11), D (=decimal 13). <EOL> -- Note: you may assume the input is always correct or empty string, <EOL> -- and symbols A,B,C,D,E,F are always uppercase. <EOL> -- Examples: <EOL> -- For num = \"AB\" the output should be 1. <EOL> -- For num = \"1077E\" the output should be 2. <EOL> -- For num = \"ABED1A33\" the output should be 4. <EOL> -- For num = \"123456789ABCDEF0\" the output should be 6. <EOL> -- For num = \"2020\" the output should be 2. <EOL> hex_key :: String -> Int <EOL> hex_key num =", "gt": "length [i | i <- num, i `elem` \"2357BD\"]", "prediction": " sum"}
{"input": "<s> -- You have been tasked to write a function that receives <EOL> -- a hexadecimal number as a string and counts the number of hexadecimal <EOL> -- digits that are primes (prime number, or a prime, is a natural number <EOL> -- greater than 1 that is not a product of two smaller natural numbers). <EOL> -- Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. <EOL> -- Prime numbers are 2, 3, 5, 7, 11, 13, 17,... <EOL> -- So you have to determine a number of the following digits: 2, 3, 5, 7, <EOL> -- B (=decimal 11), D (=decimal 13). <EOL> -- Note: you may assume the input is always correct or empty string, <EOL> -- and symbols A,B,C,D,E,F are always uppercase. <EOL> -- Examples: <EOL> -- For num = \"AB\" the output should be 1. <EOL> -- For num = \"1077E\" the output should be 2. <EOL> -- For num = \"ABED1A33\" the output should be 4. <EOL> -- For num = \"123456789ABCDEF0\" the output should be 6. <EOL> -- For num = \"2020\" the output should be 2. <EOL> hex_key :: String -> Int <EOL> hex_key num = length [i | i <-", "gt": "num, i `elem` \"2357BD\"]", "prediction": " [1..num], isDigit i]"}
{"input": "<s> -- Write a function that accepts a list of strings as a parameter, <EOL> -- deletes the strings that have odd lengths from it, <EOL> -- and returns the resulted list with a sorted order, <EOL> -- The list is always a list of strings and never an array of numbers, <EOL> -- and it may contain duplicates. <EOL> -- The order of the list should be ascending by length of each word, and you <EOL> -- should return the list sorted by that rule. <EOL> -- If two words have the same length, sort the list alphabetically. <EOL> -- The function should return a list of strings in sorted order. <EOL> -- You may assume that all words will have the same length. <EOL> -- For example: <EOL> -- >>> sorted_list_sum [\"aa\", \"a\", \"aaa\"] <EOL> -- [\"aa\"] <EOL> -- >>> sorted_list_sum [\"ab\", \"a\", \"aaa\", \"cd\"] <EOL> -- [\"ab\", \"cd\"] <EOL> import Data.List (sort) <EOL> sorted_list_sum :: [String] -> [String] <EOL> sorted_list_sum lst = sort $ filter", "gt": "(\\x -> length x `mod` 2 == 0) lst", "prediction": " (\\x -> length x > 0) lst"}
{"input": "<s> -- Write a function that accepts a list of strings as a parameter, <EOL> -- deletes the strings that have odd lengths from it, <EOL> -- and returns the resulted list with a sorted order, <EOL> -- The list is always a list of strings and never an array of numbers, <EOL> -- and it may contain duplicates. <EOL> -- The order of the list should be ascending by length of each word, and you <EOL> -- should return the list sorted by that rule. <EOL> -- If two words have the same length, sort the list alphabetically. <EOL> -- The function should return a list of strings in sorted order. <EOL> -- You may assume that all words will have the same length. <EOL> -- For example: <EOL> -- >>> sorted_list_sum [\"aa\", \"a\", \"aaa\"] <EOL> -- [\"aa\"] <EOL> -- >>> sorted_list_sum [\"ab\", \"a\", \"aaa\", \"cd\"] <EOL> -- [\"ab\", \"cd\"] <EOL> import Data.List (sort) <EOL> sorted_list_sum :: [String] -> [String] <EOL> sorted_list_sum lst =", "gt": "sort $ filter (\\x -> length x `mod` 2 == 0) lst", "prediction": " sort"}
{"input": "<s> -- In this problem, you will implement a function that takes two lists of numbers, <EOL> -- and determines whether it is possible to perform an exchange of elements <EOL> -- between them to make lst1 a list of only even numbers. <EOL> -- There is no limit on the number of exchanged elements between lst1 and lst2. <EOL> -- If it is possible to exchange elements between the lst1 and lst2 to make <EOL> -- all the elements of lst1 to be even, return \"YES\". <EOL> -- Otherwise, return \"NO\". <EOL> -- For example: <EOL> -- exchange [1, 2, 3, 4] [1, 2, 3, 4] => \"YES\" <EOL> -- exchange [1, 2, 3, 4] [1, 5, 3, 4] => \"NO\" <EOL> -- It is assumed that the input lists will be non-empty. <EOL> exchange :: [Int] -> [Int] -> String <EOL> exchange lst1 lst2 <EOL>   | evenCount >= oddCount =", "gt": "\"YES\"", "prediction": " \"NO\""}
{"input": "<s> -- In this problem, you will implement a function that takes two lists of numbers, <EOL> -- and determines whether it is possible to perform an exchange of elements <EOL> -- between them to make lst1 a list of only even numbers. <EOL> -- There is no limit on the number of exchanged elements between lst1 and lst2. <EOL> -- If it is possible to exchange elements between the lst1 and lst2 to make <EOL> -- all the elements of lst1 to be even, return \"YES\". <EOL> -- Otherwise, return \"NO\". <EOL> -- For example: <EOL> -- exchange [1, 2, 3, 4] [1, 2, 3, 4] => \"YES\" <EOL> -- exchange [1, 2, 3, 4] [1, 5, 3, 4] => \"NO\" <EOL> -- It is assumed that the input lists will be non-empty. <EOL> exchange :: [Int] -> [Int] -> String <EOL> exchange lst1 lst2 <EOL>   | evenCount >= oddCount = \"YES\" <EOL>   | otherwise = \"NO\" <EOL>   where <EOL>     evenCount = length $ filter even lst2 <EOL>     oddCount =", "gt": "length $ filter odd lst1", "prediction": " length $ filter odd lst1"}
{"input": "<s> -- In this problem, you will implement a function that takes two lists of numbers, <EOL> -- and determines whether it is possible to perform an exchange of elements <EOL> -- between them to make lst1 a list of only even numbers. <EOL> -- There is no limit on the number of exchanged elements between lst1 and lst2. <EOL> -- If it is possible to exchange elements between the lst1 and lst2 to make <EOL> -- all the elements of lst1 to be even, return \"YES\". <EOL> -- Otherwise, return \"NO\". <EOL> -- For example: <EOL> -- exchange [1, 2, 3, 4] [1, 2, 3, 4] => \"YES\" <EOL> -- exchange [1, 2, 3, 4] [1, 5, 3, 4] => \"NO\" <EOL> -- It is assumed that the input lists will be non-empty. <EOL> exchange :: [Int] -> [Int] -> String <EOL> exchange lst1 lst2 <EOL>   | evenCount >= oddCount = \"YES\" <EOL>   | otherwise = \"NO\" <EOL>   where <EOL>     evenCount = length $ filter even lst2 <EOL>     oddCount = length $ filter odd", "gt": "lst1", "prediction": " lst1"}
{"input": "<s> -- In this problem, you will implement a function that takes two lists of numbers, <EOL> -- and determines whether it is possible to perform an exchange of elements <EOL> -- between them to make lst1 a list of only even numbers. <EOL> -- There is no limit on the number of exchanged elements between lst1 and lst2. <EOL> -- If it is possible to exchange elements between the lst1 and lst2 to make <EOL> -- all the elements of lst1 to be even, return \"YES\". <EOL> -- Otherwise, return \"NO\". <EOL> -- For example: <EOL> -- exchange [1, 2, 3, 4] [1, 2, 3, 4] => \"YES\" <EOL> -- exchange [1, 2, 3, 4] [1, 5, 3, 4] => \"NO\" <EOL> -- It is assumed that the input lists will be non-empty. <EOL> exchange :: [Int] -> [Int] -> String <EOL> exchange lst1 lst2 <EOL>   | evenCount >= oddCount = \"YES\" <EOL>   | otherwise = \"NO\" <EOL>   where <EOL>     evenCount =", "gt": "length $ filter even lst2", "prediction": " sum"}
{"input": "<s> -- In this problem, you will implement a function that takes two lists of numbers, <EOL> -- and determines whether it is possible to perform an exchange of elements <EOL> -- between them to make lst1 a list of only even numbers. <EOL> -- There is no limit on the number of exchanged elements between lst1 and lst2. <EOL> -- If it is possible to exchange elements between the lst1 and lst2 to make <EOL> -- all the elements of lst1 to be even, return \"YES\". <EOL> -- Otherwise, return \"NO\". <EOL> -- For example: <EOL> -- exchange [1, 2, 3, 4] [1, 2, 3, 4] => \"YES\" <EOL> -- exchange [1, 2, 3, 4] [1, 5, 3, 4] => \"NO\" <EOL> -- It is assumed that the input lists will be non-empty. <EOL> exchange :: [Int] -> [Int] -> String <EOL> exchange lst1 lst2 <EOL>   | evenCount >= oddCount = \"YES\" <EOL>   | otherwise = \"NO\" <EOL>   where <EOL>     evenCount = length $ filter even lst2 <EOL>     oddCount = length $", "gt": "filter odd lst1", "prediction": " filter odd lst1"}
{"input": "<s> -- I think we all remember that feeling when the result of some long-awaited <EOL> -- event is finally known. The feelings and thoughts you have at that moment are <EOL> -- definitely worth noting down and comparing. <EOL> -- Your task is to determine if a person correctly guessed the results of a number of matches. <EOL> -- You are given two arrays of scores and guesses of equal length, where each index shows a match. <EOL> -- Return an array of the same length denoting how far off each guess was. If they have guessed correctly, <EOL> -- the value is 0, and if not, the value is the absolute difference between the guess and the score. <EOL> -- <EOL> -- <EOL> -- example: <EOL> -- <EOL> -- >>> compare' [1,2,3,4,5,1] [1,2,3,4,2,-2] <EOL> -- [0,0,0,0,3,3] <EOL> -- >>> compare' [0,5,0,0,0,4] [4,1,1,0,0,-2] <EOL> -- [4,4,1,0,0,6] <EOL> compare' :: [Int] -> [Int] -> [Int] <EOL> compare' game guess =", "gt": "[abs (x - y) | (x, y) <- zip game guess]", "prediction": " undefined"}
{"input": "<s> -- I think we all remember that feeling when the result of some long-awaited <EOL> -- event is finally known. The feelings and thoughts you have at that moment are <EOL> -- definitely worth noting down and comparing. <EOL> -- Your task is to determine if a person correctly guessed the results of a number of matches. <EOL> -- You are given two arrays of scores and guesses of equal length, where each index shows a match. <EOL> -- Return an array of the same length denoting how far off each guess was. If they have guessed correctly, <EOL> -- the value is 0, and if not, the value is the absolute difference between the guess and the score. <EOL> -- <EOL> -- <EOL> -- example: <EOL> -- <EOL> -- >>> compare' [1,2,3,4,5,1] [1,2,3,4,2,-2] <EOL> -- [0,0,0,0,3,3] <EOL> -- >>> compare' [0,5,0,0,0,4] [4,1,1,0,0,-2] <EOL> -- [4,4,1,0,0,6] <EOL> compare' :: [Int] -> [Int] -> [Int] <EOL> compare' game guess = [abs (x - y) |", "gt": "(x, y) <- zip game guess]", "prediction": " x <- game, y <- guess]"}
{"input": "<s> -- I think we all remember that feeling when the result of some long-awaited <EOL> -- event is finally known. The feelings and thoughts you have at that moment are <EOL> -- definitely worth noting down and comparing. <EOL> -- Your task is to determine if a person correctly guessed the results of a number of matches. <EOL> -- You are given two arrays of scores and guesses of equal length, where each index shows a match. <EOL> -- Return an array of the same length denoting how far off each guess was. If they have guessed correctly, <EOL> -- the value is 0, and if not, the value is the absolute difference between the guess and the score. <EOL> -- <EOL> -- <EOL> -- example: <EOL> -- <EOL> -- >>> compare' [1,2,3,4,5,1] [1,2,3,4,2,-2] <EOL> -- [0,0,0,0,3,3] <EOL> -- >>> compare' [0,5,0,0,0,4] [4,1,1,0,0,-2] <EOL> -- [4,4,1,0,0,6] <EOL> compare' :: [Int] -> [Int] -> [Int] <EOL> compare' game guess = [abs (x - y) | (x, y) <-", "gt": "zip game guess]", "prediction": " zip game guess]"}
{"input": "<s> -- Given a string 'text', return its md5 hash equivalent string. <EOL> -- If 'text' is an empty string, return Nothing. <EOL> -- <EOL> -- >>> string_to_md5 \"Hello world\" <EOL> -- Just \"3e25960a79dbc69b674cd4ec67a72c62\" <EOL> import Crypto.Hash.MD5 qualified as MD5 <EOL> import Data.ByteString.Base16 (encode) <EOL> import Data.ByteString.Char8 (pack, unpack) <EOL> import Data.Maybe <EOL> -- Build depends on: base >= 4.7 && < 5, base16-bytestring, bytestring, cryptohash-md5 <EOL> string_to_md5 :: String -> Maybe String <EOL> string_to_md5 text = if text == \"\" then", "gt": "Nothing else Just $ unpack $ encode $ MD5.hash $ pack text", "prediction": " Nothing else Just $ md5 text"}
{"input": "<s> -- Given a string 'text', return its md5 hash equivalent string. <EOL> -- If 'text' is an empty string, return Nothing. <EOL> -- <EOL> -- >>> string_to_md5 \"Hello world\" <EOL> -- Just \"3e25960a79dbc69b674cd4ec67a72c62\" <EOL> import Crypto.Hash.MD5 qualified as MD5 <EOL> import Data.ByteString.Base16 (encode) <EOL> import Data.ByteString.Char8 (pack, unpack) <EOL> import Data.Maybe <EOL> -- Build depends on: base >= 4.7 && < 5, base16-bytestring, bytestring, cryptohash-md5 <EOL> string_to_md5 :: String -> Maybe String <EOL> string_to_md5 text =", "gt": "if text == \"\" then Nothing else Just $ unpack $ encode $ MD5.hash $ pack text", "prediction": " do"}
{"input": "<s> -- You're a hungry rabbit, and you already have eaten a certain number of carrots, <EOL> -- but now you need to eat more carrots to complete the day's meals. <EOL> -- you should return an array of [ total number of eaten carrots after your meals, <EOL> --                                 the number of carrots left after your meals ] <EOL> -- if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry. <EOL> -- <EOL> -- Example: <EOL> -- >>> eat 5 6 10 <EOL> -- [11, 4] <EOL> -- >>> eat 4 8 9 <EOL> -- [12, 1] <EOL> -- >>> eat 1 10 10 <EOL> -- [11, 0] <EOL> -- >>> eat 2 11 5 <EOL> -- [7, 0] <EOL> -- <EOL> -- Variables: <EOL> -- @number : integer <EOL> --     the number of carrots that you have eaten. <EOL> -- @need : integer <EOL> --     the number of carrots that you need to eat. <EOL> -- @remaining : integer <EOL> --     the number of remaining carrots thet exist in stock <EOL> -- <EOL> -- Constraints: <EOL> -- * 0 <= number <= 1000 <EOL> -- * 0 <= need <= 1000 <EOL> -- * 0 <= remaining <= 1000 <EOL> -- <EOL> -- Have fun :) <EOL> eat :: Int -> Int -> Int -> [Int] <EOL> eat number need remaining = if need <= remaining then", "gt": "[number + need, remaining - need] else [number + remaining, 0]", "prediction": " []"}
{"input": "<s> -- You're a hungry rabbit, and you already have eaten a certain number of carrots, <EOL> -- but now you need to eat more carrots to complete the day's meals. <EOL> -- you should return an array of [ total number of eaten carrots after your meals, <EOL> --                                 the number of carrots left after your meals ] <EOL> -- if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry. <EOL> -- <EOL> -- Example: <EOL> -- >>> eat 5 6 10 <EOL> -- [11, 4] <EOL> -- >>> eat 4 8 9 <EOL> -- [12, 1] <EOL> -- >>> eat 1 10 10 <EOL> -- [11, 0] <EOL> -- >>> eat 2 11 5 <EOL> -- [7, 0] <EOL> -- <EOL> -- Variables: <EOL> -- @number : integer <EOL> --     the number of carrots that you have eaten. <EOL> -- @need : integer <EOL> --     the number of carrots that you need to eat. <EOL> -- @remaining : integer <EOL> --     the number of remaining carrots thet exist in stock <EOL> -- <EOL> -- Constraints: <EOL> -- * 0 <= number <= 1000 <EOL> -- * 0 <= need <= 1000 <EOL> -- * 0 <= remaining <= 1000 <EOL> -- <EOL> -- Have fun :) <EOL> eat :: Int -> Int -> Int -> [Int] <EOL> eat number need remaining = if need <= remaining then [number + need, remaining - need] else", "gt": "[number + remaining, 0]", "prediction": " []"}
{"input": "<s> -- You're a hungry rabbit, and you already have eaten a certain number of carrots, <EOL> -- but now you need to eat more carrots to complete the day's meals. <EOL> -- you should return an array of [ total number of eaten carrots after your meals, <EOL> --                                 the number of carrots left after your meals ] <EOL> -- if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry. <EOL> -- <EOL> -- Example: <EOL> -- >>> eat 5 6 10 <EOL> -- [11, 4] <EOL> -- >>> eat 4 8 9 <EOL> -- [12, 1] <EOL> -- >>> eat 1 10 10 <EOL> -- [11, 0] <EOL> -- >>> eat 2 11 5 <EOL> -- [7, 0] <EOL> -- <EOL> -- Variables: <EOL> -- @number : integer <EOL> --     the number of carrots that you have eaten. <EOL> -- @need : integer <EOL> --     the number of carrots that you need to eat. <EOL> -- @remaining : integer <EOL> --     the number of remaining carrots thet exist in stock <EOL> -- <EOL> -- Constraints: <EOL> -- * 0 <= number <= 1000 <EOL> -- * 0 <= need <= 1000 <EOL> -- * 0 <= remaining <= 1000 <EOL> -- <EOL> -- Have fun :) <EOL> eat :: Int -> Int -> Int -> [Int] <EOL> eat number need remaining =", "gt": "if need <= remaining then [number + need, remaining - need] else [number + remaining, 0]", "prediction": " take"}
{"input": "<s> -- Return the largest prime factor of n. Assume n > 1 and is not a prime. <EOL> -- >>> largest_prime_factor 13195 <EOL> -- 29 <EOL> -- >>> largest_prime_factor 2048 <EOL> -- 2 <EOL> largest_prime_factor :: Int -> Int <EOL> largest_prime_factor n = maximum $ filter (\\x -> n `mod` x == 0) $ filter is_prime [2..n] <EOL>   where  <EOL>     is_prime :: Int -> Bool <EOL>     is_prime k = null [x | x <-", "gt": "[2..k-1], k `mod` x == 0]", "prediction": " [1..k], k `mod` x == 0]"}
{"input": "<s> -- Return the largest prime factor of n. Assume n > 1 and is not a prime. <EOL> -- >>> largest_prime_factor 13195 <EOL> -- 29 <EOL> -- >>> largest_prime_factor 2048 <EOL> -- 2 <EOL> largest_prime_factor :: Int -> Int <EOL> largest_prime_factor n = maximum $ filter (\\x -> n `mod` x == 0) $", "gt": "filter is_prime [2..n]", "prediction": " prime_factor n"}
{"input": "<s> -- Return the largest prime factor of n. Assume n > 1 and is not a prime. <EOL> -- >>> largest_prime_factor 13195 <EOL> -- 29 <EOL> -- >>> largest_prime_factor 2048 <EOL> -- 2 <EOL> largest_prime_factor :: Int -> Int <EOL> largest_prime_factor n = maximum $ filter (\\x -> n `mod` x == 0) $ filter is_prime [2..n] <EOL>   where  <EOL>     is_prime :: Int -> Bool <EOL>     is_prime k =", "gt": "null [x | x <- [2..k-1], k `mod` x == 0]", "prediction": " ("}
{"input": "<s> -- Return the largest prime factor of n. Assume n > 1 and is not a prime. <EOL> -- >>> largest_prime_factor 13195 <EOL> -- 29 <EOL> -- >>> largest_prime_factor 2048 <EOL> -- 2 <EOL> largest_prime_factor :: Int -> Int <EOL> largest_prime_factor n =", "gt": "maximum $ filter (\\x -> n `mod` x == 0) $ filter is_prime [2..n]", "prediction": " maximum"}
